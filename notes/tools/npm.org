Intro to NPM as a build tool

* Basics
** Scripts are stored in the package.json file
** npm init
*** runs wizard to create package.json
*** skip test command for now
*** "scripts" lets us execute scripts with npm 

** Installing Scripts
*** npm install
*** --save-dev
*** --save
** running scripts with npm
*** npm run-script <name-of-script>
*** npm run <name-of-script>
*** npm test == npm t == npm tst == npm run test

** npm stop
*** runs stop script

** npm restart
*** runs stop script, then start script
*** unless you make a script named restart

** adding custom scripts
*** simply name a new key:value in script object

** the value of a script, is just a unix command
*** ex: "node server.js"

** check out koa
*** minimalist framework works with generators?
     
* Pre and Post Hooks
** Hooks are scripts that contain pre- or -post; ex: pretest/posttest
*** hooks run automatically before and after the base script
*** order of appearance in package.json doesn't matter
*** hooks can be run on their own
** scripts can be chained by using a post-hook to "npm run next script"

* Scripts for Development and Test
** you can run multiple scripts with && 
*** "npm run this && npm run that"
*** if the first fails, the second is not run
** you can ignore errors by combining with ; instead of &&

** Bundling with browserify
*** lets you require modules client side
*** npm install browserify --save-dev
*** "browserify <targetpath> -o <bundlepath> 
*** -o tells browserify to bundle the first file to the second

** minifying with uglify
*** npm install uglify --save-dev
*** we want to pipe the result from the browserify to the uglify
*** "browserify <app.js> | uglify -mc > <endpath>"
*** -mc (flag to mangle and compress the file)
*** > redirection operator to output result

** chaining && piping | redirection >

** npm run <without any more arguments>
*** lists scripts at our disposal

* Scripts for Development: Watching
** mocha can watch tests, rerun if test change

** " -- " lets us pass arguments into another script
*** EX: "npm run test -- -w -R min"

** watch
*** takes a command and files to run as arguments

** nodemon
*** when a file/folder changes, restarts app
*** "nodemon --ignore client --ignore public index.js"
*** starts index.js file

** client side watching 
*** coffeescript and typescript have built in options
*** watchify ! from browserify
**** "watchify <from> -o <to> -dv"
***** -v verbose logging
***** -d delay (doesn't run processor at 100%
*** gotta trigger a bundling if you bundle/minify 
*** but then make changes to base files

** live browser reload
*** npm install live-reload --save-dev
**** in html, you must serve live-reload client
**** <script src="//localhost:8080" />
*** see npm for more details...

** run tasks concurrently with &

* Versioning, Pushing, and Deploying
** increment version number
*** Semantic Versioning x.y.z
**** major.minor.patch
**** breaking.feature.fix
*** npm version --help
*** npm version <major/minor/patch>
*** this can be scripted!

** versoning code to git
*** we can use npm version to set git tag
*** in package.sjon, repository, and repo url
*** npm version affects both package.json and git tag in repo
** pushing code to repo
*** git push --tags 

** deploy the app
*** as long as there's a command line interface for your provider
** heroku toolbelt
*** heroku create <name>
**** sets up a git remote
*** deploying is as simple as pushing to the heroku git remote
** launching the app

* Deploy Script and Additional Tricks
** Example process:
  - compile, bundle, & minify serverside javascript
  - bundle & minify client side JS
  - compile CSS
  - new version
  - push to github
  - deploy to heroku
  - open to verify success
