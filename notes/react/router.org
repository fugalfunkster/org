
* React Router v.4 Documentation
https://react-router.now.sh
React Router is a declarative way to render any UI at any location. React Router aims to use components and props as its sole API. At any time, you should be able to look at the render method of a component and understand what it's doing. If you need to redirect, block transitions, or match a location, you should be able to do so declaratively.
** Quick Start
*** First Principles
- Components: EVERYTHING IS A COMPONENT!
- A =location= is data that represents where a user is - or wants to go - in your app. It looks just like window.location.
- <Match/> turns a location into UI.
*** Router Components
Routers listen for URL changes and make the location available to other (nested?) components automatically.

#+BEGIN_SRC js
  const App = () => (
    <BrowserRouter>
      <div>
        ...
      </div>
    </BrowserRouter>
  )
#+END_SRC

*** Link Components
Link components look familiar, they still have a =to= prop with a path string. 

#+BEGIN_SRC js
const App = () => (
  <BrowserRouter>
    <div>
      <ul>
        <li><Link to="/">Home</Link></li>
        <li><Link to="/about">About</Link></li>
        <li><Link to="/topics">Topics</Link></li>
      </ul>
      ...
    </div>
  </BrowserRouter>
)
#+END_SRC
*** Match and Miss Components
Match components are new, and render a component by comparing the current location to a 
'pattern'. Miss components render in the absence of a match

#+BEGIN_SRC js
const App = () => (
  <BrowserRouter>
    <div>
      ... 
      <Match exactly pattern="/" component={Home} />
      <Match pattern="/about" component={About} />
      <Match pattern="/topics" component={Topics} />
      <Miss component={NoMatch}/>
    </div>
  </BrowserRouter>
)
#+END_SRC
*** Routing Props
Components rendered by a Match get some routing-specific props, like the portion of the parent 'pattern' that was matched against the current =location.pathname=. These can be destructured from the rendered component's props as =pathname= and =pattern=.
  For example, a component rendered by <Match pattern="/topics" /> would recieve props.pathname 
as "/topics". 
  This prop can be used to nest locations and URLs.

#+BEGIN_SRC js
...
const App = () => (
  <BrowserRouter>
    <div>
      <ul>
        ...
        <li><Link to="/topics">Topics</Link></li>
      </ul>
      ...
      <Match pattern="/topics" component={Topics} />
      ...
    </div>
  </BrowserRouter>
)

const Topics = ({ pathname, pattern }) => (
  <div>
    <h2>Topics</h2>
    <ul>
      <li><Link to={`${pathname}/rendering`}>Rendering with React</Link></li>
      <li><Link to={`${pathname}/components`}>Components</Link></li>
      <li><Link to={`${pathname}/props-v-state`}>Props v. State</Link></li>
    </ul>

     <Match pattern={`${pathname}/:topicId`} component={Topic}/>
     ...
  </div>
)

const Topic = ({ params }) => (
  <div>
    <h3>{params.topicId}</h3>
  </div>
)
...
#+END_SRC

*** Using the =render= prop for Inline Rendering

#+BEGIN_SRC js
  <Match pattern={pathname} exactly render={() => (
      <h3>Please select a topic</h3>
  )}/>
#+END_SRC

*** URL Parameters and Query Params

#+BEGIN_SRC js
...
  <Match pattern={`${pathname}/:topicId`} component={Topic}/>
...
const Topic = ({ params }) => (
  <div>
    <h3>{params.topicId}</h3>
  </div>
)
#+END_SRC



** API
*** BrowserRouter
The BrowserRouter component keeps your UI in sync with the browser history.

#+BEGIN_SRC js
  <BrowserRouter>
    <App/>
  </BrowserRouter>
#+END_SRC

The BrowserRouter can have a basename, which sets a base URL for all nested locations. This is ueful if your app is served from a sub-directory on your server, you'll want to se the basename to the subdirectory.

#+BEGIN_SRC js
<BrowserRouter basename="/calendar" />

// now links like this:
<Link to="/today"/>
// will generate links with an href to "/calendar/today"
#+END_SRC

*** HashRouter (avoid)
*** MemoryRouter (for non-browser apps)
Keeps the history of your “url” in memory (does not read or write to the address bar). Useful in non-browser environments like React Native.

#+BEGIN_SRC js
  <MemoryRouter>
    <App/>
  </MemoryRouter>
#+END_SRC

=initialEntries=
An array of locations in the history stack.

=initialIndex=
The initial location’s index in the array of initialEntries.
*** ServerRouter
Server rendering is a bit more involved to properly handle <Redirect> and 
<Miss> in your app. Not only do you want to respond with the proper status 
code, but also, both function on the result of rendering so we have to sort 
of recreate componentDidMount for the server. For the exceptional case of not 
matching any patterns you’ll use a two-pass render to render the <Miss> 
components.
  Here’s an example that sends 301 for redirects and properly renders your 
app when no patterns match the url:

#+BEGIN_SRC js

import { createServer } from 'http'
import React from 'react'
import { renderToString } from 'react-dom/server'
import { ServerRouter, createServerRenderContext } from 'react-router'

createServer((req, res) => {

  // first create a context for <ServerRouter>, it's where we keep the
  // results of rendering for the second pass if necessary
  const context = createServerRenderContext()

  // render the first time
  let markup = renderToString(
    <ServerRouter
      location={req.url}
      context={context}
    >
      <App/>
    </ServerRouter>
  )

  // get the result
  const result = context.getResult()

  // the result will tell you if it redirected, if so, we ignore
  // the markup and send a proper redirect.
  if (result.redirect) {
    res.writeHead(301, {
      Location: result.redirect.pathname
    })
    res.end()
  } else {

    // the result will tell you if there were any misses, if so
    // we can send a 404 and then do a second render pass with
    // the context to clue the <Miss> components into rendering
    // this time (on the client they know from componentDidMount)
    if (result.missed) {
      res.writeHead(404)
      markup = renderToString(
        <ServerRouter
          location={req.url}
          context={context}
        >
          <App/>
        </ServerRouter>
      )
    }
    res.write(markup)
    res.end()
  }
}).listen(3000)
#+END_SRC

=location: string=
The location the server received, probably req.url on a node server.

=context=
An object returned from createServerRenderContext. It keeps the rendering result so you know which status code to send and if you need to perform a second pass render to render the <Miss> components in your app.
*** Match
Renders UI when a pattern matches a location.
**** pattern: string
Any valid URL pattern that path-to-regexp understands.

#+BEGIN_SRC js
  <Match pattern="/users/:id" component={User}/>
#+END_SRC

**** exactly: bool
When true, will only match if the pattern matches the location.pathname exactly.

| pattern | location.pathname | exactly? | matches? |
|---------+-------------------+----------+----------|
| "/foo"  | "/foo/bar"        | yes      | no       |
| "/foo"  | "/foo/bar"        | no       | yes      |

#+BEGIN_SRC js
  <Match pattern="/foo" exactly component={Foo}/>
#+END_SRC

**** location
If you don’t want to match the location on context, you can pass a location 
as a prop instead.

#+BEGIN_SRC js
  <Match pattern="/foo" location={{ pathname: '/foo' }}/>
#+END_SRC

**** component
A React component constructor to render when the location matches. The component will be rendered with the following props:

- pattern: (string) the portion of the pattern matched.
- pathname: (string) the portion of pathname matched.
- isExact: (bool) whether or not the match is exact (v. partial).
- location: the location matched.
- params: the values parsed from the pathname corresponding by name to the dynamic segments of the pattern.

#+BEGIN_SRC js
class User extends React.Component {
  render() {
    const { location, pattern, pathname, isExact } = this.props
    const { id } = this.props.params

    return <pre>{JSON.stringify(this.props, null, 2)}</pre>
  }
}

<Match pattern="/user/:id" component={User}/>
#+END_SRC

**** render: func
Instead of having a component rendered for you, you can pass in a function 
to be called when the location matches. Your render function will be called 
with the same props that are passed to the component.
  This allows for convenient inline match rendering and wrapping.

#+BEGIN_SRC js
// convenient inline rendering
<Match pattern="/home" render={() => <div>Home</div>}/>

// wrapping/composing
const MatchWithFade = ({ component:Component, ...rest }) => (
  <Match {...rest} render={(matchProps) => (
    <FadeIn>
      <Component {...matchProps}/>
    </FadeIn>
  )}/>
)

<MatchWithFade pattern="/cool" component={Something}/>
#+END_SRC

**** children: func
Sometimes you need to render whether the pattern matches the location or 
not. In these cases, you can use the function children prop. It works 
exactly like render except that (1) it gets called whether there is a match 
or not and (2) includes a matched prop to indicate if there was a match.
  It seems unlikely you’ll need this for anything besides animating when a 
component transitions from matching to not matching and back, but who knows?

#+BEGIN_SRC js
<Match children={({ matched, ...rest}) => (
  {/* Animate will always render, so you can use lifecycles
      to animate its children */}
  <Animate>
    {matched && (
      <Something {...rest}/>
    )}
  </Animate>
)}/>
#+END_SRC

*** Miss
When no Match components match the current location, then a sibling Miss will 
render.

#+BEGIN_SRC js
const App = () => (
  <Router>
    <Match pattern="/foo"/>
    <Match pattern="/bar"/>
    <Miss component={NoMatch}/>
  </Router>
)

const NoMatch = ({ location }) => (
  <div>Nothing matched {location.pathname}.</div>
)
#+END_SRC

**** component
Same as component in Match, except the only prop passed is location.

#+BEGIN_SRC js
<Miss component={NoMatch}/>
#+END_SRC

**** render: func
Same as render in Match, except the only prop passed is location.

#+BEGIN_SRC js
  <Miss render={({ location }) => (
    <div>Nothing matched {location.pathname}.</div>
  )}/>
#+END_SRC

*** Link
Provides declarative, accessible navigation around your application.

#+BEGIN_SRC js
  <Link to="/about" activeClassName="active">
    About
  </Link>
#+END_SRC

**** children: node | func
The Link component also accepts a function as children. This will allow you 
to use custom component to render the link or use the router with 
react-native.
  Children function parameter is an object with the following keys:

- isActive: (bool) whenever the Link is active
- location: the location passed to the Link
- href: (string) with the router url
- onClick: (func) the dom onClick event handler
- transition: (func) a shortcut to router.transitionTo with the “to” setted 
  on the link

#+BEGIN_SRC js
  <Link to="/courses">
    {
      ({isActive, location, href, onClick, transition}) => 
        <RaisedButton
          label="Courses"
          onClick={onClick}
          primary={isActive}
          href={href} />
    }
  </Link>
#+END_SRC

**** to: string | object
The pathname or location descriptor to link to.

#+BEGIN_SRC js
  <Link to="/courses"/>
  <Link to={{
    pathname: '/courses',
    query: { sort: 'name' },
    state: { fromDashboard: true }
  }}/>
#+END_SRC

**** activeStyle: object
An object of styles to apply to the element when the location matches the 
link’s to prop. It will be merged after a style prop object.

#+BEGIN_SRC js
  <Link
    to="/courses"
    style={{ color: 'blue', background: 'gray' }}
    activeStyle={{ color: 'red' }}
  />
// will always have a gray background
// at /foo will be 'blue' (inactive)
// at /courses will be 'red' (active)
#+END_SRC

**** activeClassName: string
A className to apply when the location matches the link’s to prop.

#+BEGIN_SRC js
  <Link
    to="/courses"
    className="course-link"
    activeClassName="active"
  />
// will always have "course-link"
// at /courses it will be "course-link active"
#+END_SRC

**** activeOnlyWhenExact: bool
When true, the link will only apply activeClassName and activeStyle if the 
link’s to matches the location exactly.

#+BEGIN_SRC js
  <Link to="/courses" activeOnlyWhenExact activeClassName="active"/>
// at /courses this will be active
// at /courses/123 it will not be active
#+END_SRC

**** isActive: func
Allows for customized handling of whether or not the link is active. Return 
true for active, false for inactive.

#+BEGIN_SRC js
  <Link
    to="/"
    activeStyle={{ color: 'red' }}
    isActive={(location) => (
      // only be active if there is no query
      !Object.keys(location.query).length
    )}
  />

  <Link
    to="/courses"
    activeStyle={{ color: 'red' }}
    isActive={(location, props) => (
      // make it active for "/courses" and "/course/123"
      // Even though it's not technically active, it is
      // theoretically for the sake of a navigation menu
      location.pathname.match(/course(s)?/)
    )}
  />
#+END_SRC

**** location
If you don’t want to use the location from context, you can pass the 
location to match as a prop instead. Useful in redux apps for links deep in 
the hierarchy.

#+BEGIN_SRC js
  <Match pattern="/foo" location={this.props.location}/>
#+END_SRC

*** NavigationPrompt
When your application enters a state that should prevent the user from 
navigating away (like a form is half-filled out), render a NavigationPrompt.

#+BEGIN_SRC js
  {formIsHalfFilledOut && (
    <NavigationPrompt message="Are you sure you want to leave?"/>
  )}
#+END_SRC

**** message: string
The message to prompt the user with when they try to navigate away.

#+BEGIN_SRC js
  <NavigationPrompt message="Are you sure you want to leave?"/>
#+END_SRC

**** message: func
Will be called with the nextLocation the user is attempting to navigate to. 
Return a string to prompt the user with or true to allow the transition.

#+BEGIN_SRC js
  <NavigationPrompt message={(location) => (
    `Are you sure you want to go to ${location.pathname}?`
  )}/>
#+END_SRC

**** when: bool
Instead of guarding a NavigationPrompt behind a flag, you can always render 
it but pass true or false to when. If true, navigation will be blocked, if 
false, navigation will be allowed.

#+BEGIN_SRC js
  <NavigationPrompt when={formIsHalfFilledOut} message="Are you sure?"/>
#+END_SRC

*** Redirect
Rendering a Redirect will navigate to a new location and add the previous 
location onto the next location state. (If this freaks you out you can use 
the imperative API from the router on context.)

#+BEGIN_SRC js
  <Match pattern="/" exactly render={() => (
    loggedIn ? (
      <Redirect to="/dashboard"/>
    ) : (
      <PublicHomePage/>
    ) 
  )}/>
#+END_SRC

*** to: string
The pathname to redirect to.

#+BEGIN_SRC js
  <Redirect to="/somewhere/else" />
#+END_SRC

*** to: location
A location descriptor to redirect to.

#+BEGIN_SRC js
  <Redirect to={{
    pathname: '/login',
    query: { utm: 'your+face' },
    state: { referrer: currentLocation }
  }}/>
#+END_SRC


 * React Router v.2/3 Tutorial
** Rendering a Route
  
     At it's heart, React Router is a component:

#+BEGIN_SRC js

  render(<Router/>, document.getElementById('app'))

#+END_SRC

     To configure a route, we need to import functionality from react-router. The Router
     component, takes a history attribute (see hashHistory below). We nest Route
     components within the Router component. Each Route component takes a path
     attribute and a component attribute. The component attribute takes a react
     component as its value, and the path attribute takes a url string as its value.
     The path url string is the url path where the component will render.

#+BEGIN_SRC js

  import { Router, Route, hashHistory } from 'react-router';

  render((
    <Router history={hashHistory}>
      <Route path="/" component={App}/>
    </Router>
  ), document.getElementById('app'));

#+END_SRC

*** hashHistory
      hashHistory manages our routing history with the hash portion of the url. It's got
      that extra junk to shim some behavior the browser has natively when using real 
      urls. There are other options, like using real urls, but hashHistory doesn't
      require any server-side configuration.


*** Adding more routes

#+BEGIN_SRC js

  import React from 'react'
  import { render } from 'react-dom'
  import App from './modules/App'
  import About from './modules/About'
  import Repos from './modules/Repos'
  import { Router, Route, hashHistory } from 'react-router'

  render((
    <Router history={hashHistory}>
      <Route path="/" component={App}/>
      {/* add the routes here */}
      <Route path="/repos" component={Repos}/>
      <Route path="/about" component={About}/>
    </Router>
  ), document.getElementById('app'))

#+END_SRC
      
** Navigating with Link
     Links are perhaps the most used component in a React App. It's almost identical to
     an <a/> tag, except that it's aware of the Router it was rendered in. Link
     components have a to attribute, that takes a url path string as a value.
     Predictably, a link component takes the user to its specified path. Links are
     acceptable to browsers, facilitating backward/forward movement.
*** Example:

#+BEGIN_SRC js

  // modules/App.js
  import React from 'react'
  import { Link } from 'react-router'

  export default React.createClass({
    render() {
      return (
        <div>
          <h1>React Router Tutorial</h1>
          <ul role="nav">
            <li><Link to="/about">About</Link></li>
            <li><Link to="/repos">Repos</Link></li>
          </ul>
        </div>
      )
    }
  })

#+END_SRC

#+RESULTS:

** Nested Routes
     Apps are just a series of components nested inside other components. With Router,
     the routing is coupled to the nesting of components. Nested route components
     automatically become nested UI.
*** this.props.children
       We nest Route components in our call to render. Nested components Route
     components are accessablie to their parent component as {this.props.children}      
*** By Small and Simple Things are Great Things Brought to Pass
      Every route can be developed, and even rendered, as an independent application.
      Route configuration stitches component apps together. 
** Active Links
     One way that a Link component is different than an <a/> element, is that it
     knows if the path it links to is active, so you can style it differently.
*** Active Styles
      You can add an inline style to your Link using activeLink:

#+BEGIN_SRC js

  <li><Link to="/about" activeStyle={{ color: 'red' }}>About</Link></li>
  <li><Link to="/repos" activeStyle={{ color: 'red' }}>Repos</Link></li>

#+END_SRC

*** Active Class Name
      You can also use an active class name instead of inline styles:

#+BEGIN_SRC js

  <li><Link to="/about" activeClassName="active">About</Link></li>
  <li><Link to="/repos" activeClassName="active">Repos</Link></li>

#+END_SRC

      Of, course we'll need a stylesheet for that to be of any use. We can add one
      using a Link.

#+BEGIN_SRC js

  <link rel="stylesheet" href="index.css" />

#+END_SRC

#+BEGIN_SRC css

.active {
  color: green;
}

#+END_SRC

*** Nav Link Wrappers
      Most links in your site don't need to know they're active, usually just primary
      navigation links need to know. It's useful to wrap those so you don't have to
      remember what your activeClassName or activeStyle is everywhere.
        We can use the spread attribute to create a component that clones props and 
      includes specified props. 

#+BEGIN_SRC js

// modules/NavLink.js
import React from 'react'
import { Link } from 'react-router'

export default React.createClass({
  render() {
    return <Link {...this.props} activeClassName="active"/>
  }
})

#+END_SRC
#+BEGIN_SRC js

// App.js
import NavLink from './NavLink'

// ...

<li><NavLink to="/about">About</NavLink></li>
<li><NavLink to="/repos">Repos</NavLink></li>

#+END_SRC

** URL Params
     Consider the following urls:
       /repos/reactjs/react-router
       /repos/facebook/react
     These urls would match a route path like this:
       /repos/:username/:repoName
*** Adding a Route with Parameters
      Let's teach our app to render this component:

#+BEGIN_SRC js

  // modules/Repo.js
  import React from 'react'

  export default React.createClass({
    render() {
      return (
        <div>
          <h2>{this.props.params.repoName}</h2>
        </div>
      )
    }
  })

#+END_SRC      

      Now we must provide the route to the component.

#+BEGIN_SRC js

  // index.js
  import Repo from './modules/Repo'

  render((
    <Router history={hashHistory}>
      <Route path="/" component={App}>
        <Route path="/repos" component={Repos}/>
        {/* add the new route */}
        <Route path="/repos/:userName/:repoName" component={Repo}/>
        <Route path="/about" component={About}/>
      </Route>
    </Router>
  ), document.getElementById('app'))

#+END_SRC

      And we can add some links to this new route in repos.js:

#+BEGIN_SRC js

  // Repos.js
  import { Link } from 'react-router'
  // ...
  export default React.createClass({
    render() {
      return (
        <div>
          <h2>Repos</h2>

          {/* add some links */}
          <ul>
            <li><Link to="/repos/reactjs/react-router">React Router</Link></li>
            <li><Link to="/repos/facebook/react">React</Link></li>
          </ul>

        </div>
      )
    }
  })

#+END_SRC

      Now go test your links out. Note that the parameter name in the route path
      becomes the property name in the component. Both repoName and userName are
      available on this.props.params of your component. You should probably add some
      prop types to help others and yourself out later.

** More Nesting
     Notice how the list of links to different repositories goes away when we navigate
     to a repository? What if we want the list to persist, just like the global
     navigation persists?

#+BEGIN_SRC js

  // index.js
  // ...
  <Route path="/repos" component={Repos}>
    <Route path="/repos/:userName/:repoName" component={Repo}/>
  </Route>

#+END_SRC
#+BEGIN_SRC js

  // Repos.js
  // ...
  <div>
    <h2>Repos</h2>
    <ul>
      <li><Link to="/repos/reactjs/react-router">React Router</Link></li>
      <li><Link to="/repos/facebook/react">React</Link></li>
    </ul>
    {/* will render `Repo.js` when at /repos/:userName/:repoName */}
    {this.props.children}
  </div>

#+END_SRC

*** Active Links
      Let's bring in our NavLink from before so we can add the active class name to
      these links:

#+BEGIN_SRC js

  // modules/Repos.js
  // import it
  import NavLink from './NavLink'

  // ...
  <li><NavLink to="/repos/reactjs/react-router">React Router</NavLink></li>
  <li><NavLink to="/repos/facebook/react">React</NavLink></li>
  // ...

#+END_SRC

      Notice how both the /repos link up top and the individual repo links are both
      active? When child routes are active, so are the parents.

** Index Routes
     When we visit / in this app it's just our navigation and a blank page. We'd like
     to render a Home component there. Lets create a Home component and then talk
     about how to render it at /.

#+BEGIN_SRC js

  // modules/Home.js
  import React from 'react'

  export default React.createClass({
    render() {
      return <div>Home</div>
    }
  })

#+END_SRC

     One option is to see if we have any children in App, and if not, render Home:

#+BEGIN_SRC js

  // App.js
  import Home from './Home'

  // ...
  <div>
    {/* ... */}
    {this.props.children || <Home/>}
  </div>
  //...

#+END_SRC

     This would work fine, but its likely we'll want Home to be attached to a route
     like About and Repos in the future. A few reasons include:
       1. Participating in a data fetching abstraction that relies on matched routes
          and their components.
       2. Participating in onEnter hooks
       3. Participating in code-splitting
     Also, it just feels good to keep App decoupled from Home and let the route
     config decide what to render as the children. Remember, we want to build small
     apps inside small apps, not big ones!

Lets add a new route to index.js.

#+BEGIN_SRC js 

  // index.js
  // new imports:
  // add `IndexRoute` to 'react-router' imports
  import { Router, Route, hashHistory, IndexRoute } from 'react-router'
  // and the Home component
  import Home from './modules/Home'

  // ...

  render((
    <Router history={hashHistory}>
      <Route path="/" component={App}>

        {/* add it here, as a child of `/` */}
        <IndexRoute component={Home}/>

        <Route path="/repos" component={Repos}>
          <Route path="/repos/:userName/:repoName" component={Repo}/>
        </Route>
        <Route path="/about" component={About}/>
      </Route>
    </Router>
  ), document.getElementById('app'))

#+END_SRC


      Now open http://localhost:8080 and you'll see the new component is rendered.
        Notice how the IndexRoute has no path. It becomes this.props.children of the
      parent when no other child of the parent matches, or in other words, when the
      parent's route matches exactly.
        Index routes can twist people's brains up sometimes. Hopefully it will sink in
      with a bit more time. Just think about a web server that looks for index.html
      when you're at /. Same idea, React Router looks for an index route if a route's
      path matches exactly.

** Index Links
     Have you noticed in our app that we don't have any navigation to get back to
     rendering the Home component?
       Lets add a link to / and see what happens:

#+BEGIN_SRC js

  // in App.js
  // ...
  <li><NavLink to="/">Home</NavLink></li>
  // ...

#+END_SRC

     Now navigate around. Notice anything weird? The link to Home is always active!
     As we learned earlier, parent routes are active when child routes are active.
     Unfortunately, / is the parent of everything.
       For this link, we want it to only be active when the index route is active.
     There are two ways to let the router know you're linking to the "index route"
     so it only adds the active class (or styles) when the index route is rendered.

*** IndexLink
      First lets use the IndexLink

#+BEGIN_SRC js

  // App.js
  import { IndexLink, Link } from 'react-router'

  // ...
  <li><IndexLink to="/" activeClassName="active">Home</IndexLink></li>

#+END_SRC

*** onlyActiveOnIndex Property
      We can use Link as well by passing it the onlyActiveOnIndex prop (IndexLink
      just wraps Link with this property for convenience).

#+BEGIN_SRC js

  <li><Link to="/" activeClassName="active" onlyActiveOnIndex={true}>Home</Link></li>

#+END_SRC

     That's fine, but we already abstracted away having to know what the
     activeClassName is with Nav.
       Remember, in NavLink we're passing along all of our props to Link with the
     {...spread} syntax, so we can actually add the prop when we render a NavLink
     and it will make its way down to the Link:

#+BEGIN_SRC js

  <li><NavLink to="/" onlyActiveOnIndex={true}>Home</NavLink></li>

#+END_SRC

** Clean URLs with Browser History
     The URLs in our app right now are built on a hack: the hash. Its the default
     because it will always work, but there's a better way.
       Modern browsers let JavaScript manipulate the URL without making an http
     request, so we don't need to rely on the hash (#) portion of the url to do
     routing, but there's a catch (we'll get to it later).
*** Configuring Browser History
      Open up index.js and import browserHistory instead of hashHistory.

#+BEGIN_SRC js

  // index.js
  // ...
  // bring in `browserHistory` instead of `hashHistory`
  import { Router, Route, browserHistory, IndexRoute } from 'react-router'

  render((
    <Router history={browserHistory}>
      {/* ... */}
    </Router>
  ), document.getElementById('app'))

#+END_SRC

      Now go click around and admire your clean urls.
      Oh yeah, the catch. Click on a link and then refresh your browser. What happens?

        Cannot GET /repos

*** Configuring Your Server
      Your server needs to deliver your app no matter what url comes in, because
      your app, in the browser, is manipulating the url. Our current server doesn't
      know how to handle the URL.
        The Webpack Dev Server has an option to enable this. Open up package.json
      and add --history-api-fallback.

      "start": "webpack-dev-server --inline --content-base . --history-api-fallback"

      We also need to change our relative paths to absolute paths in index.html
      since the urls will be at deep paths and the app, if it starts at a deep path,
      won't be able to find the files.

#+BEGIN_SRC html

  <!-- index.html -->
  <!-- index.css -> /index.css -->
  <link rel=stylesheet href=/index.css>

  <!-- bundle.js -> /bundle.js -->
  <script src="/bundle.js"></script>

#+END_SRC

      Stop your server if it's running, then npm start again. Look at those clean urls
      :)

** Production-ish Server
     None of this has anything to do with React Router, but since we're talking
     about web servers, we might as well take it one step closer to the real-world.
     We'll also need it for server rendering in the next section.
       Webpack dev server is not a production server. Let's make a production
     server and a little environment-aware script to boot up the right server
     depending on the environment.

     Let's install a couple modules:

       npm install express if-env compression --save

     First, we'll use the handy if-env in package.json. Update your scripts entry in
     package.json to look like this:

#+BEGIN_SRC js

  // package.json
  "scripts": {
    "start": "if-env NODE_ENV=production && npm run start:prod || npm run start:dev",
    "start:dev": "webpack-dev-server --inline --content-base . --history-api-fallback",
    "start:prod": "webpack && node server.js"
  },

#+END_SRC

     Now when we run npm start it will check if our NODE_ENV is production. If it is,
     we run npm run start:prod, if it's not, we run npm run start:dev.
       Now we're ready to create a production server with Express and add a new file
     at root dir. Here's a first attempt:

#+BEGIN_SRC js

  // server.js
  var express = require('express')
  var path = require('path')
  var compression = require('compression')

  var app = express()

  // serve our static stuff like index.css
  app.use(express.static(__dirname))

  // send all requests to index.html so browserHistory in React Router works
  app.get('*', function (req, res) {
    res.sendFile(path.join(__dirname, 'index.html'))
  })

  var PORT = process.env.PORT || 8080
  app.listen(PORT, function() {
    console.log('Production Express server running at localhost:' + PORT)
  })

#+END_SRC

Now run:

#+BEGIN_SRC bash

  NODE_ENV=production npm start
  # For Windows users:
  # SET NODE_ENV=production npm start

#+END_SRC
 
     Congratulations! You now have a production server for this app. After clicking
     around, try navigating to http://localhost:8080/package.json. Whoops. Let's
     fix that. We're going to shuffle around a couple files and update some paths
     scattered across the app.
       1. make a public directory.
       2. Move index.html and index.css into it.
     Now let's update server.js to point to the right directory for static assets:

#+BEGIN_SRC js

  // server.js
  // ...
  // add path.join here
  app.use(express.static(path.join(__dirname, 'public')))

  // ...
  app.get('*', function (req, res) {
    // and drop 'public' in the middle of here
    res.sendFile(path.join(__dirname, 'public', 'index.html'))
  })

#+END_SRC

     We also need to tell wepback to build to this new directory:

#+BEGIN_SRC js

  // webpack.config.js
  // ...
  output: {
    path: 'public',
    // ...
  }

#+END_SRC

     And finally (!) add it to the --content-base argument to npm run start:dev script:

#+BEGIN_SRC json

  "start:dev": "webpack-dev-server --inline --content-base public --history-api-fallback",

#+END_SRC     

     If we had the time in this tutorial, we could use the WebpackDevServer API in a
     JavaScript file instead of the CLI in an npm script and then turn this path into
     config shared across all of these files. But, we're already on a tangent, so that
     will have to wait for another time.
       Okay, now that we aren't serving up the root of our project as public files,
     let's add some code minification to Webpack and gzipping to express.

#+BEGIN_SRC js

  // webpack.config.js

  // make sure to import this
  var webpack = require('webpack')

  module.exports = {
  // ...

    // add this handful of plugins that optimize the build
    // when we're in production
    plugins: process.env.NODE_ENV === 'production' ? [
      new webpack.optimize.DedupePlugin(),
      new webpack.optimize.OccurrenceOrderPlugin(),
      new webpack.optimize.UglifyJsPlugin()
    ] : [],

    // ...
  }

#+END_SRC

     And compression in express:

#+BEGIN_SRC js

  // server.js
  // ...
  var compression = require('compression')

  var app = express()
  // must be first!
  app.use(compression())

#+END_SRC

     Now go start your server in production mode:

       NODE_ENV=production npm start

     You'll see some UglifyJS logging and then in the browser, you can see the assets
     are being served with gzip compression.

** Navigating Programatically
     While most navigation happens with Link, you can programatically navigate around
     an application in response to form submissions, button clicks, etc.
       Let's make a little form in Repos that programatically navigates.

#+BEGIN_SRC js 

  // modules/Repos.js
  import React from 'react'
  import NavLink from './NavLink'

  export default React.createClass({
    // add this method
    handleSubmit(event) {
      event.preventDefault()
      const userName = event.target.elements[0].value
      const repo = event.target.elements[1].value
      const path = `/repos/${userName}/${repo}`
      console.log(path)
    },
    render() {
      return (
        <div>
          <h2>Repos</h2>
          <ul>
            <li><NavLink to="/repos/reactjs/react-router">React Router</NavLink></li>
            <li><NavLink to="/repos/facebook/react">React</NavLink></li>
            {/* add this form */}
            <li>
              <form onSubmit={this.handleSubmit}>
                <input type="text" placeholder="userName"/> / {' '}
                <input type="text" placeholder="repo"/>{' '}
                <button type="submit">Go</button>
              </form>
            </li>
          </ul>
          {this.props.children}
        </div>
      )
    }
  })

#+END_SRC

     There are two ways you can do this, the first is simpler than the second.
       First we can use the browserHistory singleton that we passed into Router in
     index.js and push a new url into the history.

#+BEGIN_SRC js 

  // Repos.js
  import { browserHistory } from 'react-router'

  // ...
    handleSubmit(event) {
      // ...
      const path = `/repos/${userName}/${repo}`
      browserHistory.push(path)
    },
  // ...

#+END_SRC


     There's a potential problem with this though. If you pass a different history to
     Router than you use here, it won't work. It's not very common to use anything
     other than browserHistory, so this is acceptable practice. If you're concerned
     about it, you can make a module that exports the history you want to use across
     the app, or...
       You can also use the router that Router provides on "context". First, you ask
     for context in the component, and then you can use it:

#+BEGIN_SRC js

  export default React.createClass({

    // ask for `router` from context
    contextTypes: {
      router: React.PropTypes.object
    },

    // ...

    handleSubmit(event) {
      // ...
      this.context.router.push(path)
    },

    // ..
  })

#+END_SRC


This way you'll be sure to be pushing to whatever history gets passed to Router. It also makes testing a bit easier since you can more easily stub context than singletons.

** TODO Server Rendering
     Alright, first things first. Server rendering, at its core is a simple concept
     in React.

#+BEGIN_SRC js

  render(<App/>, domNode)
  // can be rendered on the server as
  const markup = renderToString(<App/>)

#+END_SRC


     It's not rocket science, but it also isn't trivial. First I'm going to just
     throw a bunch of webpack shenanigans at you with little explanation, then
     we'll talk about the Router.
       Since node doesn't (and shouldn't) understand JSX, we need to compile the code
     somehow. Using something like babel/register is not fit for production use, so
     we'll use webpack to build a server bundle, just like we use it to build a
     client bundle.

     Make a new file called webpack.server.config.js and put this stuff in there:

#+BEGIN_SRC js


var fs = require('fs')
var path = require('path')

module.exports = {

  entry: path.resolve(__dirname, 'server.js'),

  output: {
    filename: 'server.bundle.js'
  },

  target: 'node',

  // keep node_module paths out of the bundle
  externals: fs.readdirSync(path.resolve(__dirname, 'node_modules')).concat([
    'react-dom/server', 'react/addons',
  ]).reduce(function (ext, mod) {
    ext[mod] = 'commonjs ' + mod
    return ext
  }, {}),

  node: {
    __filename: true,
    __dirname: true
  },

  module: {
    loaders: [
      { test: /\.js$/, exclude: /node_modules/, loader: 'babel-loader?presets[]=es2015&presets[]=react' }
    ]
  }

}

#+END_SRC


     Hopefully some of that makes sense, we aren't going to cover what all of that
     stuff does, it's sufficient to say that now we can run our server.js file through
     webpack and then run it.
       Now we need to make some scripts to build server bundle before we try to run
     our app. Update your package.json script config to look like this:

#+BEGIN_SRC js

"scripts": {
  "start": "if-env NODE_ENV=production && npm run start:prod || npm run start:dev",
  "start:dev": "webpack-dev-server --inline --content-base public/ --history-api-fallback",
  "start:prod": "npm run build && node server.bundle.js",
  "build:client": "webpack",
  "build:server": "webpack --config webpack.server.config.js",
  "build": "npm run build:client && npm run build:server"
},

#+END_SRC

     Now when we run NODE_ENV=production npm start both the client and server bundles
     get created by Webpack.
       Okay, let's talk about the Router. We're going to need our routes split out into
     a module so that both the client and server entries can require it. Make a file at
     modules/routes and move your routes and components into it.

#+BEGIN_SRC js

// modules/routes.js
import React from 'react'
import { Route, IndexRoute } from 'react-router'
import App from './App'
import About from './About'
import Repos from './Repos'
import Repo from './Repo'
import Home from './Home'

module.exports = (
  <Route path="/" component={App}>
    <IndexRoute component={Home}/>
    <Route path="/repos" component={Repos}>
      <Route path="/repos/:userName/:repoName" component={Repo}/>
    </Route>
    <Route path="/about" component={About}/>
  </Route>
)
// index.js
import React from 'react'
import { render } from 'react-dom'
import { Router, browserHistory } from 'react-router'
// import routes and pass them into <Router/>
import routes from './modules/routes'

render(
  <Router routes={routes} history={browserHistory}/>,
  document.getElementById('app')
)

#+END_SRC


     Now open up server.js. We're going to bring in two modules from React Router to
     help us render on the server.
       If we tried to render a <Router/> on the server like we do in the client, we'd
     get an empty screen since server rendering is synchronous and route matching is
     asynchronous.
       Also, most apps will want to use the router to help them load data, so
     asynchronous routes or not, you'll want to know what screens are going to render
     before you actually render so you can use that information to load asynchronous
     data before rendering. We don't have any data loading in this app, but you'll see
     where it could happen.
       First we import match and RouterContext from react router, then we'll match the
     routes to the url, and finally render.

#+BEGIN_SRC js

// ...
// import some new stuff
import React from 'react'
// we'll use this to render our app to an html string
import { renderToString } from 'react-dom/server'
// and these to match the url to routes and then render
import { match, RouterContext } from 'react-router'
import routes from './modules/routes'

// ...

// send all requests to index.html so browserHistory works

app.get('*', (req, res) => {
  // match the routes to the url
  match({ routes: routes, location: req.url }, (err, redirect, props) => {
    // `RouterContext` is the what `Router` renders. `Router` keeps these
    // `props` in its state as it listens to `browserHistory`. But on the
    // server our app is stateless, so we need to use `match` to
    // get these props before rendering.
    const appHtml = renderToString(<RouterContext {...props}/>)

    // dump the HTML into a template, lots of ways to do this, but none are
    // really influenced by React Router, so we're just using a little
    // function, `renderPage`
    res.send(renderPage(appHtml))
  })
})

function renderPage(appHtml) {
  return `
    <!doctype html public="storage">
    <html>
    <meta charset=utf-8/>
    <title>My First React Router App</title>
    <link rel=stylesheet href=/index.css>
    <div id=app>${appHtml}</div>
    <script src="/bundle.js"></script>
   `
}

var PORT = process.env.PORT || 8080
app.listen(PORT, function() {
  console.log('Production Express server running at localhost:' + PORT)
})

#+END_SRC


     And that's it. Now if you run NODE_ENV=production npm start and visit the app,
     you can view source and see that the server is sending down our app to the
     browser. As you click around, you'll notice the client app has taken over and
     doesn't make requests to the server for UI. Pretty cool yeah?!
       Our callback to match is a little naive, here's what a production version
     would look like:

#+BEGIN_SRC js

app.get('*', (req, res) => {
  match({ routes: routes, location: req.url }, (err, redirect, props) => {
    // in here we can make some decisions all at once
    if (err) {
      // there was an error somewhere during route matching
      res.status(500).send(err.message)
    } else if (redirect) {
      // we haven't talked about `onEnter` hooks on routes, but before a
      // route is entered, it can redirect. Here we handle on the server.
      res.redirect(redirect.pathname + redirect.search)
    } else if (props) {
      // if we got props then we matched a route and can render
      const appHtml = renderToString(<RouterContext {...props}/>)
      res.send(renderPage(appHtml))
    } else {
      // no errors, no redirect, we just didn't match anything
      res.status(404).send('Not Found')
    }
  })
})

#+END_SRC

     Server rendering is really new. There aren't really "best practices" yet,
     especially when it comes to data loading, so this tutorial is done, dropping
     you off at the bleeding edge


* Getting Started with React Router - Joe Maddalone
** Router, Route, and Link Components
*** Router
The router component is the parent-most component in our app.
*** Route
Route components nest inside the Router component. Routes take a 'path' and a 'component' 
prop. The path is the url path at which the specified component will render. 
*** Link
Operates like an anchor tag, instead of an href we use a 'to' prop. 
*** Source:

#+BEGIN_SRC js

import React from 'react';
import {Router, Route, Link, hashHistory} from 'react-router';

const Home = () => <div><h1>Home</h1><Links /></div>;
const About = () => <div><h1>About</h1><Links /></div>;
const Contact = () => <div><h1>Contact</h1><Links /></div>;

const Links = () => 
  <nav>
    <Link to="/">Home</Link>
    <Link to="/about">About</Link>
    <Link to="/contact">Contact</Link>
</nav>

class App extends React.Component {
  render(){
    return (
      <Router history={hashHistory}>
        <Route path="/" component={Home}></Route>
        <Route path="/about" component={About}></Route>
        <Route path="/contact" component={Contact}></Route>
      </Router>
    )
  }
}

export default App;

#+END_SRC
** hashHistory vs. browserHistory
hashHistory is convienent for development, but for production, it's best to use browserHistory 
to avoid the uglyurl strings generated by hashHistory. In order to use browserHistory, we need 
to instruct our server to return our application at any route. For example, in a node/express 
server, we would serve index.html whenever a route is called. react-router will handle the rest 
for us.
** activeStyle & activeClassName
The 'activeStyle' prop allows us to style our link differently when it is the current route.
activeStyle works just like the 'style' prop:
#+BEGIN_SRC js
  <Link activeStyle={{color: 'green'}} to="/">Home</Link>
#+END_SRC

The activeClassName works similarly:
#+BEGIN_SRC js
  <Link activeClassName="active" to="/">Home</Link>
#+END_SRC

** Nested Routes
When we want to create nested routes, it's as simple as nesting the Route components within 
the Router component, rendering each nested Route's component as 'props.children' in the parent Route's component, and matching our Link component's path.  

*** Source

#+BEGIN_SRC js

import React from 'react';
import {Router, Route, Link, hashHistory} from 'react-router';

const Home = () => <div><h1>Home</h1><Links />{props.children}</div>;
const About = () => <div><h1>About</h1>{props.children}</div>;
const Contact = () => <div><h1>Contact</h1></div>;

const Links = () => 
  <nav>
    <Link to="/">Home</Link>
    <Link to="/about">About</Link>
    <Link to="/about/contact">Contact</Link>
</nav>

class App extends React.Component {
  render(){
    return (
      <Router history={hashHistory}>
        <Route path="/" component={Home}>
          <Route path="/about" component={About}>
            <Route path="/contact" component={Contact}></Route>
          </Route>
        </Route>
      </Router>
    )
  }
}

export default App;

#+END_SRC
** IndexRoutes
Index routes alow us to render a default component when no other route is active.
*** Source:

#+BEGIN_SRC js

import React from 'react';
import {Router, Route, Link, IndexRoute, hashHistory} from 'react-router';

const Outer = () => <div><h1>Our Site</h1><Links />{props.children}</div>;
const About = () => <div><h1>About</h1></div>;
const Contact = () => <div><h1>Contact</h1></div>;

const Links = () => 
  <nav>
    <Link to="/">Home</Link>
    <Link to="/about">About</Link>
    <Link to="/contact">Contact</Link>
</nav>

class App extends React.Component {
  render(){
    return (
      <Router history={hashHistory}>
        <Route path="/" component={Outer}>
          <IndexRoute component={About}></IndexRoute>
          <Route path="contact" component={Contact}></Route>
        </Route>
      </Router>
    )
  }
}

export default App;

#+END_SRC

** Route Parameters
Route parameters allow us to pass in a portion of our route-url-path as a property (props.params.message) of the component that the Route Component will render. 
*** Source

#+BEGIN_SRC js

import React from 'react';
import {Router, Route, Link, hashHistory} from 'react-router';

const Message = (props) => <div><h1>{props.params.message || Hello!}</h1><Links /></div>;

const Links = () =>
  <nav>
    <Link to="/">Hello</Link>
    <Link to="/Hi">Hi</Link>
    <Link to="/Yo">Yo</Link>
  </nav>

class App extends React.Component {
  render(){
    return (
      <Router history={hashHistory}>
        <Route path="/(:message)" component={Message}></Route>
      </Router>
    )
  }
}

export default App;

#+END_SRC

** Named Components
We can render multiple components from a single route using 'named' components. 

*** Source
#+BEGIN_SRC js

import React from 'react';
import {Router, Route, Link, IndexRoute, hashHistory} from 'react-router';

const Home = () => <h1>Home</h1>;
const HomeBody = () => <div>this is the home body</div>;
const Other = () => <h1>Other</h1>;
const OtherBody = () => <div>this is the other body</div>;

const Container = (props) =>
  <div>{props.header}{props.body}<Links /></div>

const Links = () => 
  <nav>
    <Link to="/">Home</Link>
    <Link to="/other">Other</Link>
</nav>

class App extends React.Component {
  render(){
    return (
      <Router history={hashHistory}>
        <Route path="/" component={Container}>
          <IndexRoute components={{ header: Home, body: HomeBody}}></IndexRoute>
          <Route path="/other" components={{ header: Other, body: OtherBody}}></Route>
        </Route>
      </Router>
    )
  }
}

export default App;

#+END_SRC

** Querystring Parameters
We can pass in query strings as props (props.location.query.queryKey) to any component that will render at a specific route. Query strings follow a '?' and are key value pairs 'key=value' separated by '&'. 

*** Source
#+BEGIN_SRC js

import React from 'react';
import {Router, Route, Link, hashHistory} from 'react-router';

const Page = (props) =>
  <div><h1>{Props.location.query.message || 'Hello'}</h1></div>

const Links = () => 
  <nav>
    <Link to={{pathname: "/", query: {message: "Yo"}}}>Yo</Link>
  </nav>

class App extends React.Component {
  render(){
    return (
      <Router history={hashHistory}>
        <Route path="/" component={Page}></Route>
      </Router>
    )
  }
}

export default App;

#+END_SRC

** Redirect
The Redirect component in react-router does exactly what it sounds like. It allows us to 
redirect from from one route to another.

*** Source
#+BEGIN_SRC js

import React from 'react';
import {Router, Route, Redirect, Link, hashHistory} from 'react-router';

const Home = () => <div><h1>Home</h1><Links /></div>;
const About = () => <div><h1>About Us</h1><Links /></div>;
const Contact = () => <div><h1>Contact</h1><Links /></div>;

const Links = () => 
  <nav>
    <Link to="/">Home</Link>
    <Link to="/about">About</Link >
    <Link to="/about-us">About Us</Link >
    <Link to="/contact">Contact</Link>
</nav>

class App extends React.Component {
  render(){
    return (
      <Router history={hashHistory}>
        <Route path="/" component={Home}></Route>
        <Route path="/about-us" component={About}></Route>
        <Redirect from='/about' to='/about-us'></Redirect>
        <Route path="/contact" component={Contact}></Route>
      </Router>
    )
  }
}

export default App;

#+END_SRC

** setRouteWillLeaveHook
setRouteWillLeaveHook provides a method for us to intercept a route change before leaving the current route. But, this method exists on the Router component, so we must use context to access it. 

*** Source
#+BEGIN_SRC js
import React from 'react';
import { Router, Route, Link, hashHistory } from 'react-router';

// const Home = () => <div><h1>Home</h1><Links /></div>;

class Home extends React.Component {
  componentWillMount(){
    this.context.router.setRouteLeaveHook(
      this.props.route,
      this.routerWillLeave
    )
  }
  routerWillLeave( nextLocation ){
    return `leaving home for ${nextLocation.pathname}`
  }
  render(){
    return <div><h1>Home</h1><Links /></div>;
  }
}
Home.contextTypes = { router: React.PropTypes.object.isRequired }

const About = () => <div><h1>About</h1><Links /></div>;
const Links = () => {
  return (
    <nav>
      <Link to="/">Home</Link>
      <Link to="about">About</Link>
    </nav>
  )
};

const App = () => {
  return (
    <Router history={ hashHistory }>
      <Route path="/" component={Home}></Route>
      <Route path="/about" component={About}></Route>
    </Router>
  )
};

export default App;
#+END_SRC

