* Notes on react-router tutorial
** Rendering a Route
  
     At it's heart, React Router is a component:

#+BEGIN_SRC js

  render(<Router/>, document.getElementById('app'))

#+END_SRC

     To configure a route, we need to import functionality from react-router. The Router
     component, takes a history attribute (see hashHistory below). We nest Route
     components within the Router component. Each Route component takes a path
     attribute and a component attribute. The component attribute takes a react
     component as its value, and the path attribute takes a url string as its value.
     The path url string is the url path where the component will render.

#+BEGIN_SRC js

  import { Router, Route, hashHistory } from 'react-router';

  render((
    <Router history={hashHistory}>
      <Route path="/" component={App}/>
    </Router>
  ), document.getElementById('app'));

#+END_SRC

*** hashHistory
      hashHistory manages our routing history with the hash portion of the url. It's got
      that extra junk to shim some behavior the browser has natively when using real 
      urls. There are other options, like using real urls, but hashHistory doesn't
      require any server-side configuration.


*** Adding more routes

#+BEGIN_SRC js

  import React from 'react'
  import { render } from 'react-dom'
  import App from './modules/App'
  import About from './modules/About'
  import Repos from './modules/Repos'
  import { Router, Route, hashHistory } from 'react-router'

  render((
    <Router history={hashHistory}>
      <Route path="/" component={App}/>
      {/* add the routes here */}
      <Route path="/repos" component={Repos}/>
      <Route path="/about" component={About}/>
    </Router>
  ), document.getElementById('app'))

#+END_SRC
      
** Navigating with Link
     Links are perhaps the most used component in a React App. It's almost identical to
     an <a/> tag, except that it's aware of the Router it was rendered in. Link
     components have a to attribute, that takes a url path string as a value.
     Predictably, a link component takes the user to its specified path. Links are
     acceptable to browsers, facilitating backward/forward movement.
*** Example:

#+BEGIN_SRC js

  // modules/App.js
  import React from 'react'
  import { Link } from 'react-router'

  export default React.createClass({
    render() {
      return (
        <div>
          <h1>React Router Tutorial</h1>
          <ul role="nav">
            <li><Link to="/about">About</Link></li>
            <li><Link to="/repos">Repos</Link></li>
          </ul>
        </div>
      )
    }
  })

#+END_SRC

#+RESULTS:

** Nested Routes
     Apps are just a series of components nested inside other components. With Router,
     the routing is coupled to the nesting of components. Nested route components
     automatically become nested UI.
*** this.props.children
       We nest Route components in our call to render. Nested components Route
     components are accessablie to their parent component as {this.props.children}      
*** By Small and Simple Things are Great Things Brought to Pass
      Every route can be developed, and even rendered, as an independent application.
      Route configuration stitches component apps together. 
** Active Links
     One way that a Link component is different than an <a/> element, is that it
     knows if the path it links to is active, so you can style it differently.
*** Active Styles
      You can add an inline style to your Link using activeLink:

#+BEGIN_SRC js

  <li><Link to="/about" activeStyle={{ color: 'red' }}>About</Link></li>
  <li><Link to="/repos" activeStyle={{ color: 'red' }}>Repos</Link></li>

#+END_SRC

*** Active Class Name
      You can also use an active class name instead of inline styles:

#+BEGIN_SRC js

  <li><Link to="/about" activeClassName="active">About</Link></li>
  <li><Link to="/repos" activeClassName="active">Repos</Link></li>

#+END_SRC

      Of, course we'll need a stylesheet for that to be of any use. We can add one
      using a Link.

#+BEGIN_SRC js

  <link rel="stylesheet" href="index.css" />

#+END_SRC

#+BEGIN_SRC css

.active {
  color: green;
}

#+END_SRC

*** Nav Link Wrappers
      Most links in your site don't need to know they're active, usually just primary
      navigation links need to know. It's useful to wrap those so you don't have to
      remember what your activeClassName or activeStyle is everywhere.
        We can use the spread attribute to create a component that clones props and 
      includes specified props. 

#+BEGIN_SRC js

// modules/NavLink.js
import React from 'react'
import { Link } from 'react-router'

export default React.createClass({
  render() {
    return <Link {...this.props} activeClassName="active"/>
  }
})

#+END_SRC
#+BEGIN_SRC js

// App.js
import NavLink from './NavLink'

// ...

<li><NavLink to="/about">About</NavLink></li>
<li><NavLink to="/repos">Repos</NavLink></li>

#+END_SRC

** URL Params
     Consider the following urls:
       /repos/reactjs/react-router
       /repos/facebook/react
     These urls would match a route path like this:
       /repos/:username/:repoName
*** Adding a Route with Parameters
      Let's teach our app to render this component:

#+BEGIN_SRC js

  // modules/Repo.js
  import React from 'react'

  export default React.createClass({
    render() {
      return (
        <div>
          <h2>{this.props.params.repoName}</h2>
        </div>
      )
    }
  })

#+END_SRC      

      Now we must provide the route to the component.

#+BEGIN_SRC js

  // index.js
  import Repo from './modules/Repo'

  render((
    <Router history={hashHistory}>
      <Route path="/" component={App}>
        <Route path="/repos" component={Repos}/>
        {/* add the new route */}
        <Route path="/repos/:userName/:repoName" component={Repo}/>
        <Route path="/about" component={About}/>
      </Route>
    </Router>
  ), document.getElementById('app'))

#+END_SRC

      And we can add some links to this new route in repos.js:

#+BEGIN_SRC js

  // Repos.js
  import { Link } from 'react-router'
  // ...
  export default React.createClass({
    render() {
      return (
        <div>
          <h2>Repos</h2>

          {/* add some links */}
          <ul>
            <li><Link to="/repos/reactjs/react-router">React Router</Link></li>
            <li><Link to="/repos/facebook/react">React</Link></li>
          </ul>

        </div>
      )
    }
  })

#+END_SRC

      Now go test your links out. Note that the parameter name in the route path
      becomes the property name in the component. Both repoName and userName are
      available on this.props.params of your component. You should probably add some
      prop types to help others and yourself out later.

** More Nesting
     Notice how the list of links to different repositories goes away when we navigate
     to a repository? What if we want the list to persist, just like the global
     navigation persists?

#+BEGIN_SRC js

  // index.js
  // ...
  <Route path="/repos" component={Repos}>
    <Route path="/repos/:userName/:repoName" component={Repo}/>
  </Route>

#+END_SRC
#+BEGIN_SRC js

  // Repos.js
  // ...
  <div>
    <h2>Repos</h2>
    <ul>
      <li><Link to="/repos/reactjs/react-router">React Router</Link></li>
      <li><Link to="/repos/facebook/react">React</Link></li>
    </ul>
    {/* will render `Repo.js` when at /repos/:userName/:repoName */}
    {this.props.children}
  </div>

#+END_SRC

*** Active Links
      Let's bring in our NavLink from before so we can add the active class name to
      these links:

#+BEGIN_SRC js

  // modules/Repos.js
  // import it
  import NavLink from './NavLink'

  // ...
  <li><NavLink to="/repos/reactjs/react-router">React Router</NavLink></li>
  <li><NavLink to="/repos/facebook/react">React</NavLink></li>
  // ...

#+END_SRC

      Notice how both the /repos link up top and the individual repo links are both
      active? When child routes are active, so are the parents.

** Index Routes
     When we visit / in this app it's just our navigation and a blank page. We'd like
     to render a Home component there. Lets create a Home component and then talk
     about how to render it at /.

#+BEGIN_SRC js

  // modules/Home.js
  import React from 'react'

  export default React.createClass({
    render() {
      return <div>Home</div>
    }
  })

#+END_SRC

     One option is to see if we have any children in App, and if not, render Home:

#+BEGIN_SRC js

  // App.js
  import Home from './Home'

  // ...
  <div>
    {/* ... */}
    {this.props.children || <Home/>}
  </div>
  //...

#+END_SRC

     This would work fine, but its likely we'll want Home to be attached to a route
     like About and Repos in the future. A few reasons include:
       1. Participating in a data fetching abstraction that relies on matched routes
          and their components.
       2. Participating in onEnter hooks
       3. Participating in code-splitting
     Also, it just feels good to keep App decoupled from Home and let the route
     config decide what to render as the children. Remember, we want to build small
     apps inside small apps, not big ones!

Lets add a new route to index.js.

#+BEGIN_SRC js 

  // index.js
  // new imports:
  // add `IndexRoute` to 'react-router' imports
  import { Router, Route, hashHistory, IndexRoute } from 'react-router'
  // and the Home component
  import Home from './modules/Home'

  // ...

  render((
    <Router history={hashHistory}>
      <Route path="/" component={App}>

        {/* add it here, as a child of `/` */}
        <IndexRoute component={Home}/>

        <Route path="/repos" component={Repos}>
          <Route path="/repos/:userName/:repoName" component={Repo}/>
        </Route>
        <Route path="/about" component={About}/>
      </Route>
    </Router>
  ), document.getElementById('app'))

#+END_SRC


      Now open http://localhost:8080 and you'll see the new component is rendered.
        Notice how the IndexRoute has no path. It becomes this.props.children of the
      parent when no other child of the parent matches, or in other words, when the
      parent's route matches exactly.
        Index routes can twist people's brains up sometimes. Hopefully it will sink in
      with a bit more time. Just think about a web server that looks for index.html
      when you're at /. Same idea, React Router looks for an index route if a route's
      path matches exactly.

** Index Links
     Have you noticed in our app that we don't have any navigation to get back to
     rendering the Home component?
       Lets add a link to / and see what happens:

#+BEGIN_SRC js

  // in App.js
  // ...
  <li><NavLink to="/">Home</NavLink></li>
  // ...

#+END_SRC

     Now navigate around. Notice anything weird? The link to Home is always active!
     As we learned earlier, parent routes are active when child routes are active.
     Unfortunately, / is the parent of everything.
       For this link, we want it to only be active when the index route is active.
     There are two ways to let the router know you're linking to the "index route"
     so it only adds the active class (or styles) when the index route is rendered.

*** IndexLink
      First lets use the IndexLink

#+BEGIN_SRC js

  // App.js
  import { IndexLink, Link } from 'react-router'

  // ...
  <li><IndexLink to="/" activeClassName="active">Home</IndexLink></li>

#+END_SRC

*** onlyActiveOnIndex Property
      We can use Link as well by passing it the onlyActiveOnIndex prop (IndexLink
      just wraps Link with this property for convenience).

#+BEGIN_SRC js

  <li><Link to="/" activeClassName="active" onlyActiveOnIndex={true}>Home</Link></li>

#+END_SRC

     That's fine, but we already abstracted away having to know what the
     activeClassName is with Nav.
       Remember, in NavLink we're passing along all of our props to Link with the
     {...spread} syntax, so we can actually add the prop when we render a NavLink
     and it will make its way down to the Link:

#+BEGIN_SRC js

  <li><NavLink to="/" onlyActiveOnIndex={true}>Home</NavLink></li>

#+END_SRC

** Clean URLs with Browser History
     The URLs in our app right now are built on a hack: the hash. Its the default
     because it will always work, but there's a better way.
       Modern browsers let JavaScript manipulate the URL without making an http
     request, so we don't need to rely on the hash (#) portion of the url to do
     routing, but there's a catch (we'll get to it later).
*** Configuring Browser History
      Open up index.js and import browserHistory instead of hashHistory.

#+BEGIN_SRC js

  // index.js
  // ...
  // bring in `browserHistory` instead of `hashHistory`
  import { Router, Route, browserHistory, IndexRoute } from 'react-router'

  render((
    <Router history={browserHistory}>
      {/* ... */}
    </Router>
  ), document.getElementById('app'))

#+END_SRC

      Now go click around and admire your clean urls.
      Oh yeah, the catch. Click on a link and then refresh your browser. What happens?

        Cannot GET /repos

*** Configuring Your Server
      Your server needs to deliver your app no matter what url comes in, because
      your app, in the browser, is manipulating the url. Our current server doesn't
      know how to handle the URL.
        The Webpack Dev Server has an option to enable this. Open up package.json
      and add --history-api-fallback.

      "start": "webpack-dev-server --inline --content-base . --history-api-fallback"

      We also need to change our relative paths to absolute paths in index.html
      since the urls will be at deep paths and the app, if it starts at a deep path,
      won't be able to find the files.

#+BEGIN_SRC html

  <!-- index.html -->
  <!-- index.css -> /index.css -->
  <link rel=stylesheet href=/index.css>

  <!-- bundle.js -> /bundle.js -->
  <script src="/bundle.js"></script>

#+END_SRC

      Stop your server if it's running, then npm start again. Look at those clean urls
      :)

** Production-ish Server
     None of this has anything to do with React Router, but since we're talking
     about web servers, we might as well take it one step closer to the real-world.
     We'll also need it for server rendering in the next section.
       Webpack dev server is not a production server. Let's make a production
     server and a little environment-aware script to boot up the right server
     depending on the environment.

     Let's install a couple modules:

       npm install express if-env compression --save

     First, we'll use the handy if-env in package.json. Update your scripts entry in
     package.json to look like this:

#+BEGIN_SRC js

  // package.json
  "scripts": {
    "start": "if-env NODE_ENV=production && npm run start:prod || npm run start:dev",
    "start:dev": "webpack-dev-server --inline --content-base . --history-api-fallback",
    "start:prod": "webpack && node server.js"
  },

#+END_SRC

     Now when we run npm start it will check if our NODE_ENV is production. If it is,
     we run npm run start:prod, if it's not, we run npm run start:dev.
       Now we're ready to create a production server with Express and add a new file
     at root dir. Here's a first attempt:

#+BEGIN_SRC js

  // server.js
  var express = require('express')
  var path = require('path')
  var compression = require('compression')

  var app = express()

  // serve our static stuff like index.css
  app.use(express.static(__dirname))

  // send all requests to index.html so browserHistory in React Router works
  app.get('*', function (req, res) {
    res.sendFile(path.join(__dirname, 'index.html'))
  })

  var PORT = process.env.PORT || 8080
  app.listen(PORT, function() {
    console.log('Production Express server running at localhost:' + PORT)
  })

#+END_SRC

Now run:

#+BEGIN_SRC bash

  NODE_ENV=production npm start
  # For Windows users:
  # SET NODE_ENV=production npm start

#+END_SRC
 
     Congratulations! You now have a production server for this app. After clicking
     around, try navigating to http://localhost:8080/package.json. Whoops. Let's
     fix that. We're going to shuffle around a couple files and update some paths
     scattered across the app.
       1. make a public directory.
       2. Move index.html and index.css into it.
     Now let's update server.js to point to the right directory for static assets:

#+BEGIN_SRC js

  // server.js
  // ...
  // add path.join here
  app.use(express.static(path.join(__dirname, 'public')))

  // ...
  app.get('*', function (req, res) {
    // and drop 'public' in the middle of here
    res.sendFile(path.join(__dirname, 'public', 'index.html'))
  })

#+END_SRC

     We also need to tell wepback to build to this new directory:

#+BEGIN_SRC js

  // webpack.config.js
  // ...
  output: {
    path: 'public',
    // ...
  }

#+END_SRC

     And finally (!) add it to the --content-base argument to npm run start:dev script:

#+BEGIN_SRC json

  "start:dev": "webpack-dev-server --inline --content-base public --history-api-fallback",

#+END_SRC     

     If we had the time in this tutorial, we could use the WebpackDevServer API in a
     JavaScript file instead of the CLI in an npm script and then turn this path into
     config shared across all of these files. But, we're already on a tangent, so that
     will have to wait for another time.
       Okay, now that we aren't serving up the root of our project as public files,
     let's add some code minification to Webpack and gzipping to express.

#+BEGIN_SRC js

  // webpack.config.js

  // make sure to import this
  var webpack = require('webpack')

  module.exports = {
  // ...

    // add this handful of plugins that optimize the build
    // when we're in production
    plugins: process.env.NODE_ENV === 'production' ? [
      new webpack.optimize.DedupePlugin(),
      new webpack.optimize.OccurrenceOrderPlugin(),
      new webpack.optimize.UglifyJsPlugin()
    ] : [],

    // ...
  }

#+END_SRC

     And compression in express:

#+BEGIN_SRC js

  // server.js
  // ...
  var compression = require('compression')

  var app = express()
  // must be first!
  app.use(compression())

#+END_SRC

     Now go start your server in production mode:

       NODE_ENV=production npm start

     You'll see some UglifyJS logging and then in the browser, you can see the assets
     are being served with gzip compression.

** Navigating Programatically
     While most navigation happens with Link, you can programatically navigate around
     an application in response to form submissions, button clicks, etc.
       Let's make a little form in Repos that programatically navigates.

#+BEGIN_SRC js 

  // modules/Repos.js
  import React from 'react'
  import NavLink from './NavLink'

  export default React.createClass({
    // add this method
    handleSubmit(event) {
      event.preventDefault()
      const userName = event.target.elements[0].value
      const repo = event.target.elements[1].value
      const path = `/repos/${userName}/${repo}`
      console.log(path)
    },
    render() {
      return (
        <div>
          <h2>Repos</h2>
          <ul>
            <li><NavLink to="/repos/reactjs/react-router">React Router</NavLink></li>
            <li><NavLink to="/repos/facebook/react">React</NavLink></li>
            {/* add this form */}
            <li>
              <form onSubmit={this.handleSubmit}>
                <input type="text" placeholder="userName"/> / {' '}
                <input type="text" placeholder="repo"/>{' '}
                <button type="submit">Go</button>
              </form>
            </li>
          </ul>
          {this.props.children}
        </div>
      )
    }
  })

#+END_SRC

     There are two ways you can do this, the first is simpler than the second.
       First we can use the browserHistory singleton that we passed into Router in
     index.js and push a new url into the history.

#+BEGIN_SRC js 

  // Repos.js
  import { browserHistory } from 'react-router'

  // ...
    handleSubmit(event) {
      // ...
      const path = `/repos/${userName}/${repo}`
      browserHistory.push(path)
    },
  // ...

#+END_SRC


     There's a potential problem with this though. If you pass a different history to
     Router than you use here, it won't work. It's not very common to use anything
     other than browserHistory, so this is acceptable practice. If you're concerned
     about it, you can make a module that exports the history you want to use across
     the app, or...
       You can also use the router that Router provides on "context". First, you ask
     for context in the component, and then you can use it:

#+BEGIN_SRC js

  export default React.createClass({

    // ask for `router` from context
    contextTypes: {
      router: React.PropTypes.object
    },

    // ...

    handleSubmit(event) {
      // ...
      this.context.router.push(path)
    },

    // ..
  })

#+END_SRC


This way you'll be sure to be pushing to whatever history gets passed to Router. It also makes testing a bit easier since you can more easily stub context than singletons.

** TODO Server Rendering
     Alright, first things first. Server rendering, at its core is a simple concept
     in React.

#+BEGIN_SRC js

  render(<App/>, domNode)
  // can be rendered on the server as
  const markup = renderToString(<App/>)

#+END_SRC


     It's not rocket science, but it also isn't trivial. First I'm going to just
     throw a bunch of webpack shenanigans at you with little explanation, then
     we'll talk about the Router.
       Since node doesn't (and shouldn't) understand JSX, we need to compile the code
     somehow. Using something like babel/register is not fit for production use, so
     we'll use webpack to build a server bundle, just like we use it to build a
     client bundle.

     Make a new file called webpack.server.config.js and put this stuff in there:

#+BEGIN_SRC js


var fs = require('fs')
var path = require('path')

module.exports = {

  entry: path.resolve(__dirname, 'server.js'),

  output: {
    filename: 'server.bundle.js'
  },

  target: 'node',

  // keep node_module paths out of the bundle
  externals: fs.readdirSync(path.resolve(__dirname, 'node_modules')).concat([
    'react-dom/server', 'react/addons',
  ]).reduce(function (ext, mod) {
    ext[mod] = 'commonjs ' + mod
    return ext
  }, {}),

  node: {
    __filename: true,
    __dirname: true
  },

  module: {
    loaders: [
      { test: /\.js$/, exclude: /node_modules/, loader: 'babel-loader?presets[]=es2015&presets[]=react' }
    ]
  }

}

#+END_SRC


     Hopefully some of that makes sense, we aren't going to cover what all of that
     stuff does, it's sufficient to say that now we can run our server.js file through
     webpack and then run it.
       Now we need to make some scripts to build server bundle before we try to run
     our app. Update your package.json script config to look like this:

#+BEGIN_SRC js

"scripts": {
  "start": "if-env NODE_ENV=production && npm run start:prod || npm run start:dev",
  "start:dev": "webpack-dev-server --inline --content-base public/ --history-api-fallback",
  "start:prod": "npm run build && node server.bundle.js",
  "build:client": "webpack",
  "build:server": "webpack --config webpack.server.config.js",
  "build": "npm run build:client && npm run build:server"
},

#+END_SRC

     Now when we run NODE_ENV=production npm start both the client and server bundles
     get created by Webpack.
       Okay, let's talk about the Router. We're going to need our routes split out into
     a module so that both the client and server entries can require it. Make a file at
     modules/routes and move your routes and components into it.

#+BEGIN_SRC js

// modules/routes.js
import React from 'react'
import { Route, IndexRoute } from 'react-router'
import App from './App'
import About from './About'
import Repos from './Repos'
import Repo from './Repo'
import Home from './Home'

module.exports = (
  <Route path="/" component={App}>
    <IndexRoute component={Home}/>
    <Route path="/repos" component={Repos}>
      <Route path="/repos/:userName/:repoName" component={Repo}/>
    </Route>
    <Route path="/about" component={About}/>
  </Route>
)
// index.js
import React from 'react'
import { render } from 'react-dom'
import { Router, browserHistory } from 'react-router'
// import routes and pass them into <Router/>
import routes from './modules/routes'

render(
  <Router routes={routes} history={browserHistory}/>,
  document.getElementById('app')
)

#+END_SRC


     Now open up server.js. We're going to bring in two modules from React Router to
     help us render on the server.
       If we tried to render a <Router/> on the server like we do in the client, we'd
     get an empty screen since server rendering is synchronous and route matching is
     asynchronous.
       Also, most apps will want to use the router to help them load data, so
     asynchronous routes or not, you'll want to know what screens are going to render
     before you actually render so you can use that information to load asynchronous
     data before rendering. We don't have any data loading in this app, but you'll see
     where it could happen.
       First we import match and RouterContext from react router, then we'll match the
     routes to the url, and finally render.

#+BEGIN_SRC js

// ...
// import some new stuff
import React from 'react'
// we'll use this to render our app to an html string
import { renderToString } from 'react-dom/server'
// and these to match the url to routes and then render
import { match, RouterContext } from 'react-router'
import routes from './modules/routes'

// ...

// send all requests to index.html so browserHistory works

app.get('*', (req, res) => {
  // match the routes to the url
  match({ routes: routes, location: req.url }, (err, redirect, props) => {
    // `RouterContext` is the what `Router` renders. `Router` keeps these
    // `props` in its state as it listens to `browserHistory`. But on the
    // server our app is stateless, so we need to use `match` to
    // get these props before rendering.
    const appHtml = renderToString(<RouterContext {...props}/>)

    // dump the HTML into a template, lots of ways to do this, but none are
    // really influenced by React Router, so we're just using a little
    // function, `renderPage`
    res.send(renderPage(appHtml))
  })
})

function renderPage(appHtml) {
  return `
    <!doctype html public="storage">
    <html>
    <meta charset=utf-8/>
    <title>My First React Router App</title>
    <link rel=stylesheet href=/index.css>
    <div id=app>${appHtml}</div>
    <script src="/bundle.js"></script>
   `
}

var PORT = process.env.PORT || 8080
app.listen(PORT, function() {
  console.log('Production Express server running at localhost:' + PORT)
})

#+END_SRC


     And that's it. Now if you run NODE_ENV=production npm start and visit the app,
     you can view source and see that the server is sending down our app to the
     browser. As you click around, you'll notice the client app has taken over and
     doesn't make requests to the server for UI. Pretty cool yeah?!
       Our callback to match is a little naive, here's what a production version
     would look like:

#+BEGIN_SRC js

app.get('*', (req, res) => {
  match({ routes: routes, location: req.url }, (err, redirect, props) => {
    // in here we can make some decisions all at once
    if (err) {
      // there was an error somewhere during route matching
      res.status(500).send(err.message)
    } else if (redirect) {
      // we haven't talked about `onEnter` hooks on routes, but before a
      // route is entered, it can redirect. Here we handle on the server.
      res.redirect(redirect.pathname + redirect.search)
    } else if (props) {
      // if we got props then we matched a route and can render
      const appHtml = renderToString(<RouterContext {...props}/>)
      res.send(renderPage(appHtml))
    } else {
      // no errors, no redirect, we just didn't match anything
      res.status(404).send('Not Found')
    }
  })
})

#+END_SRC

     Server rendering is really new. There aren't really "best practices" yet,
     especially when it comes to data loading, so this tutorial is done, dropping
     you off at the bleeding edge
