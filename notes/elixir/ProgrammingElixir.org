Programming Elixir :: Dave Thomas

* Take the Red Pill

#+BEGIN_SRC elixir
h IO.puts
#+END_SRC

#+RESULTS:
: * def puts(device \\ group_leader(), item)
: 
: Writes `item` to the given `device`, similar to `write/2`,
: but adds a newline at the end.
: 

#+BEGIN_SRC elixir
i "i" 
#+END_SRC

#+RESULTS:
#+begin_example
Term
  "i"
Data type
  BitString
Byte size
  1
Description
  This is a string: a UTF-8 encoded binary. It's printed surrounded by
  "double quotes" because all UTF-8 encoded codepoints in it are printable.
Raw representation
  <<105>>
Reference modules
  String, :binary
#+end_example

* Pattern Matching
* Immutability
* Elixir Basics

#+BEGIN_SRC elixir
a = %{red: "red", blue: "blue"}
a.blue
#+END_SRC

#+RESULTS:
: "blue"

* Anonymous Functions

#+BEGIN_SRC elixir
list_concat = fn a, b -> a ++ b end
list_concat.([1, 2], [3, 4])
#+END_SRC

#+RESULTS:
: [1, 2, 3, 4]


#+BEGIN_SRC elixir
sum = &(&1 + &2 + &3)
sum.(1, 2, 3)
#+END_SRC

#+RESULTS:
: 6

#+BEGIN_SRC elixir
pair_tuple_to_list = fn {a,b} -> [a, b] end  
pair_tuple_to_list.({1234,5678})
#+END_SRC

#+RESULTS:
: [1234, 5678]

#+BEGIN_SRC elixir
fun = fn
      (0, 0, _) -> "FizzBuzz"
      (0, _, _) -> "Fizz"
      (_, 0, _) -> "Buzz"
      (_, _, x) -> x
      end

fb = fn
     (n) -> fun.(rem(n,3), rem(n,5), n)
     end

IO.puts(fb.(10))
IO.puts(fb.(11)) 
IO.puts(fb.(12))
IO.puts(fb.(13))
IO.puts(fb.(14))
IO.puts(fb.(15))
IO.puts(fb.(16))
#+END_SRC

#+RESULTS:
: Buzz
: 11
: Fizz
: 13
: 14
: FizzBuzz
: 16
: :ok


#+BEGIN_SRC elixir

#+END_SRC

#+BEGIN_SRC elixir
prefix = fn b -> (fn a -> "#{b} #{a}" end) end 
mrs = prefix.("Mrs.")
mrs.("Smith")

#+END_SRC

#+RESULTS:
: "Mrs. Smith"

#+BEGIN_SRC elixir
Enum.map([1,2,3,4],&(&1 + 2))
Enum.each([1,2,3,4],&(IO.inspect(&1)))
#+END_SRC

#+RESULTS:
: 1
: 2
: 3
: 4
: :ok

* Modules and Named Functions
Named functions can only exist inside modules. Internally, named functions are identified by both name and arity. Thus, you could have two functions in the same module, with the same name, but with different arity. Check out the code block below and corresponding file for function forms.

Modules are compiled: either give IEx a source file's name or use the =c= helper

#+BEGIN_SRC shell
$ iex ./e/times.esx
#+END_SRC

or

#+BEGIN_SRC elixir
# c "./e/times.esx" # the c helper, in org-mode it only needs to be loaded once
# Times.double(5.5)
  Times.double(2,2) # multi-arity experiment
# Times.double("string")
# Times.triple(2)
# Times.quadruple(2)
#+END_SRC

#+RESULTS:
: 8

the params and args do that pattern matching 
so just like the anonymous functions,
we can have multiple clauses of the same definition - in one module 
but, we gotta write the function multiple times
in the order (first to last) that they must be matched
and the arity's gotta be consistent,
adjacency is nice

Let's use pattern matching, and multiple function clauses to implement a recursive function that calculates its argument's factorial

#+BEGIN_SRC elixir
  # c "./e/mathy.esx"
  Mathy.factorialOf(10)
#+END_SRC

#+RESULTS:
: 3628800

#+BEGIN_SRC elixir
  # c "./e/mathy.esx"
  # Mathy.sum(10)
  # Mathy.gcd(7,31)
  Mathy.gcd(6,36)
#+END_SRC

#+RESULTS:
: 6

** Guard Clauses
Guard classes are predicates that are attached to a function definiton using one or more =when= keywords.

* Lists and Recursion
* Maps, Keyword Lists, Sets, and Structs
* An Aside - What are Types?
* Strings and Binaries
* Control Flow
* Organizing a Project
* Tooling
* Working With Multiple Processes
* Nodes - the Key to Distributing Services
* OTP: Servers
* OTP: Supervisors
* A More Complex Example
* OTP: Applications
* Tasks and Agents
* Macros an Code Evaluation
* Linking Modules: Behaviors and Use
* Protocols - Polymorphic Functions
* More Cool Stuff
* Exceptions: raise and try, catch and throw
* Type Specifications and Type Checking
