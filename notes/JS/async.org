* DONE Reasoning about Asynchronous JavaScript - Wes Higbee (2:05)
** Concurrency Model and Event Loop : https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop
*** JavaScript is single threaded, JS cannot execure processes in parallel
*** The event loop and the event queue interface with the function stack
*** async function calls stage functions and their dependency 
*** once the function's dependency arrives, the function will be conj'd onto the queue
*** js supports concurrency through non-blocking
** Avoid Blocking
*** each process runs to completion
*** callbacks go onto the event queue, and won't be called until the current process finishes
*** browser rendering is async!
*** use webworkers to run intensive code in the background to avoid blocking the front-End of the app.
** Cooperative Concurrency
*** concurrency permits multiple processes to execute alternately
*** our programs are composed of async processes: 'little programs'
*** think explicitly about asynchronous seams
** Sources of Async
*** Timers
**** timer delay not guaranteed, pushed to queue after time elapsed, delay is a minimum.
*** user interactions
**** event listeners are synchronous!
*** network & disk I/O
*** Node stuff (see docs)
**** fs
**** process.nextTick (beats out setTimeout, jups to the front of the event queue, guaranteed ordered execution)
**** setImmediate (also async, guaranteed ordered execution)
**** disk I/O
**** IPC - interprocess communication EX: webworkers
*** Web Workers
** Not all function calls aren't async
** race conditions in order of queue
** Debugging in the browser
*** sources, call stack,
*** check async, call stack will display source of current stack 


* Modern Asynchronous JavaScript : Wes Higbee (6:34)


* CSP-JS
The Library: https://github.com/ubolonton/js-csp
** Communicating with Channels (video) https://www.youtube.com/watch?v=W2DgDNQZOwo
** CSP - FullStackFest (video) https://www.youtube.com/watch?v=r7yWWxdP_nc
** David Nolan
- CSP http://swannodette.github.io/2013/07/12/communicating-sequential-processes
- ES6 generators http://swannodette.github.io/2013/08/24/es6-generators-and-csp
** Generators and Channels in JS https://medium.com/javascript-inside/generators-and-channels-in-javascript-594f2cf9c16e#.448z7n5na
** Taming the Async Beast w/ CSP in JS http://jlongster.com/Taming-the-Asynchronous-Beast-with-CSP-in-JavaScript


* TODO Rethinking Asynchronous JavaScript : Kyle Simpson 
** Parallel, Concurrent, and Asynchronous
*** Parallel: At the same time
A CPU can only execute one process at a time. But as computer with multiple cores can execute multiple processes at a time. Parallelism is when two or more processes are executing at the same time. Parallelism is usually espressed via threads. The operating system has virtural threads, and manages the execution of threads to take advantage of multiple cores. JavaScript programs only execute within a single thread.
*** Concurrency: Within a time frame
Concurrency is when multiple process are executing within a time frame. In JavaScript, processes are coordinated in an event loop. Processes are scheduled and executed in a queue-like fashion.
** Callbacks
*** A Simple Example:
How does the following code work?

#+BEGIN_SRC js :results output
  setTimeout(function(){
    console.log("callback!");
  }, 1000);
#+END_SRC

#+RESULTS:
: callback!

First, a event is scheduled to be fired after 1000ms. Sometime after this countdown has finished, depending largely on what else is going on within the event loop, the event will fire, causing the function to execute.

*** Callbacks are Continuations
In our code, there is a now, and a later. This idea is that of a continuation: Your code will execute, stop execution, and then resume execution later. Continuations and callbacks are the same concept.
*** The Two Evils of Callback Hell
**** Inversion of Control: An Issue of Trust
When you pass a callback to a third-party utility, you trust that
- Your callback will not be called too early
- Your callback will not be called too late
- Your callback will not be called too many times
- Your callback will not be called too few times
- Your callback will not loose its execution context
- Errors will not be swallowed
...
**** Not-Reasonable: Humans are Single Threaded and Synchronous Planners
Asychronous patterns are difficult to reason about. Our programs will be more robust if our patterns permit us to write code in a synchronous, sequential, blocking way.
** Thunks
Broadly, thunks are expressions that have not yet been evaluated, and thus 
represent a future value. 
  "Functional programming languages have also allowed programmers to explicitly 
generate thunks. This is done in source code by wrapping an argument expression in 
an anonymous function that has no parameters of its own. This prevents the 
expression from being evaluated until a receiving function calls the anonymous 
function, thereby achieving the same effect as call-by-name."
  - Wikipedia
*** Thunk Ex:
A thunk is a function that requires no new arguments to execute and return a value.

#+BEGIN_SRC js :results output
  function add (x, y) {
    return x + y;
  }
  const thunk = () => add(10,15);
  console.log(thunk());
#+END_SRC

#+RESULTS:
: 25

Thunks are the concetual underpinning for promises: a wrapper around a value.

*** Async Thunk Ex:
What is an async thunk? a function that needs to be passed a callback so you can 
access a value.
  Note that both the thunk and reference function's signature and body handle 
the asynchronicity. But, once the asynchronous code is embedded in the thunk, we can access the value in the thunk without concerning ourselves with the temporal 
implementation.

#+BEGIN_SRC js :results output
  function addAsync(x, y, cb) {
    setTimeout(function() {
      cb(x+y);
    }, 1000);
  }

  let thunk = function(cb) {
    addAsync(10,15,cb);
  };

  thunk((x) => console.log(x));  
#+END_SRC

#+RESULTS:
: 25

*** Thunk Maker & Nesting Thunks Ex:

#+BEGIN_SRC js :results output
  function makeThunk(fn, ...args){
    return function(cb) {
      args.push(cb);
      fn.apply(null, args);
    };
  }

  function getData(n, cb){
    cb(n);
  }

  let get10 = makeThunk(getData, 10);
  let get30 = makeThunk(getData, 30);
  
  get10(function(n1){
    let x = 1 + n1;
    get30(function(n2){
      let y = 1 + n2;
      let getAnswer = makeThunk(getData, (x + y));
      getAnswer((x) => console.log(x));
    });
  });
#+END_SRC

#+RESULTS:
: 42

*** TODO Thunks and Closure (example solution)
Time is the most complex form of state in a program. Thunks use closure to 
maintain state, removing time as a complecting factor of state. This helps us 
to abstract away time based complexity in ordering processes.
** Promises
Promises represent future values. They allow you to retain control over callback execution, by allowing you to subscribe to "completion events." In native promises, the completion event is the .then method. Because promises permit you to retain control over what happens when a requested value arrives, promises address the inversion of control problem inherent with vanilla callbacks.

*** Promises You Can Trust
Promises were designed to solve the inversion of control that plagued vanilla callbacks. To do this, promises make certain guarantees.
1. Promises can only resolve once
2. A resolved promise has a state of either success or error
3. Resolution values passed into the promise are kept (messages)
4. Exceptions become errors, nothing is swallowed
5. Once a promise resolves, it's value is immutable

*** Promise API
When a promise resolves, the value passed to resolve =resolve(data)= is propagated forward, 
and becomes the argument to the callback in that promise's .then method. 
*** TODO Catch(ing?)
*** Promise Flow Control - dot chaining
Promises allow us to express flow control by chaining promises together. AWhenever a promise's .then method is called, it will return a promise (what promise?) by default. However, we can order sequential promises by returning a different promise in the then method's callback.
**** dot chaining Example:
#+BEGIN_SRC js :results output
  function getData(d) {
    return new Promise(function(resolve, reject){
      setTimeout(function(){ 
        resolve(d); 
      }, 1000);
    });
  }

  let x;

  getData(10)
  .then(function(num1){
    x = 1 + num1;
    return getData(30);
  })
  .then(function(num2){
    let y = 1 + num2;
    return getData("Meaning of Life: " + ( x + y));
  })
  .then(function(answer){
    console.log(answer);
  })
#+END_SRC

#+RESULTS:
: Meaning of Life: 42

*** Exercise #3

 #+BEGIN_SRC js :results output
function fakeAjax(url,cb) {
	var fake_responses = {
		"file1": "The first text",
		"file2": "The middle text",
		"file3": "The last text"
	};

	var randomDelay = (Math.round(Math.random() * 1E4) % 8000) + 1000;

	console.log("Requesting: " + url);

	setTimeout(function(){
		cb(fake_responses[url]);
	},randomDelay);
}

function output(text) {
	console.log(text);
}

// **************************************

function getFile(file) {
    return new Promise(function(resolve, reject){
      fakeAjax(file, resolve); 
    });
}

// request all files at once in "parallel"

let file1 = getFile("file1");
let file2 = getFile("file2");
let file3 = getFile("file3");

// print results in the correct order

file1
.then(output)
.then(function(data){
  console.log("Data: ", data); // note we're not dealing with file1 anymore
  return file2;
})
.then(function(data){
  output(data);
  return file3;
})
.then(function(data){
  output(data);
})

#+END_SRC

 #+RESULTS:
 : Requesting: file1
 : Requesting: file2
 : Requesting: file3
 : The first text
 : Data:  undefined
 : The middle text
 : The last text

*** Abstractions
*** Sequences and Gates
** Generators
*** Example
*** Messaging
*** Async Generators
*** Promises and Generators
** Observables
*** Events and Promises
*** Observables
*** Reactive Sequences
** CSP
*** Concurrency and Chanels
*** Blocking Channels
*** Event Channels
*** Recap


* YDKJS: Async
** Asynchrony: Now & Later
*** A Program in Chunks
*** Event Loop
*** Parallel Thinking
*** Concurrency
*** Jobs
*** Statement Ordering
** Callbacks
*** Continuations
*** Sequential Brain
*** Trust Issues
*** Trying to Save Callbacks
** Promises
*** What is a Promise?
*** Thenable Duck Typing
*** Promise Trust
*** Chain Flow
*** Error Handling
*** Promise Patterns
*** Promise API Recap
*** Promise Limitations
** Generators
*** Breaking Run-to-Completion
*** Generator-ing Values
*** Iterating Generators Asychronously
*** Generators + Promises
*** Generator Delegation
*** Cenerator Concurrency
*** Thunks
*** Pre-ES6 Generators
