
* Practical Design Patterns in JS : Jonathan Mills (3:10)
** What is a Design Pattern?
*** A Pattern Language!
"...each pattern represents our current best guess as to what arrangement of the physical
environment will work to sole the problem presented. ... The empirical questions center on the problem - does it occur and is it felt in the way we have described it? ... and the solution - does the arrangement we propose in face resolve the problem? - Christopher Alexander
*** Common Problems and Common Solutions

|-------------------------------+------------------+------------------------------|
| Problems                      | Solutions        | Example                      |
|-------------------------------+------------------+------------------------------|
| Designing Service Layers      | Module Pattern   | Namespaces, Modules, etc.    |
| Complicated Object Interfaces | Facade Pattern   | React abstracts away the DOM |
| Visibility into State Changes | Observer Pattern | Pub/Sub, Event Listeners     |
|-------------------------------+------------------+------------------------------|

*** What Constitutes a Pattern?
- Design Patterns Solve A Problem
- Design Patterns are Tested / Proven
- The Solution is Not Obvious
- The Pattern Usually Describes A Relationship
- The Pattern Has A Human Component
*** Types of Patterns
- Creational - Making new objects
  1. Constructor Pattern
  2. Module Pattern
  3. Factory Pattern
  4. Singleton Pattern
- Structural
  1. Decorator
  2. Facade
  3. Flyweight
- Behavioral
  1. Command
  2. Mediator
  3. Observer

** Objects in JavaScript
*** Object Creation
- {} // literals
- Object.Create(Object.prototype)
- new Object();
*** Assigning Keys and Values
- dot notation
- square bracket notation
*** Object.defineProperty let's us put object properties on lockdown

#+BEGIN_SRC js :results output
  let task = {
    title: 'Independence Day',
    description: 'A Summer Blockbuster'
  };
  
  Object.defineProperty(task, 'printPromo', {
    value: function () {
      return this.title + ': ' + this.description;
    },
    writable: true,
    enumerable: true,
    configurable: true
  });

  console.log(task.printPromo());
#+END_SRC

#+RESULTS:
: Independence Day: A Summer Blockbuster

*** Object.create() for Prototypal Inheritance
Not a deep copy, b/c it doesn't copy defineProperty settings over.
** Creational Design Patterns
*** Constructor Pattern: Constructor Functions and the =new= Keyword
The constructor pattern is really about using constructor functions and the =new= keyword. 
When a Constructor function invocation is preceeded by the =new= keyword, the constructor 
function will do four things:
- Create a new object
- Link that object to an object prototype, by default the
- Binds =this= to the new object's scope
- Returns the new object

It is idiomatic to capitalize the first letter of a constructor function's name:

#+BEGIN_SRC js :results output
  var Task = function(name){
    this.name = name;
    this.completed = false;
    this.complete = function(){
      console.log('completing task: ' + this.name);
      this.completed = true;
    }
    this.save = function(){
      console.log('saving task: ' + this.name);
    }
  }

  var task1 = new Task('create a demo for constructors');
  var task2 = new Task('create a demo for modules');
  var task3 = new Task('create a demo for singletons');
  var task4 = new Task('create a demo for prototypes');

  task1.complete();
  task2.save();
  task3.save();
  task4.save();
#+END_SRC 

#+RESULTS:
: completing task: create a demo for constructors
: saving task: create a demo for modules
: saving task: create a demo for singletons
: saving task: create a demo for prototypes

*** Constructor Pattern: Using Object Prototypes (glaring omissions)
When we use the constructor pattern, each time we construct an object, that object's recieves 
it's own properties and methods according to the constructor. For methods that lack internal 
state, this means unnecessary duplication. 
  The prototype pattern allows us to store properties and methods on an object that 
constructed objects link to through the prototype chain. IF we call a method on a constructed object, that doesn't exist on that object but exists on it's prototype, the constructed object will execute the method using it's own =this= context.
  We can assign methods and properties to the prototype of objects returned from a constructor 
function via the constructor functions =.prototype= property.
  
#+BEGIN_SRC js :results output
  var Task = function(name){
    this.name = name;
    this.completed = false;
  }

  Task.prototype.complete = function(){
    console.log('completing task: ' + this.name);
    this.completed = true;
  };

  Task.prototype.save = function(){
    console.log('saving task: ' + this.name);
  };

  var task1 = new Task('create a demo for constructors');
  var task2 = new Task('create a demo for modules');
  var task3 = new Task('create a demo for singletons');
  var task4 = new Task('create a demo for prototypes');

  task1.complete();
  task2.save();
  task3.save();
  task4.save();
#+END_SRC 

#+RESULTS:
: completing task: create a demo for constructors
: saving task: create a demo for modules
: saving task: create a demo for singletons
: saving task: create a demo for prototypes

*** Constructor Pattern: The =class= Keyword

#+BEGIN_SRC js cmd: "org-babel-node --presets es2015" :results output
  class Task { 
    constructor(name) {
      this.name = name;
      this.completed = false;
    };
    complete() {
      console.log('completing task: ' + this.name);
      this.completed = true;
    };
    save() {
      console.log('saving task: ' + this.name);
    };
  }

  var task1 = new Task('create a demo for constructors');
  var task2 = new Task('create a demo for modules');
  var task3 = new Task('create a demo for singletons');
  var task4 = new Task('create a demo for prototypes');

  task1.complete();
  task2.save();
  task3.save();
  task4.save();
#+END_SRC 

#+RESULTS:
: completing task: create a demo for constructors
: saving task: create a demo for modules
: saving task: create a demo for singletons
: saving task: create a demo for prototypes

*** TODO Module Pattern
At its core, the module pattern is an object literal that has properties or methods that make up its public API. We can return an object from a function, and take advantage of closures to encapsulate and protect internal state, while using the public api exposed on the returned object.

#+BEGIN_SRC js
  // unfinished
#+END_SRC

*** Factory Pattern
The factory pattern simplifies object creation, and helps you create different objects based 
on need. 
*** Singleton Pattern

** Structural Design Patterns
** Behavorial Design Patterns
