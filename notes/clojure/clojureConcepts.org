#+TODO: TODO NEXT OPEN | DONE

* Index
** Living Clojure
[X] Chapter 1 : The Structure of Clojure
[X] Chapter 2 : Flow and Functional Transformations
[ ] Chapter 3 : State and Concurrency
[ ] Chapter 4 : Java Interop and Polymorphism
[ ] Chapter 5 : How to Use Clojure Projects and Libraries
[ ] Chapter 6 : Communication with core.async
[ ] Chapter 7 : Creating Web Applications with Clojure
[ ] Chapter 8 : The Power of Macros
[ ] Training Plan Week 1
[ ] Training Plan Week 2
[ ] Training Plan Week 3
[ ] Training Plan Week 4
[ ] Training Plan Week 5
[ ] Training Plan Week 6
[ ] Training Plan Week 7
** Clojure for the Brave and True
[ ] 1. Building, Running, and the REPL
[ ] 2. How to Use Emacs, An Excellent Clojure Editor
[ ] 3. Do Things: A Clojure Crash Course
[ ] 4. Core Functions in Depth
[ ] 5. Functional Programming
[ ] 6. Organizing Your Project: A Librarian's Tale
[ ] 7. Clojure Alchemy: Reading, Evaluation, and Macros
[ ] 8. Writing Macros
[ ] 9. The Sacred Art of Concurrent and Parallel Programming
[ ] 10. Clojure Metaphysics: Atoms, Refs, Vars, ...
[ ] 11. Mastering Concurrent PRocesses with core.async
[ ] 12. Working with the JVM
[ ] 13. Creating & Extending Abstractions w/ Multimethods, Protocols, and Records
[ ] A. Building and Developing with Leiningen
[ ] B. Boot, the Fancy Clojure Build Framework
** ClojureScript Unraveled
[X] 3.1. First steps with Lisp syntax
[X] 3.2. The base data types
[X] 3.3. Vars
[X] 3.4. Functions
[X] 3.5. Flow control
[X] 3.6. Truthiness
[X] 3.7. Locals, Blocks, and Loops
[ ] 3.8. Collection types
[X] 3.9. Destructuring
[ ] 3.10. Threading Macros
[ ] 3.11. Reader Conditionals
[ ] 3.12. Namespaces
[ ] 3.13. Abstractions and Polymorphism
[ ] 3.14. Data types
[ ] 3.15. Host interoperability
[ ] 3.16. State management
[ ] 4.1. Getting Started with the Compiler
[ ] 4.2. Working with the REPL
[ ] 4.3. The Closure Library
[ ] 4.4. Dependency management
[ ] 4.5. External dependencies
[ ] 4.6. Unit testing
[ ] 5.1. Transducers
[ ] 5.2. Transients
[ ] 5.3. Metadata
[ ] 5.4. Core protocols
[ ] 5.5. CSP (with core.async)
[ ] 6.1. Appendix A: Interactive development with Figwheel
[ ] 6.2. Appendix B: Setting up a ClojureScript development environment
** Clojure Applied


* Simple Expressions (lc) / Base Data Types (cu) / Data Structures (brave)
** Simple values are expressions that evaluate to themselves
*** Integers
*** Ratios - not available in ClojureScript
*** Decimals
*** Strings ("example")
*** Keywords (:example)
*** symbols (example) - evaluate to what they refer to
*** char (\e) - evaluate to a single character string in ClojureScript
*** booleans (true false)
*** (nil)


* Regular Expressions (brave)


* Forms (brave)


* Compound Data: Collections & Seqs
** Immutability and Persistence
Collections have two important features: immutability and persistence. Immutable 
collections cannot be changed. Instead, the data in a collection is shared by 
collections created from the original collection. Thus, a function that "adds" a new 
value to an existing collection does no such thing; It instead returns a 
new collection, containing the new value, and references to each value in the 
original collection. This is called structural sharing.
  We can observe structural sharing using identical?, a predicate that tells us whether
two valuesa are the same object in memory:

#+BEGIN_SRC clojure :results output
  (let [xs (list 1 2 3)
        ys (cons 0 xs)]
    (println "xs:" xs)
    (println "ys:" ys)
    (println "rest ys:" (rest ys))
    (println (identical? xs (rest ys))))
#+END_SRC

#+RESULTS:
: xs: (1 2 3)
: ys: (0 1 2 3)
: rest ys: (1 2 3)
: true

** Collections (lc, cu) / The Collection Abstraction (brave)
All collections support functions =count=, =conj=, and =seq=. However, different
collection types implement these functions in different ways. For example, =conj= 
returns a new collection from an existing collection and a value. When =conj= is applied 
to a list, the new value appears at the beginning of the new list. But, when =conj= 
is applied to a vector, the new value appears at the end of the new vector. In both 
cases =conj= returns a new collection with a new value, but the implementation is 
different.
** Seqs (lc, cu) / Programming to Abstractions (brave) / the Sequence Abstraction
Collections also provide a consistent interface to a category of functions called 
'sequence functions,' which include =first=, =rest=, and =cons=. The =seq= function accepts a collection and returns a sequence. The sequence interface permits 'walking:' accessing the elements of the collection as sequences of values. When sequence functions are applied to collections, the collection is first represented as a sequence, and then the sequence function is performed.
*** rest & next
rest and next are similar function, but when they are passed an empty collection their behavior differs.

#+BEGIN_SRC clojure :results output
  (println (rest []))
  (println (next []))
#+END_SRC

#+RESULTS:
: ()
: nil
*** nil is sorta seqable
Check it out:

#+BEGIN_SRC clojure :results output
  (println (seq nil))
  (println (first nil))
  (println (rest nil))
#+END_SRC

#+RESULTS:
: nil
: nil
: ()

*** Treating Lists, Vectors, Sets and Maps as Sequences
*** Abstraction Through Indirection
** Types of Collections (lc, cu)
*** Lists
In Clojure, lists are singly linked lists. Lists are syntatictally important in any LISP; See also 
'Compound Expressions'. Lists are enclosed in parens, and preceded with a ' to prevent evaluation of the 
list as an expression. Lists are very efficient for sequential access to elements, and acesss to the first item in a list is very fast. 
**** Create a list
***** list literal

#+BEGIN_SRC clojure
  '(1 true "three" :four nil)
#+END_SRC

#+RESULTS:
| 1 | true | three | :four | nil |

***** programmatically
#+BEGIN_SRC clojure
  ( list 1 true "three" :four nil)
#+END_SRC

#+RESULTS:
| 1 | true | three | :four | nil |

**** Lists as seqs
***** first

#+BEGIN_SRC clojure
  (first '(1 true "three" :four nil))
#+END_SRC

#+RESULTS:
: 1

***** rest

#+BEGIN_SRC clojure
  (rest '(1 true "three" :four nil))
#+END_SRC

#+RESULTS:
| true | three | :four | nil |

***** cons

#+BEGIN_SRC clojure
  (cons 0 '(1 2 3 4))
#+END_SRC

#+RESULTS:
| 0 | 1 | 2 | 3 | 4 |

**** Lists as stacks
***** peek

#+BEGIN_SRC clojure
  (peek '(1 true "three" :four nil))
#+END_SRC

#+RESULTS:
: 1

***** pop

#+BEGIN_SRC clojure
  (pop '(1 true "three" :four nil))
#+END_SRC

#+RESULTS:
| true | three | :four | nil |

***** conj (equivalent to push for list-stacks)

#+BEGIN_SRC clojure
  (conj '(1 2 3 4) 0)
#+END_SRC

#+RESULTS:
| 0 | 1 | 2 | 3 | 4 |

*** Vectors
Vectors provide fast index access, and grow from their tail. When creating a vector, every item is evaluated before being stored.
**** Create a vector
***** literal

#+BEGIN_SRC clojure
  [1 true "three" :four nil]
#+END_SRC

#+RESULTS:
| 1 | true | three | :four | nil |

***** programatically

#+BEGIN_SRC clojure
  (vector 1 true "three" :four nil)
#+END_SRC

#+RESULTS:
| 1 | true | three | :four | nil |

**** nth

#+BEGIN_SRC clojure
  (nth [1 true "three" :four nil] 3)
#+END_SRC

#+RESULTS:
: :four

**** last

#+BEGIN_SRC clojure
  (last [1 true "three" :four nil])
#+END_SRC

#+RESULTS:
: nil

**** Vectors as Stacks
***** peek

#+BEGIN_SRC clojure
  (peek [1 true "three" :four "something"])
#+END_SRC

#+RESULTS:
: something

***** pop

#+BEGIN_SRC clojure
  (pop [1 true "three" :four "something"])
#+END_SRC

#+RESULTS:
| 1 | true | three | :four |

***** conj

#+BEGIN_SRC clojure
  (conj [1 true "three" :four "something"] "else")
#+END_SRC

#+RESULTS:
| 1 | true | three | :four | something | else |

**** Vectors as Associative Collections
Because vectors access values in relation to numerical indexes - a type of key - we can use the assoc function to return a new collection with a different value at a specified index. Note that Clojure won't permit us to create sparse arrays, and we can only specify existing indexes or the index after the last item - effectively conjing the value onto the vector.

#+BEGIN_SRC clojure
  (assoc [1 2 3 5 5 6 7] 3 4)
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 | 6 | 7 |

Vectors are functions of their keys.

#+BEGIN_SRC clojure
  ([1 2 3 4 5 6 7] 3)
#+END_SRC

#+RESULTS:
: 4

**** mapv & filterv
The map and filter functions return lazy seqs, but it is common to need a fully realized seq instead. We can accomplish this when working with vectors by using mapv and filterv. This form is also faster. 

#+BEGIN_SRC clojure :results output

  (println (type (mapv inc [1 2 3 4])))
#+END_SRC

#+RESULTS:
: clojure.lang.PersistentVector

*** Maps
Maps are associative collections that store key value pairs. Every item is evaluated before being stored in 
a map, like vectors, but the order of evaluation is indeterminate - we can't predict what order a map's 
items will surface in. However, other relatives, like the sorted-maps, do provide ordering guarantees.
  It is most common to use keywords as the keys in a map, in great part because keywords can be used as 
functions that take the map as an argument and return the corresponding value if the key is present in the 
map.
**** Create a map
***** literal

#+BEGIN_SRC clojure
  {:key "value"}
#+END_SRC

#+RESULTS:
| :key | value | 

***** programmatically

#+BEGIN_SRC clojure
  (hash-map :key "value")
#+END_SRC

#+RESULTS:
| :key | value |

**** Element retrieval with get, keyword access, and default values
***** get
#+BEGIN_SRC clojure
  (get {:a "A" :b "B" :c "C"} :a)
#+END_SRC

#+RESULTS:
: A

***** keyword access

#+BEGIN_SRC clojure
  (:a {:a "A" :b "B" :c "C"})
#+END_SRC

#+RESULTS:
: A

***** default values

#+BEGIN_SRC clojure
  (:d {:a "A" :b "B" :c "C"} "not found")
#+END_SRC

#+RESULTS:
: not found
**** assoc & dissoc
***** assoc
#+BEGIN_SRC clojure
  (assoc {:a "A" :b "B" :c "C"} :d "D")
#+END_SRC

#+RESULTS:
| :a | A | :b | B | :c | C | :d | D |

***** dissoc

#+BEGIN_SRC clojure
  (dissoc {:a "A" :b "B" :c "C"} :a)
#+END_SRC

#+RESULTS:
| :b | B | :c | C |
**** keys & vals
***** keys

#+BEGIN_SRC clojure
  (keys {:a "A" :b "B" :c "C"})
#+END_SRC

#+RESULTS:
| :a | :b | :c |

***** vals

#+BEGIN_SRC clojure
  (vals {:a "A" :b "B" :c "C"})
#+END_SRC

#+RESULTS:
| A | B | C |

**** merge

#+BEGIN_SRC clojure
  (merge {:a "A" :b "B" :c "C"} {:d "D" :e "E" :f "F"})
#+END_SRC

#+RESULTS:
| :a | A | :b | B | :c | C | :d | D | :e | E | :f | F |

*** Sets
Sets are collections of unique values. No duplicate values are allowed when creating a set, even when 
nesting sets. Like maps, sets are unordered, but have ordered relatives such as sorted-set and 
sorted-set-by.
**** Create a set
***** literal

#+BEGIN_SRC clojure
  #{1 2 3 4}
#+END_SRC

#+RESULTS:
: #{1 4 3 2}

***** programatically

#+BEGIN_SRC clojure
  (hash-set 1 2 3 4)
#+END_SRC

#+RESULTS:
: #{1 4 3 2}

**** Element retrieval with get, keyword access, set access, & contains?
***** get

#+BEGIN_SRC clojure
  (get #{1 2 3 4} 2)
#+END_SRC

#+RESULTS:
: 2

***** keyword access

#+BEGIN_SRC clojure
  (:b #{:a :b :c :d})
#+END_SRC

#+RESULTS:
: :b

***** set access

#+BEGIN_SRC clojure
  (#{:a :b :c :d} :b)
#+END_SRC

#+RESULTS:
: :b

***** contains?

#+BEGIN_SRC clojure
  (contains? #{1 2 3 4} 2)
#+END_SRC

#+RESULTS:
: true

**** conj & disj
***** conj

#+BEGIN_SRC clojure
  (conj #{1 2 3 4} 5)
#+END_SRC

#+RESULTS:
: #{1 4 3 2 5}

***** disj

#+BEGIN_SRC clojure
  (disj #{1 2 3 4} 4)
#+END_SRC

#+RESULTS:
: #{1 3 2}

**** Using the clojure.set library
***** clojure.set/union

#+BEGIN_SRC clojure
  (clojure.set/union #{1 2 3 4} #{3 4 5})
#+END_SRC

#+RESULTS:
: #{1 4 3 2 5}

***** clojure.set/difference

#+BEGIN_SRC clojure
  (clojure.set/difference #{1 2 3 4} #{3 4 5})
#+END_SRC

#+RESULTS:
: #{1 2}

***** clojure.set/intersection

#+BEGIN_SRC clojure
  (clojure.set/intersection #{1 2 3 4} #{3 4 5})
#+END_SRC

#+RESULTS:
: #{4 3}
*** Queues
Queues largely borrow the semantics of stacks. But, where a stack peeks and conjs to the same 'end', a queue peeks data from one end, and conj's it to another end.
**** crete a queue
Creating a queue is not as straightforward as other collections, and requires literal syntax.

#+BEGIN_SRC clojure
  (def pg #queue [1 2 3 4 5])
#+END_SRC

#+RESULTS:

**** peek

#+BEGIN_SRC clojure :results output
  (def pq #queue [1 2 3 4 5])
  (peek pq)
#+END_SRC

#+RESULTS:

**** conj

#+BEGIN_SRC clojure :results output
  (def pq #queue [1 2 3 4 5])
  (conj pq 5)
#+END_SRC** The Power of Laziness (lc) / Lazy seqs (brave) / Laziness (cu)
"Most of ClojureScript's sequence-returning functions generate lazy sequences instead of 
eagerly creating a whole new sequence. Lazy sequences generate their contents as they are 
requested, usually when iterating over them. Laziness ensures that we don't do more work than 
we need to and gives us the possibility of treating potentially infinite sequences as regular 
ones."
*** Lazy Sequences and Side Effects
The flip side is that then you're applying functions that produce side-effects to lazy 
sequences, the side-effects won't occur until the sequence is iterated over to retrieve its 
contents. This is common when mapping over a lazy sequence.

#+BEGIN_SRC clojure :results output
  (def animals (map #(println %) '('monkey 'bear ' bird 'bee)))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC clojure :results output
  (def animals (map #(println %) '("monkey" "bear" "bird" "bee")))
  animals
#+END_SRC

#+RESULTS:
: monkey
: bear
: bird
: bee

#+BEGIN_SRC clojure :results output
  (def animals (doall (map #(println %) '("monkey" "bear" "bird" "bee"))))
#+END_SRC

#+RESULTS:
: monkey
: bear
: bird
: bee

*** range (lc)
The range function, in the absence of any arguments, returns a lazy, infinite sequence of all the integers. Thankfully range is polymorphic. With one argument, range returns a lazy sequence of integers from 0 until the argument. With two arguments, range returns a lazy sequence beginning at the first argument and ending before the second. If a third argument is provided, the difference between integers in the returned seq will reflect the third argument.
 
#+BEGIN_SRC clojure
  (range 6 19 2.5)
#+END_SRC

#+RESULTS:
| 6 | 8.5 | 11.0 | 13.5 | 16.0 | 18.5 |

*** take (lc)
The take function accepts an integer and a lazy sequence, then returns the number of items from the sequence corresponding to its integer argument.

#+BEGIN_SRC clojure
  (take 5 (range))
#+END_SRC

#+RESULTS:
| 0 | 1 | 2 | 3 | 4 |

*** repeat (lc)
The repeat function takes an integer and an expression as arguments, and returns a lazy sequence containg the value of its second argument repeated as many times as the integer.

#+BEGIN_SRC clojure
  (repeat 3 "beetlejuice")
#+END_SRC

#+RESULTS:
| beetlejuice | beetlejuice | beetlejuice |

*** repeatedly (lc)
repeatedly works similarly to repeat, but instead of accepting an expression to repeat, repeatedly accepts a function.

#+BEGIN_SRC clojure
  (repeatedly 10 #(rand-int 10))
#+END_SRC

#+RESULTS:
| 5 | 5 | 9 | 1 | 8 | 5 | 0 | 4 | 9 | 1 |

*** cycle (lc)
The cycle function accepts a collection and returns a lazy sequence containing the items in 
that collection repeated infinitely.

#+BEGIN_SRC clojure
  (take 5 (cycle '("Dave Brubeck" "Herbie Hancock" "Thelonious Monk" "Bill Evans")))
#+END_SRC

#+RESULTS:
| Dave Brubeck | Herbie Hancock | Thelonious Monk | Bill Evans | Dave Brubeck |

*** Demonstrating Lazy Seq Efficiency (brave)
*** Infinite Sequences (brave)
** for : sequence comprehension (cu, lc)
The for function accepts a vector of bindings and an expression, and returns a sequence of the 
result of evaluating the expression. for can accept multiple bindings, and iterates through them 
in a nested fashion.

#+BEGIN_SRC clojure
  (for [x [1 2 3]
        y [4 5]]
    [y (* x x)])
#+END_SRC

#+RESULTS:
| 4 | 1 |
| 5 | 1 |
| 4 | 4 |
| 5 | 4 |
| 4 | 9 |
| 5 | 9 |

*** using :let to create local bindings

#+BEGIN_SRC clojure
  (for [animal [:mouse :duck :lory]
        color [:red :blue]
        :let [animal-str (str "animal-"(name animal))
              color-str (str "color-"(name color))
              display-str (str animal-str "-" color-str)]]
    display-str)
#+END_SRC

#+RESULTS:
| animal-mouse-color-red | animal-mouse-color-blue | animal-duck-color-red | animal-duck-color-blue | animal-lory-color-red | animal-lory-color-blue |

*** using :while to break out of the sequence generation

#+BEGIN_SRC clojure
  (for [animal [:mouse :duck :lory]
        color [:red :blue]
        :let [animal-str (str "animal-"(name animal))
              color-str (str "color-"(name color))
              display-str (str animal-str "-" color-str)]
        :while (not= animal :duck)]
    display-str)
#+END_SRC

#+RESULTS:
| animal-mouse-color-red | animal-mouse-color-blue | animal-lory-color-red | animal-lory-color-blue |

*** using :when to filter out values

#+BEGIN_SRC clojure
  (for [animal [:mouse :duck :lory]
        color [:red :blue]
        :let [animal-str (str "animal-"(name animal))
              color-str (str "color-"(name color))
              display-str (str animal-str "-" color-str)]
        :when (not= animal :duck)]
    display-str)
#+END_SRC

#+RESULTS:
| animal-mouse-color-red | animal-mouse-color-blue | animal-lory-color-red | animal-lory-color-blue |

*** doseq and run! for side effects
doseq is similar to for, but executes the expression, discards the resulting values, and returns nil.

#+BEGIN_SRC clojure :results output
  (doseq [x [1 2 3]
          y [4 5]
          :let [z (+ x y)]]
    (println x "+" y "=" z))
#+END_SRC

#+RESULTS:
: 1 + 4 = 5
: 1 + 5 = 6
: 2 + 4 = 6
: 2 + 5 = 7
: 3 + 4 = 7
: 3 + 5 = 8

run! similarly returns nil, and acts similarly to reduce.

#+BEGIN_SRC clojure :results output
  (run! println [1 2 3 4 5])
#+END_SRC

#+RESULTS:
: 1
: 2
: 3
: 4
: 5


* Basic Functions (lc, brave, cu)
** Compound Expressions (lc)
Clojure is a dialect of LISP (LISt Processing). All lisp code is made of lists of data - literally, data in the list data structure.  Lists are evaluated in Clojure as expressions; The first element in a list is the function, and subsequent elements are arguments of the first element. This is known as 'prefix' notation. Note, that Clojure does not have operators, only functions. This facilitates function argument arbitrarity. As a bonus, there's no operator precedence table to memorize. 

#+BEGIN_SRC clojure
  (+ 1/2 3/4)
#+END_SRC

#+RESULTS:
: 5/4

Clojure also uses lists as compound data structures when the list is preceded by a single-quote. Emphatically, in Clojure: code is data.
** Function Invocation / Calling Functions (brave, cu)
Because Clojure is a lisp, you invoke a function by using it as the first item in a list.
** Functions Are Values
In Clojure, functions are first class values: They can be referenced with vars, passed to functions as arguments, and returned from functions. 
*** Defining Functions (brave, cu, lc)
**** Anonymous functions with fn (brave, lc)

#+BEGIN_SRC clojure :results output
  ((fn [parameter] (println parameter)) "Code is Data")
#+END_SRC

#+RESULTS:
: Code is Data
**** Binding a Function to a Symbol Using def (cu)

#+BEGIN_SRC clojure :results output
  (def symbolicName (fn [parameter1] (println parameter1)))
  (symbolicName "Code is Data")
#+End_SRC

#+RESULTS:
: Code is Data

**** Binding a Function to a Symbol Using defn (lc, cu)
The defn macro is the idiomatic way to define functions, and optionally 
includes a 'docstring'.

#+BEGIN_SRC clojure :results output
  (defn symbolicName "This is a description of the function" 
    [parameter1] (println parameter1))
  (symbolicName "Code is Data")
#+End_SRC

#+RESULTS:
: Code is Data

**** Functions with Multiple Arities and Variadic Functions (cu)
Function definitions can include different bodies for different arities.

#+BEGIN_SRC clojure :results output
  (defn myinc
    "Self defined version of parameterized 'inc'."
    ([x] (myinc x 1))
    ([x y] (+ x y)))
  (println (myinc 5))
  (println (myinc 9))
#+END_SRC

#+RESULTS:
: 6
: 10

And, functions can accept an arbitrary number of arguments using the & symbol.

#+BEGIN_SRC clojure
  (defn my-variadic-set [& params] (set params))
  (my-variadic-set 1 2 3 4 2 3)
#+END_SRC

#+RESULTS:
: #'user/my-variadic-set#{1 4 3 2}

**** Anonymous function shorthand #(%) (lc)
The # reader macro expands shorthand function expressions into legit function expressions during compilation. A single arity function would use % as shorthand for its argument. Otherwise, arguments should be numbered (%1 %1 etc.) or variable (%&).

#+BEGIN_SRC clojure :results output
  (#(println %) "Code is Data")
#+END_SRC

#+RESULTS:
: Code is Data
** Pure Functions: What and Why (brave)
Pure functions always return the same output when given the same input. Pure functions are free of 'side effects'. 
*** comp
*** memoize


* Control
** Boolean Logic 
*** Basic Logic Tests (lc)
Only two values evaluate to false in logic operations: false and nil. nil is 
logically false. In Clojure, functions that return a boolean value as their result 
typically end with a question mark.
**** true? - tests for true values

#+BEGIN_SRC clojure
  (true? nil)
#+END_SRC

#+RESULTS:
: false

**** false? - tests for the boolean value false

#+BEGIN_SRC clojure
  (false? nil)
#+END_SRC

#+RESULTS:
: false

**** nil? - tests for nil, the absence of value

#+BEGIN_SRC clojure
  (nil? nil)
#+END_SRC

#+RESULTS:
: true

**** not - returns the negation of a boolean returned from its operand

#+BEGIN_SRC clojure
  (true? (not nil))
  (false? (not nil))
#+END_SRC

#+RESULTS:
: truefalse

**** = & not= - tests for equality or inequality

#+BEGIN_SRC clojure
  (= nil (not= nil false))
#+END_SRC

#+RESULTS:
: false

*** Collections As Predicates (cu)
Maps and Sets implement the callable protocol (IFn), and can thus be used as 
if they were functions. When calling a collection, it will return an argument's value that the collection itself contains. If the collection does not contain the argument's value, the result will be nil. 

#+BEGIN_SRC clojure
  (#{1 2 3} 2)
#+END_SRC

#+RESULTS:
: 2

*** Logic Tests you Can Use on Collections (lc)
***** coll?
The coll? predicate returns true if its argument is a collection.

#+BEGIN_SRC clojure
  (coll? {})
  (coll? 8)
#+END_SRC

#+RESULTS:
: truefalse

***** empty?
The empty? predicate tests whether a collection contains any items.

#+BEGIN_SRC clojure
  (empty? #{})
#+END_SRC

#+RESULTS:
: true

***** seq & 'nil pruning'
The seq function isn't really a predicate, but it is idiomatic to use it as a predicate for 
whether a collection is not empty. If a collection is empty, seq returns nil -  a falsey value. Otherwise, seq returns a list containing the elements of that collection - a truthy value.

#+BEGIN_SRC clojure :results output
  (println (seq {:a "A"}))
#+END_SRC

#+RESULTS:
: ([:a A])

***** every?
The every? function tests whether every element in a collection passes a predicate.

#+BEGIN_SRC clojure
  (every? #(= :zanzibar %) '(:zanzibar :zanzibar :zanzibarnacle))
#+END_SRC

#+RESULTS:
: false
***** not-any?
The not-any? function tests whether each element in the collection fails a predicate.

#+BEGIN_SRC clojure
  (not-any? #(= :zanzibar %) '(:zanzibarnacle :zanzibarnacle :zanzibarnacle))
#+END_SRC

#+RESULTS:
: true

***** some
The some function returns true if any item in a collection passes a predicate.

#+BEGIN_SRC clojure
  (some #(> % 4) [1 2 3 4 5 6 7 8])
#+END_SRC

#+RESULTS:
: true

And remember, that we can use sets as predicates for their members.

#+BEGIN_SRC clojure
  (some #{1 2 3} [2])
#+END_SRC

#+RESULTS:
: 2

But be wary of falsey values!

#+BEGIN_SRC clojure
  (some #{nil} [nil])
#+END_SRC

#+RESULTS:
: nil
** Control Flow (brave, cu)
There are no statements in Clojure, only expressions.
*** do (cu)
The do expression accepts any number of arguments, evaluates them in turn, and returns the value of the last expression. This is how Clojure does 'blocks.' Idiomatically, do expressions are useful for side effects, like sdtout or logging. 

#+BEGIN_SRC clojure
  (do 
    (println "I was evaluated")
    "And, I was returned")
#+END_SRC

#+RESULTS:
: And, I was returned

*** when (lc)
The when function accepts a predicate and an expression. If the predicate returns true, the expression will be evaluated. If the predicate returns false, when returns nil. That is all.

#+BEGIN_SRC clojure
  (when true "true")
#+END_SRC

#+RESULTS:
: true

*** when-let (lc)
The when-let function works similarly to when, but has a symbol-binding in the place of a logic test. If the expression bound to the symbol is truthy, the truthy value is bound to the symbol and the expression is evaluated.

#+BEGIN_SRC clojure :results output
  (when-let [name (> 5 1)]
    (println (str name " is true!")))
#+END_SRC

#+RESULTS:
: true is great!
 
*** if (cu)
The if function takes three parameters: a predicate, an expression to evaluate in the event of 
a true result, and an expression to evaluate in the event of a false result.

#+BEGIN_SRC clojure
  (if false
    "The Truth is Out There"
    "The X-Files have been closed")
#+END_SRC

#+RESULTS:
: The X-Files have been closed

*** if-let (lc)
The if-let function works similarly to let, but has a symbol-binding in the place of a logic test. If the expression bound to the symbol is truthy, the truthy value is bound to the symbol and the first expression is evaluated, otherwise the second expression is evaulated.

#+BEGIN_SRC clojure :results output
  (if-let [sym 1]
    (println (str sym " is true"))
    (println (" is false")))
#+END_SRC

#+RESULTS:
: 1 is true

*** cond (cu)
The cond expression permits a mapping of logic tests to expressions. Should a logic test 
evaluate to true, the corresponding expression will be evaluated. To ensure that the final 
predicate succeeds, you can use any truthy value as a predicate: "default" or :else are 
semantically satisfying.
  If none of the predicates succeed, cond returns nil.

#+BEGIN_SRC clojure :results output
  (def x 0)
  (cond
    (> x 0) (println "positive")
    (< x 0) (println "negative")
    "default" (println "zero"))
#+END_SRC

#+RESULTS:
: zero

*** condp (cu)
The predicates in a cond expression may be very similar. The condp expression accepts a single predicate that applies to subsequent pairs of keywords and expressions.

#+BEGIN_SRC clojure
  (defn translate
    [code]
    (condp = (keyword code)
      :es "Spanish"
      :en "English"
      :fr "French"
      "unknown"))
  (translate "fr")
  (translate "pg")
#+END_SRC

#+RESULTS:
: #'user/translate"French""unknown"

*** case (cu)
The case expression is similar to condp, but always checks for equality between a symbol and a 
branching value that maps to an expression. Note that the branching values are evaluated during 
compilation.
  Unlike cond and condp, if there is no successful predicate, case will throw an error! 
Thankfully, it is easy to provide a default, and the last expression in a case will always be 
evaluated.

#+BEGIN_SRC clojure
  (defn translate
    [code]
    (case code
      "es" "Spanish"
      "en" "English"
      "fr" "French"
      "Unknown"))
  (translate "fr")
  (translate "pg")
#+END_SRC

#+RESULTS:
: #'user/translate"French""Unknown"


* Naming Things (lc) / Namespaces
** Binding Values to Symbols / Vars (lc)
"Clojure symbols refer to values. When a symbol is evaluated, it returns the thing it refers 
to." (lc) In Clojure, references cannot be reassigned - consistent with values being 
immutable. Use let inside functions, not def!
**** def
Creates a var "object" scoped to the namespace. 

#+BEGIN_SRC clojure :results output
(def foo "bar")
(println foo)
#+END_SRC

#+RESULTS:
: bar

**** let
let defines a var "object(s)" scoped to the let expression. As its first parameter, let 
takes a vector of paired items, typically symbol / expression pairs, and binds each expression's value to its corresponding symbol.
  Remaining arguments are evaluated in the scope of the let bindings.

#+BEGIN_SRC clojure :results output
  (let [sym "value"] 
    (println sym))
  (println sym)
#+END_SRC

#+RESULTS:
: value
** Destructuring (lc, cu)
Anywhere you bind values (let, for, doseq, etc...) you can take advantage of destructuring. 
Destructuring takes two forms, positional destructuring with indexed sequences or associative 
destructuring with associative data structures. 
  In the following example, the let binding contains two vectors nested in its first parameter. 
The symbols in the first vector bind the values in the second vector according to their 
respective indexes.
  The _ is used as a placeholder, indicate that the value at that index is not needed. And, if a 
value is not present, the symbol will be bound to nil.

#+BEGIN_SRC clojure :results output
  ;; positional destructuring example, it's all about the index
  (let [[color _ shape] ["red" "heavy" "square"]]
    (println (str color " " shape)))

  ;; associative destructuring example, it's all about key matching
  (let [{a :a _ 'b c "c"} {:a "red" 'b "heavy" "c" "square"}]
    (println (str a " " c)))
#+END_SRC

#+RESULTS:
: red square
: red square

*** Using & to Bundle the Rest Parameters
Just like & can be used to collect surplus parameters to a variadic function, & can collect the remaining paramters in a destructuring form. 

#+BEGIN_SRC clojure :results output
  (let [[color & more] ["red" "heavy" "square" "ball"]]
    (println (str color " " (last more))))
#+END_SRC

#+RESULTS:
: red ball

*** Using :as to Retain the Original Data Structure
Sometimes you want to access the data structure you are destructuring in its original form. The :as keyword permits you to provide a symbol to bind the original data structure. Although this example uses a vector, this also works for destructuring maps.

#+BEGIN_SRC clojure :results output
  (let [[_ _ _ :as og] ["red" "heavy" "square" "ball"]]
    (println (reduce #(str %1 " " %2) og)))
#+END_SRC

#+RESULTS:
: red heavy square ball

*** Using :or to Provide Default Values When Associatively Destructuring
When destructuring a map, we can specify a default value for a symbol by using the :or keyword followed by a map with the symbol and default value.

#+BEGIN_SRC clojure :results output
  (let [{a :a b :b c :c :or {c "triangle"}} {:a "red" :b "heavy"}]
    (println (str a " " c)))
#+END_SRC

#+RESULTS:
: red triangle

*** Keeping the OG Keys Using :keys, :syms, and :strs
Often, the symbols we will want to bind values to match the keys in a map. When this is the case, we can use :keys, :syms, or :strs to associate a vector of symbols with keys (be they keywords, symbols, or strings) in the map.

#+BEGIN_SRC clojure :results output
  (let [{:keys [a b c]} {:a "red" :b "heavy" :c "square"}]
    (println (str a b c)))
  (let [{:syms [a b c]} {'a "red" 'b "heavy" 'c "square"}]
    (println (str a b c)))
  (let [{:strs [a b c]} {"a" "red" "b" "heavy" "c" "square"}]
    (println (str a b c)))
#+END_SRC

#+RESULTS:
: redheavysquare
: redheavysquare
: redheavysquare

*** Destructuring Nested Data
Thankfully, destructuring nested data is as easy as flat data.

#+BEGIN_SRC clojure :results output
  (let [{a :a [one two three] :b _ :c} {:a "red" :b [1 2 3] :c "square"}]
    (println (str a two)))
#+END_SRC

#+RESULTS:
: red2

** Namespaces (lc) / Organizing Your Project: A Librarian's Tale (brave)
vars are scoped to namespaces. The default namespace is "user". 
*** creating and identifying a namespace (lc)

#+BEGIN_SRC clojure :results output
  (ns alice.favfoods)
  (println  *ns*)
#+END_SRC

#+RESULTS:
: #object[clojure.lang.Namespace 0x763be7bf alice.favfoods]

*** accessing a namespace (lc)

#+BEGIN_SRC clojure :results output
  (ns userland)
  (println *ns*)
  (def whoDoYouFightFor "the users")
  (println whoDoYouFightFor)
  (ns the.System)
  (println *ns*)
  (println userland/whoDoYouFightFor)
#+END_SRC

#+RESULTS:
: #object[clojure.lang.Namespace 0x65170eca userland]
: the users
: #object[clojure.lang.Namespace 0x6caf1747 the.System]
: the System
: the users

*** :require(ing) libs (lc)
Clojure has 'libs', namespaces full of symbols bound to values. Likely, function buckets...
**** require
After we require a namespace, symbols in that namespace will be accessible through a qualified namespace.

#+BEGIN_SRC clojure
  (require 'clojure.set)
  clojure.set/union
#+END_SRC

#+RESULTS:
: nil#object[clojure.set$union 0x72f24ffb "clojure.set$union@72f24ffb"]

**** :require :as
We can use the :as option to set an alias for a namespace.

#+BEGIN_SRC clojure
  (ns wonderland 
    (require '[clojure.set :as s]))
  s/union
#+END_SRC

#+RESULTS:
: #object[clojure.set$union 0x72f24ffb "clojure.set$union@72f24ffb"]

This form is acceptable, but less common:

#+BEGIN_SRC clojure
  (require '[clojure.set :as s])
  s/union
#+END_SRC

#+RESULTS:
: nil#object[clojure.set$union 0x72f24ffb "clojure.set$union@72f24ffb"]


**** :require :refer :all
The :all option makes a namespaces symbold available in the current namespace without qualification. IF symbols conflict between namespaces, the compiler will throw an exception.

#+BEGIN_SRC clojure
  (ns wonderland
    (:require [alice.favfoods :refer :all]
              [rabbit.favfoods :refer :all]))
#+END_SRC
*** Using libs (lc)
** Namespaces (cu)


* Higher Order Functions and Working with Compound Data
** Function Calls, Macro Calls, and Special Forms (brave)
** Higher Order Functions (brave)
** Functions Creating Functions and other Neat Expressions (lc) / Function Functions (brave)
*** partial (brave, lc)
Partial application is the process of fixing arguments to a function, and returning a 
function with a correspondingly smaller arity. The partial expression accepts a function and 
an expression, and returns a function with the expression fixed as the original functions 
first argument. This is a sort of left-to-right motion.

#+BEGIN_SRC clojure :results output
  (def half (partial #(println (str %1 %2)) "Only the beginning..."))
  (half "this is the end")
#+END_SRC

#+RESULTS:
: Only the beginning...this is the end

*** comp (brave, lc)
Function composition means composite abstraction. The comp expression takes any number of 
functions as parameters, and returns the composition of those functions in a right to left 
manner.

#+BEGIN_SRC clojure
  (def printStr (comp println str))
  (printStr "one" "two")
#+END_SRC

*** apply (brave)
** Data Transformation with Higher-Order Functions (lc) / Seq Function Examples (brave)
The venerable for loop is often used to iterate over an ordered collection of data and affect some transformation of that collection. But, there's a better way! The sequence abstraction's generic interface permits us to use a great many functions on collections.
*** map (cu, lc, brave)
The map function accepts a function and a seq, and returns a new, lazy seq from the result of 
applying the function to each item in the original seq. Map is also capable of handling 
multiple collections, in which case each collection populates the parameters of a function; but 
the map will terminate when the shortest collection ends.

#+BEGIN_SRC clojure
  (map #(* %1 %2) '(1 2 3 4 5) '(2 3 4))
#+END_SRC

#+RESULTS:
| 2 | 6 | 12 |
*** mapping over maps
When you map over a map, the function you pass to map will recieve a two-item vector, containg the key and the value from the map. You can destructure the vector in the function's signature to ease this complexity.

#+BEGIN_SRC clojure
  (map (fn [[key value]] (* value value)) {:one 1 :two 2 :three 3})
#+END_SRC

#+RESULTS:
| 1 | 4 | 9 |

However, if the keys are not needed, it is more idiomatic to extract the values before passing them to map.

#+BEGIN_SRC clojure
  (map (fn [value] (* value value)) (vals {:one 1 :two 2 :three 3}))
#+END_SRC

#+RESULTS:
| 1 | 4 | 9 |

*** reduce (cu, lc, brave)
The reduce function boils down a seq to a single value, using an accumulator during the 
iteration. reduce accepts a function for accumulating values, an optional initial value, and 
and a collection.
  A function passed to reduce must have two parameters. The first parameter represents the 
accumulator, the value that was returned from the last iteration of reduce. The second 
parameter represents the current item in the collection. The function must return a value, this 
value is the accumulator. 

#+BEGIN_SRC clojure
  (reduce + '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: 15

#+BEGIN_SRC clojure
  (reduce + 100 '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: 115

#+BEGIN_SRC clojure
  (reduce #(* %1 %2) '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: 120

*** filter (cu, lc, brave)
The filter function accepts a predicate and a seq, and returns a seq containing each item in 
the original seq that passes the predicate.

#+BEGIN_SRC clojure
  (filter true? '(true false true true false))
#+END_SRC

#+RESULTS:
| true | true | true |

*** remove (lc)
remove is the opposite of filter, returning a seq of items that fail the predicate.

#+BEGIN_SRC clojure
  (remove odd? (range 0 20))
#+END_SRC

#+RESULTS:
| 0 | 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 |

*** flatten (lc)

#+BEGIN_SRC clojure
  (flatten '([1 2 3 [4 5 [6]]]))
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 | 6 |

*** into (lc)
into returns a collection made by conj-ing the items in its second argument onto its first 
argument. This is useful for converting one collection type to another.

#+BEGIN_SRC clojure
  (into {} [[:a "A"] [:b "B"]])
#+END_SRC

#+RESULTS:
| :a | A | :b | B |

#+BEGIN_SRC clojure
  (into '(0) [1 2 3 4])
#+END_SRC

#+RESULTS:
| 4 | 3 | 2 | 1 | 0 |

#+BEGIN_SRC clojure
  (into [] {:a "A" :b "B"})
#+END_SRC

#+RESULTS:
| :a | A |
| :b | B |

*** partition &  partition-all (lc)

#+BEGIN_SRC clojure
  (partition 4 (range 0 11))
#+END_SRC

#+RESULTS:
| 0 | 1 | 2 | 3 |
| 4 | 5 | 6 | 7 |

#+BEGIN_SRC clojure
  (partition-all 4 (range 0 11))
#+END_SRC

#+RESULTS:
| 0 | 1 |  2 | 3 |
| 4 | 5 |  6 | 7 |
| 8 | 9 | 10 |   |

*** partition-by (lc)
partion-by is unique in that its first parameter is a function, and the second a collection. The function is applied to each item in the collection, and whenever the evaluation of the function changes, a new partition is begun.

#+BEGIN_SRC clojure
  (partition-by #(= % 6) (range 0 11))
#+END_SRC

#+RESULTS:
| 0 | 1 | 2 |  3 | 4 | 5 |
| 6 |   |   |    |   |   |
| 7 | 8 | 9 | 10 |   |   |

*** take, drop, take-while, and drop-while (brave)
*** concat (brave)
*** more (lc)
** Recursion With loop and recur (lc)
*** loop (cu)
loop is similar to let, in that it's first parameter is a vector that establishes bindings for 
the remainger of the expression. Within a loop expression, a recur expression causes execution 
of the loop to return to the beginning of the loop with new bindings specifiied in the recur 
expression. This is Clojure's way of recursion without consuming the stack.

#+BEGIN_SRC clojure :results output
  (loop [x 0
         y 1]
    (if (= x y)
      (println "X is equal to Y")
      (do
        (println (str x " is not equal to " y))
        (recur (inc x) y))))
#+END_SRC

#+RESULTS:
: 0 is not equal to 1
: X is equal to Y
** Living with Immutable Data Structures (brave)
*** Recursion Instead of for/while
*** Function Composition Instead of Attribute Mutation


* State and Concurrency (lc) / Clojure Metaphysica: Atoms, Refs, Vars... (brave)
** State Management (cu)
*** Vars (cu, brave)
*** Using Atoms for Independent Items (lc) / Atoms (brave, cu)
*** Using Refs for Coordinated Changes (lc) / Refs (brave)
*** Using Agents to Manage Changes On Their Own (lc)
*** Volatiles
*** Watches and Validators (brave)
** Concurrency and Parallelism Concepts (brave)
*** Synchronous and Asynchronous
*** Concurrent and Parallel
*** Threads and the JVM
**** Reference Cells
**** Mutual Exclusion
*** Futures
*** Delays
*** Promises
** core.async (lc) / Mastering Concurrent Processes with core.async (brave)
*** Getting Started with Processes (brave)
*** queues (brave)
*** channels (lc)


* Host Interop (lc, brave, cu)
** Java Interop (lc) 
** Javascript (cu)
** Working with the JVM (brave)


* Creating and Extending Abstractions... (brave) / Abstractions and Polymorphism (cu)
** Polymorphism (brave)
*** multimethods (brave, cu)
*** protocols (brave, cu)
** Records (brave)
** Heirarchies (cu)


* The Reader, Evaluation, and Macros (brave) / The Power of Macros (lc)
** Macros (lc) / Clojure Alchemy: Reading, Evaluation, and Macros (brave)
*** Clojure's Evaluation Model (brave)
*** The Reader (brave)
*** The Evaluator (brave)
*** templating (lc)
** Threading Macros (cu)
*** Thread First
*** Thread Last
** Reader Conditionals (cu)
** Writing Macros (brave)


* Rolling Our Own Data Types (cu)


* Tooling
** Getting Set Up With a Clojure Editor (lc)
** Lein / Boot
*** Creating Our Project with Lein (lc)
*** Dep Management with Lein (lc)
*** Building and Developing with Leiningen (brave)
*** Boot, the Fancy Clojure Build Framework (brave)


* Web Libs
** Creating a Web Server With compojure
** Using JSON with the Cheshire and Ring
** Making HTTP Calls with ClojureScript and cljs-http
** DOM control with ClojureScript and Enfocus
** Event Handling with Enfocus
** Hiccup, Enlive, Liberator, Transit
** Om / OmNext
** Using Hoplon and Luminus for Inclusive, Bundled Libraries for Web Development
** Dealing with Databases
