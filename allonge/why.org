  
 The Y combinator:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const Y = (f) =>
  ( x => f(v => x(x)(v)) )
  ( x => f(v => x(x)(v)) );

  const factorial = Y(function (fac) { 
    return function (n) {
      return (n == 0 ? 1 : n * fac(n - 1)); }
    });

  console.log(factorial(5));

#+END_SRC

#+RESULTS:
: 120

  Here's my guide to the y-combinator!

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  // First I present the Y combinator:

  const Y = (f) =>
  ( x => f(v => x(x)(v)) )
  ( x => f(v => x(x)(v)) );

  // Next, a function to pass to the Y combinator
  // It's nothing fancy, just a function to compute factorials
  // It's interesting to note that it returns a function
  // that returns a ternary expression, reminiscent of linear recursion

  const factorial = Y(function (fac) { 
    return function (n) {
      return (n == 0 ? 1 : n * fac(n - 1)); }
    });

  // 

  factorial(5);

  // Let the substitution begin!
  // First I'll substitute function where its called.

  (Y(function (fac) {
    return function (n) {
      return (n == 0 ? 1 : n * fac(n - 1)); }
    }))(5)

  // Now, to substitute in the Y combinator
  
  (((f) =>
    ( x => f(v => x(x)(v)) )
    ( x => f(v => x(x)(v)) ))
   (function (fac) {
    return function (n) {
      return (n == 0 ? 1 : n * fac(n - 1)); }
    }))(5)

 // My, my, my, my, my. what a mess
 // lets apply our function to the combinator
 // and see if we can't clean this up

  (( x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })
   ( x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); }))(5)
   
 // Well, it does look more orderly. But I fear we'll just make a mess of it again.
 // Now to apply the inner functions to each other.
 // Hopefully this will return a function to which we can apply 5...

  (n => { 
    return (
      n == 0
        ? 1 
        : n * (v => (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })
                    (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })(v)
              )(n - 1)
    ); 
  })(5)

  // Ok, I just ran the above and got the same answer.
  // So, I'm going to proceed as if I haven't make any substitution errors.
  // Let's begin to evaluate our function!
  // First, we pass 5 to our function, binding 5 to n
  // n !== 0 so we're left with


  (5 * (v => (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })
             (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })(v)
       )(4));

  // AKA

  (5 * ((x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })
        (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })(4)));

  // Can you see where this is going?
  // If the ternary embedded in the function didn't tip you off...
  // This should definitely smell like linear recursion at this point!
  // We've got a starting value that looks like it's the beginning of a deffered computation;
  // And we're about to apply its decrement to a function that looks suspiciously similar to 
  // the Y combinator that we started with.

  // Enough talking. Substitute!
 
  (5 * (n => {
         return (
           n == 0
             ? 1
             : n * (v => (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })
                         (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })
                         (v)
                   )(n - 1)
         );
       })(4));

  // 4 !== 0
  // Again! Again!

  (5 * 4 * (v => (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })
                 (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })(v)
           )(3));

  // Simpler! Simpler!

  (5 * 4 * ((x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })
            (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })(3)));

  // Whew! That's tiring. I'm going to stop here. I think we all get the idea...
  // So what's going on, there seems to be dinstinct behavior for three pieces
  // First, X has no interaction with our factorial function. 
  // Second, V serves as a means to pass the decrement of the original input to
  // the next recursion. In this way it balances n => in our factorial function
  // Third, the factorial function 


#+END_SRC
