Javascript Allonge Notepad

* Aside: Welcome to fugalfunkster's notebook

** Hello... But, why? 
   My name is Matthew, and I remember things better when I write them down.
   Normally, I like to take notes with pen and paper, and I keep myself organized
   with index cards. but now that I'm learning to program computers, I've reached 
   the limit of that medium. In the search for something more idiomatic, 
   interactive, and sharable, I found org mode.
     Org mode is a mode (modality) for emacs, packed full of tools for organizing 
   ones thoughts and getting things done. Note that this document is just a text 
   file with a .org file type. Viewed without the aid of org mode, the document
   contains meaningful but useless markup. When edited in emacs' org mode, that
   markup breathes structure and interactivity into the document.
     This notebook is the product of my study of Reginald Braithwaite's "Javascript
   Allonge." 

** Org-Mode and Literate Programming
   This document is saved as a text file, suffixed with .org 

*** http://howardism.org/Technical/Emacs/literate-programming-tutorial.html

*** Not all code will appear in a block
** Terminology

*** cf : compare

** Org-Babel

** ES6 code blocks

*** node npm babel
*** http://rwx.io/blog/2015/10/06/org-with-babel-node/

*** In this doc, code blocks will be labeled as "Ex:" with their own bullet to expand
*** Note that many of these code blocks begin with return when the result isn't 
*** logged to stdout (in this case, console.log)
**** this is required to recieve the return value of an expression 
**** because org-babel executes the code-block within a function wrapper

** Properties
*** Here's the doc-wide tangle property if you wish to modify it:
**** note, this property tag must be registered with the point over the code
**** and a lil C-c C-c
***  Getting the result
**** :results output
*** using babel
**** :cmd "org-babel-node --presets es2015"
*** Do the tangle
**** What is tangling?
***** http://orgmode.org/manual/Extracting-source-code.
**** It takes "C-c C-v t" to tangle
**** Select code blocks in this document will to tangle out to recipes.js
***** but only for those blocks with the property :tangle yes

 
* Prelude: Values and Expressions over Coffee

** values are expressions
*** but not all expressions are values
*** when an expression includes an operator, it is not a value
** values and identity
*** we test whether two values are identical with === and !== 
** value types
*** primitives can be identical
*** 123 === 123 >> true
** reference types
*** reference types are always unique
*** [1,2,3]===[1,2,3] >> false


* A Rich Aroma: Basic Numbers

** literal: notation for representing a fixed value in source code
*** nums are double-precision floating point 
*** binary is base 2, some fractions base 10
*** do not have exact representations base 2
*** this is problematic, in monetary calculations for example
** operations on numbers
*** +, -, *, /, %, -:

    
* The First Sip: Basic Functions
 
** As little as possible about Functions
*** functions are values that represent computations to be performed

***** Ex:
  #+BEGIN_SRC js
    return () => 0
  #+END_SRC

  #+RESULTS:
  | Function |

**** We use functions by applying them to arguments (0 or more values)

***** Ex:
  #+BEGIN_SRC js
    return (() => 0 )()
  #+END_SRC

  #+RESULTS:
  : 0

**** functions return values (including other functions)
**** functions evaluate expressions
*** blocks
**** blocks contain zero or more statements, separated by semicolons
**** a block containg no statements evaluates to undefined
*** undefined, the absence of value - another primitive value
**** void is an operator that takes any value
**** and always evaluates to undefined
**** idiomatically: void 0 >> undefined
*** statements
**** all expressions are statements - but some return undefined when applied

***** Ex:
 #+BEGIN_SRC js
   return () => {2 + 2}
 #+END_SRC

 #+RESULTS:
 | Function |

***** cf Ex: 
#+BEGIN_SRC js
  return (() => {2+2})()
#+END_SRC

#+RESULTS:
: undefined

**** not all statements are expressions
*** the return keyword
**** allows us to return a value from a function,
**** when that function evaluates a block
**** return immediately terminates the function application and 
**** returns the result of evaluating its expression

***** Ex:
 #+BEGIN_SRC js
  return (() => { return 2+2; })()  
 #+END_SRC

 #+RESULTS:
 : 4

*** functions are reference types


** Ah. I'd like to Have an Argument, Please.
*** a quick summary of functions and bodies
**** Expressions consist either of representations of values,
**** operators that combine expressions, and special forms
**** like object/array/function literal notation
**** A return statement accepts any valid JS expression
*** I. - Call by value
**** javascript will evaluate all expressions applied to a function
**** then applies the function to the resulting value(s)
*** variables, bindings, and environment
**** Every time a function is invoked, a new environment is created
**** each environment maps variable names to argument values
**** like a dictionary {x: 2}

***** Ex:
#+BEGIN_SRC js
  ((x) => x)(2)
#+END_SRC

#+RESULTS:
: undefined

**** recall YDKJS discussion of scope/environments/etc...
*** II - Call by sharing
**** when js binds a value-type to a name it makes a copy of the value
**** when js binds a reference-type to a name, it uses a reference


** Closures and Scope
*** Free Variables - those not bound within the function
**** bound with a var/let/const or via an argument
**** Functions containing no free variables are called pure functions
***** But a pure function can contain a closure

***** Ex:
#+BEGIN_SRC js
  return ((x) => (y) => x)(1)(2)
#+END_SRC

#+RESULTS:
: 1

**** Functions containing one or more free variables are called closures
***** closures cannot contain pure functions, because free variables
***** remain accessable to inner functions
*** Intro to Combinators!
**** the I Combinator (aka the Identity Function)
***** (x) => x
**** the K Combinator (aka Kestrel)
***** (x) => (y) => x
*** shadowing - local scope shadows parent scope
*** the global environment
**** many programmers enclose each javascript file within a function expression
***** (() => { . . . })();


** That Constant Coffee Craving
*** Immediately Invoked Function Expressions
**** We can bind any value we want for an expression by wrapping the expression
**** in a function and subsequently invoking the function with our value

***** ex: 
#+BEGIN_SRC js
  return ((pi) => (diameter) => diameter * pi)(3.14)(10)
#+END_SRC

#+RESULTS:
: 31.400000000000002

**** inside-out

***** Ex:
#+BEGIN_SRC js
  return ((diameter) => ((pi) => diameter * pi)(3.14))(10)
#+END_SRC

#+RESULTS:
: 31.400000000000002

**** invoking functions is considerably more expensive than evaluating functions
***** every time we invoke the outer function, we'll invoke the inner function
*** const - can bind any expression (including functions)
**** the const keyword introduces one or more bindings in its enclosing block
***** const statements must occur inside blocks,
***** we can't use them when we write a fat arrow that has an expression as its body
**** naming functions is elegant when functions are expressions
**** const can affect multiple bindings using commas
*** nested blocks - not just for functions
**** other kinds of blocks
***** if statements are not expressions, its clauses are statements or blocks
***** const scopes to these blocks too!
*** const obeys lexical scope
**** blocks delineate const-binding's environment
**** const shadows just like parameter/argument bindings
*** Bind names as close to where we need them as possible
**** this design rule is called the Principle of Least Priviledge
**** it has both quality and security implications
*** rebinding - not with const
**** although we can rebind named parameters/arguments to a different value
**** javascript does not permit us to rebind const-s


** Naming Functions
*** the function keyword
**** can have a name! - and should for code clarity and debugging
***** confusingly, we could still bind the named functions with const
***** this would result in a binding in the enclosing environment
***** but the function would retain its given name
***** so we would have created a named function expression
****** the name of the function is a property of the function 
**** the body must be a block
**** thus we must use the return keyword to return a value from the block
**** Note on named function expressions 
***** the function name is not available in the enclosing scope
***** but the function name is available within the body of the function
***** preserves recursion without resorting to shenanegans
*** function declarations
**** a statement instead of an expression
**** the function's name becomes bound in the environment
**** note, function declarations are hoisted
*** function declarations should not occur within other blocks or expressions
**** of course, functions declarations often do occur inside other function blocks
**** see for example, the note on the global environment in Closures and Scope


** Combinators and Function Decorators
*** higher order functions
**** any function that takes a function as argument, returns functions, or both
*** combinators
**** Technical Definition
***** "A combinator is a higher-order function that uses only function application
***** and earlier defined combinators to define a result from its arguments"
**** Looser definition
***** higher-order pure functions that take only functions as arguments
***** and return a function
**** the B combinator (aka Blackbird)
***** const compose = (a, b) => (c) => a(b(c))
**** combinators are useful for reasoning about what you're doing and how (verbs)
**** be more explicit when reasoning about what you're working with (nouns)
*** function decorators
**** definition
***** a higher-order function that takes one function as an argument,
***** and returns a function (a variation of the argument function)
**** function decorators need not be pure

     
** Building Blocks
*** composition
**** Ex: const cookAndEat = (food) => eat(cook(food));
**** the trick is to organize your code so you can compose functions
*** partial application
**** When a function takes multiple arguments, we need not apply all arguments
***** if we can return a function with arguments pre-supplied
**** orthogonal (involving right angles) to composition


** Magic Names
*** this
**** bound to the function's context (dynamic)
*** arguments
**** an array like object that contains all of the arguments passed to a function
**** we'll use it to build functions that can take a variable number of arguments
*** on fat arrows
**** this and arguments take on the binding from the enclosing scope!
*** Function Design Principles
**** If you call a function more than once, give it a name and first-class status
**** If the function only represents an expression to be computed, use fat arrows
**** The distinction helps sort out the syntatic differences re: magic words
     

** Summary
*** Functions are values that can be part of expressions, returned from other functions
*** Functions are reference values
*** Functions are applied to arguments
*** The arguments are passed by sharing, which is also called pass by value
*** Fat arrow functions have expressions or blocks as their bodies
*** function keyword functions always have blocks as their bodies
*** Function bodies have zero or more statements
*** Expression bodies evaluate to the value of the expression
*** Block bodies evaluate to whatever is returned with the return keyword, else undefined
*** JS uses const to bind values to names within block scope
*** JS uses function declarations to bind functions to names within function scope
*** Function declarations are hoisted
*** Function application creates an environment, with scope
*** Blocks also create scopes if const statements exist within
*** Scopes are nested and free variable references closed over
*** Variables can shadow variables in an enclosing scope


* Recipies with Basic Functions

** Partial Application
*** Recipe: 

#+BEGIN_SRC js :tangle yes
const callFirst = (fn, larg) =>
  function (rest) {
  return fn.call(this, larg, rest);
};

const callLast = (fn, rarg) =>
  function (rest) {
  return fn.call(this, rest, rarg);
};
#+END_SRC

*** TODO let author know that ...rest as a function param causes error
*** Example:

#+BEGIN_SRC js
const callFirst = (fn, larg) =>
  function (rest) {
  return fn.call(this, larg, rest);
};

const greet = (me, you) =>
  `Hello, ${you}, my name is ${me}`;
 
const heliosSaysHello = callFirst(greet, 'Helios');

console.log(heliosSaysHello('Celine'));

#+END_SRC

#+RESULTS:
: Hello, Celine, my name is Helios
: undefined

*** note that an application of callLast could be named sayHelloToCeline
*** Gathering and Spreading allow partial application for many args
*** TODO Recipe:

#+BEGIN_SRC js tangle: yes
 const callLeft = (fn, args) =>
  (remainingArgs) =>
    fn(args, remainingArgs);

 const callRight = (fn, args) =>
  (remainingArgs) =>
    fn(remainingArgs, args);

#+END_SRC

#+RESULTS:
: undefined

*** play with these examples in the repl
*** design a function with three arguments and partially apply them
*** try a function with four arguments


** Unary
*** Definition
**** A function decorator that modfies a function so that it takes only one argument
*** Recipe:

#+BEGIN_SRC js :tangle yes
const unary = (fn) =>
   fn.length === 1
     ? fn
     : function (something) {
         return fn.call(this, something);
};
#+END_SRC

#+RESULTS:
: undefined

*** Example:

#+BEGIN_SRC js
const unary = (fn) =>
   fn.length === 1
     ? fn
     : function (something) {
         return fn.call(this, something);
};
console.log(['1', '2', '3'].map(unary(parseInt)));
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 |

*** Note that the unary operator is necessary above because parseInt is defined
*** as parseInt(string[, radix]). parseInt takes an optional radix argument. 
*** And when you call parseInt with map, the index (an argument of map) is 
*** interpreted as a radix.


** Tap

*** the K combinator (Kestrel)
**** const K = (x) => (y) => x;
*** Recipe:

#+BEGIN_SRC js
const tap = (value) =>
 (fn) => (
   typeof(fn) === 'function' && fn(value),
     value
   );
#+END_SRC

#+RESULTS:
: undefined

*** Description:
**** tap takes a value and returns a function that always returns the value
**** but, if you pass it a function, it executes the function (using the value 
**** as an argument) for side-effects
*** Application Example:

#+BEGIN_SRC js
const tap = (value) =>
 (fn) => (
   typeof(fn) === 'function' && fn(value),
     value
   );

tap('espresso')(it => {
  console.log(`Our drink is '${it}'`);
});
#+END_SRC

#+RESULTS:
: Out drink is 'espresso'
: undefined

*** Recipe: w/o 'currying'

#+BEGIN_SRC js
const tap = (value, fn) => {
   typeof(fn) === 'function' && fn(value),
   value
};
#+END_SRC

#+RESULTS:
: undefined
 
*** Recipe: (currying optional)

#+BEGIN_SRC js :tangle yes
const tap = (value, fn) => {
  const curried = (fn) => (
    typeof(fn) === 'function' && fn(value),
    value
  );
 
  return fn === 'undefined'
    ? curried
    : curried(fn);
};
#+END_SRC

#+RESULTS:
: undefined

*** a poor mans debugger, and useful for working with object and instance methods


** Maybe
*** sometimes you want to vet a value before you pass it to a function
**** in JS you might: value !== null && value !== void 0
**** to ensure that the value is not null or undefined
**** naturally there's a function decorator for that
*** Recipe:

#+BEGIN_SRC js :tangle yes
'use strict'
const maybe = (fun) =>
  function (args) {
    if (args.length === 0) {
      return
    } else {
      for (let arg of args) {
        if (arg == null) return;
      }
    return fn.apply(this, args)
    }
};
#+END_SRC

#+RESULTS:
: undefined

*** note: plays nicely with instance methods (foreshadowing)


** Once
*** Ensures that a function can only be called once
*** Recipe:

#+BEGIN_SRC js :tangle yes
'use strict'
const once = (fn) => {
  let done = false;
 
  return function () {
    return done ? void 0 : ((done = true), fn.apply(this, arguments))
  }
};
#+END_SRC

*** Example:

#+BEGIN_SRC js
'use strict'
const once = (fn) => {
  let done = false;
 
  return function () {
    return done ? void 0 : ((done = true), fn.apply(this, arguments))
  }
};

const askedOnABlindDate = once(
  () => 'sure'
);

console.log(askedOnABlindDate());
console.log(askedOnABlindDate());
console.log(askedOnABlindDate());
console.log(askedOnABlindDate());

#+END_SRC

#+RESULTS:
: sure
: undefined
: undefined
: undefined
: undefined

*** there's a closure here, to manage the internal state of 'done'
*** see stateful method decorators... (foreshadowing)


** Left-Variadic Functions
*** Variadic functions accept a variable number of arguments.
**** JS now lets you do this when using rest parameters. Ex: (x, y, ...z)
**** This may be useful for certian kinds of destructuring algorithms
**** But JS only permits gathering parameters from the end of the parameter list
***** AKA: Right Variadic Functions
*** Left Variadic Functions require some fussing
**** thankfully, the rest parameter is (acts like?) a proper array
**** so we can grab all argument with the rest parameter, and slice them up to 
**** grab the right-most arguments, and bundle the rest
*** Recipe:

#+BEGIN_SRC js :tangle yes
const leftVariadic = (fn) => {
  if (fn.length < 1) {
    return fn;
  } else {
    return function (args) {
      const gathered = args.slice(0, args.length - fn.length + 1), spread = args.slice(args.length - fn.length + 1);
      return fn.apply(
        this, [gathered].concat(spread)
      ); }
    } 
};

#+END_SRC

#+RESULTS:
: undefined

*** Example:
    
#+BEGIN_SRC js
const leftVariadic = (fn) => {
  if (fn.length < 1) {
    return fn;
  } else {
    return function (args) {
      const gathered = args.slice(0, args.length - fn.length + 1), spread = args.slice(args.length - fn.length + 1);
      return fn.apply(
        this, [gathered].concat(spread)
      ); }
    } 
};

const butLastAndLast = leftVariadic((butLast, last) => [butLast, last]);
console.log(butLastAndLast(['why', 'hello', 'there', 'little', 'droid']));
#+END_SRC

#+RESULTS:
| (why hello there little) | droid |

*** TODO wierd error with ...args, and argument to butLastAndLAst should be an array
*** Destructuring
**** Javascript can now destructure arrays when assigning variables 
**** Recipe:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
'use strict'
const [first, ...butFirst] = ['why', 'hello', 'there', 'little', 'droid'];
console.log(butFirst);
console.log(first); 
#+END_SRC

#+RESULTS:
: [ 'hello', 'there', 'little', 'droid' ]
: why

**** Note again, this is right variadic destructuring
*** leftGather
**** We can use the rest parameter, and Array#slice to make our own leftGather function
**** we have to supply the length of the array into which we will destructure
**** so that excess arguments can be collected in the left parameter
**** Recipe:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :tangle yes
const leftGather = (outputArrayLength) => { 
  return function (inputArray) {
    return [inputArray.slice(0, 
            inputArray.length - outputArrayLength + 1)]
           .concat(
             inputArray.slice(inputArray.length - outputArrayLength + 1)
           )
    } 
};
#+END_SRC

**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
const leftGather = (outputArrayLength) => { 
  return function (inputArray) {
    return [inputArray.slice(0, 
            inputArray.length - outputArrayLength + 1)]
           .concat(
             inputArray.slice(inputArray.length - outputArrayLength + 1)
           )
    } 
};

const [butLast, last] = leftGather(2)(['why', 'hello', 'there', 'little', 'droid']);
console.log(butLast);
console.log(last);

#+END_SRC  

#+RESULTS:
: [ 'why', 'hello', 'there', 'little' ]
: droid

     
** Compose and Pipeline
*** The B Combinator (again)
*** Recipe:

#+BEGIN_SRC js :tangle yes
  const compose = (a, b) =>
  (c) => a(b(c))
#+END_SRC

*** Example:
 
#+BEGIN_SRC js
  const compose = (a, b) =>
    (c) => a(b(c))

  const addOne = (number) => number + 1;
  const doubleOf = (number) => number * 2;
  const doubleOfAddOne = compose(doubleOf, addOne);

  console.log(doubleOfAddOne(3));

#+END_SRC

#+RESULTS:
: 8
: undefined

*** Variadic compose through recursion 
**** Recipe:

 #+BEGIN_SRC js
 const compose = (a, rest) =>
   rest.length === 0
     ? a
     : (c) => a(compose(rest)(c))

 #+END_SRC

*** Semantics
**** Compose isn't necessarily helpful for compound actions that are realted,
**** like intermediate steps in a calculation.
**** But, to combine multiple, single-purpose functions, compose works nicely.
**** Thus, compost is at its best when defining a new function
**** that combines the effects of existing functions
*** Pipeline
**** Compose accepts arguments that execute from right to left,
**** ex: (doubleOf, addThree)
**** which is not the most intuitive, we have to write the function name of the 
**** first argument to reflect that it is acting on the result of the next argument
**** pipeline solves this by allowing function names that are syntatically insensitive
*** Recipe:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :tangle yes
  const pipeline = (...fns) => 
    (value) =>
      fns.reduce((acc, fn) => fn(acc), value);
#+END_SRC

*** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" 
  const pipeline = (...fns) => 
    (value) =>
      fns.reduce((acc, fn) => fn(acc), value); 

  const addOne = (number) => number + 1;
  const double = (number) => number * 2;
  const setter = pipeline(addOne, double);

console.log(setter(2));
#+END_SRC

#+RESULTS:
: 6
: undefined


* Picking the Bean: Choice and Truthiness
** Boolean
*** true and false are value types, true === true, false === false
** truthiness
*** 6 kinds of wrong
**** 0, '', NaN, undefined, null, false
*** Everything else is truthy
** "Logical" operators evaluate truthiness, not boolean values
*** ! - negation operator
**** unary prefix
**** returns false if its argument is truthy
**** returns true if its argument is falsey
***** !! is a way to convert a truthy value to the boolean true
*** && - logical and
**** binary infix
**** && evaluates its left-hand expression, and if falsey, returns that value
**** else, && evaluates and returns its right-hand expression
*** || - logical or
**** binary infix
**** || evaluates its left-hand expression, and if truthey, returns that value
**** else, || evaluates and returns its right-hand expression
*** first ? second : third  - the ternary operator
**** if the ternary's first argument is truthy,
**** it evaluates it's second argument,
**** otherwise it evaluates its third argument
**** an expression, not a statement (like if/else)
** These operators provide flow control, not pure logical operators
*** Function parameters are eagerly evaluated
**** This means that JavaScript always evaluates expressions provided as parameters
**** to a function, before passing those values into the function for invocation
**** Recall Applicative Order and Normal Order
***** See SICP and HtDP
**** If we need to roll our own control-flow semantics,
**** we must pass functions as parameters to other functions,
**** not expressions, which would be evaluated
*** Flow Control operators have "short-cut" semantics


* Composing and Decomposing Data

** Arrays and Destructuring Arguments
*** Arrays are ordered collections of elements
**** Arrays are reference types
**** Literals - [element, element, element]
***** Array literals are expressions that evaluate to an array
**** Element References
***** In JavaScript, arrays are 0 based
***** You can extract an element within an array by using bracket notation
***** Example:

#+BEGIN_SRC js
  const x = [], a = [x];
  console.log(a[0] === x);

#+END_SRC

#+RESULTS:
: true
: undefined

***** As the previous example demonstrates, 
***** arrays relate to their elements by reference
*** Destructuring Arrays
**** New ES6 Syntax
***** In addition to bracket notation, we can extract elements of an array
***** by destructuring the array.
***** Destructuring an array mirrors array declaration.
***** On the left side of an assignment,
***** we have brackers surrounding the name binding(s)
***** And on the right, the array to destructure
**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
// declare
  const container = ['goodies'];
// destructure
  const unwrap = (wrapped) => { 
    const [something] = wrapped;
    return something; 
  }
  console.log(unwrap(container));

#+END_SRC

#+RESULTS:
: goodies
: undefined

*** Gathering and Spreading
**** Gathering (extracting an array from an array)
***** We can also extract arrays from an array, for example extracting the head
***** and the remaining elements of the array (the "rest")
****** Recall our right and left variadiac functions
**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const [car, ...cdr] = [1, 2, 3, 4, 5];
  console.log(car);
  console.log(cdr);
#+END_SRC

#+RESULTS:
: 1
: [ 2, 3, 4, 5 ]
**** Spreading (assembling an array with an array)
**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
  const oneTwoThree = ['one', 'two', 'three'];
  console.log(['zero', ...oneTwoThree]);

#+END_SRC

#+RESULTS:
| zero | one | two | three |

*** Application
**** Destructuring is not Pattern Matching
***** When destructuring, the sides of the assignment operator should align
***** In other programming languages, a mismatched destructuring attempt will err
***** JavaScript, however, simply assigns undefined when destructuring fails
***** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
  const [thistle, that, theOther] = ['duck feet', 'tiger tail'];
  console.log(theOther);

  const [...what] = [];
  console.log(what);

#+END_SRC

#+RESULTS:
: undefined
: []
: undefined

**** Destructuring and Return Values
***** Some languages support multiple return values, ie: a function can return
***** several things at once, like a value and an error code. We can emulate that
***** with destructuring
***** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const description = (nameAndOccupation) => { 
    if (nameAndOccupation.length < 2) {
      return ["", "occupation missing"] 
    } else {
      const [[first, last], occupation] = nameAndOccupation;
      return [`${first} is a ${occupation}`, "ok"];
    }
  }

  const [reg, status] = description([["Reginald", "Braithwaite"], "programmer"]);

  console.log(reg);
  console.log(status);
#+END_SRC

#+RESULTS:
: Reginald is a programmer
: ok

**** Destructuring parameters
***** Consider that the parameters to a function are also a collection of elements
***** We can destructure those too! permitting us to create functions that accept
***** a variable number of arguments
***** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
 const theWholeShebang = (car, ...cdr) => [car, cdr];
 console.log(theWholeShebang('why', 'hello', 'there', 'little', 'droid'));

#+END_SRC

#+RESULTS:
: [ 'why', [ 'hello', 'there', 'little', 'droid' ] ]


** Self-Similarity
*** What is a list?
    Lists are a collection composed of zero or more elements.
      In the previous chapter, we created arrays through literal declaration
    and then destructured arrays into their constituent elements. These two
    operations are opposites.
      We can also define a list in terms of rules, that - if followed - 
    create a list. Traditionally, there are two rules that define a list. A list is
    either:
      1. Empty
      2. Consists of an element concatenated with a list
    Thus, [] is a list. So is ["baz", []]. 
*** A process to determing whether a value is an empty list:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const isEmpty = ([first, ...rest]) => first === undefined; 

  console.log(isEmpty([]));
  console.log(isEmpty([0]));
  console.log(isEmpty([[]]));

#+END_SRC

#+RESULTS:
: true
: false
: false

*** A recursive process to determine the length of an array

 #+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

   const length = ([first, ...rest]) =>
     first === undefined 
       ? 0
       : 1 + length(rest);

   console.log(length([]));
   console.log(length([1,2,3]));

 #+END_SRC

 #+RESULTS:
 : 0
 : 3
*** Recursion
    Our length function is recursive, it calls itself. This makes sense because
    our definition of a list is recursive, and if a list is self-similar, it is
    natural to create an algorithm that is also self similar.
      Recursive algorithms follow the "divide and conquer" strategy:
    1. Divide the problem into smaller problems
    2. If a smaller problem is solvable, solve the small problem
    3. If a smaller problem is not solvable, divide and conquer that problem
    4. When all problems are solved, compose the solutions   
*** Linear Recursion
    Linear recursion varies from this strategy in that it entails breaking off
    a piece of a problem, the terminal case, solving that piece and then sticking
    it onto a solution for the rest of the problem.
*** Flatten-ing

#+BEGIN_SRC  js :cmd "org-babel-node --presets es2015" :results output

  const flatten = ([first, ...rest]) => {
    if (first === undefined) {
      return [];
    } else if (!Array.isArray(first)) {
      return [first, ...flatten(rest)];
    } else {
      return [...flatten(first), ...flatten(rest)];
    }
}

console.log(flatten(['foo', [3, 4, []]]));

#+END_SRC

#+RESULTS:
: [ 'foo', 3, 4 ]

*** Map-ing:
    Mapping, applying a function to each element of an array, is a form of 
    linear recursion.
**** Recipe:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" 
  const mapWith = (fn, [first, ...rest]) => {
    first === undefined
      ? []
      : [fn(first), mapWith(fn, rest)];
  }

#+END_SRC
**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" 
  const mapMaker = (fn, [first, ...rest]) => 
    first === undefined ? [] : [fn(first), ...mapMaker(fn, rest)];

  console.log(mapMaker((x) => x * x, [1,2,3,4]));

#+END_SRC

#+RESULTS:

*** Fold-ing:
    With the exception of the length example earlier, all of our examples have used
    the spread operator, ... , to rebuild our solution. We might instead want to
    concatenate the values from each step of the process.
**** sumSquares Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const sumSquares = ([first, ...rest]) => 
    first === undefined 
      ? 0
      : first * first + sumSquares(rest);

  console.log(sumSquares([1,2,3]));

#+END_SRC

#+RESULTS:
: 14

**** sumSquares vs. Map
     There are two differences between sumSquares and our map example:
       1. Given the terminal case of an empty list, we return 0 instead of []
       2. We catenate the square of each element to the result of fn(rest) 
**** foldWith, a moar general mapWith:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const foldWith = (fn, terminalValue, [first, ...rest]) => 
    first === undefined
      ? terminalValue
      : fn(first, foldWith(fn, terminalValue, rest));

  console.log(foldWith((x, rest) => x * x + rest, 0, [1,2,3]));

#+END_SRC

#+RESULTS:
: 14

*** Folding is a form of linear recursion, mapping is a form of folding 
    We can represent a map as a fold, we just need to supply the array-rebuilding 
    code
**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const foldWith = (fn, terminalValue, [first, ...rest]) => 
    first === undefined
      ? terminalValue
      : fn(first, foldWith(fn, terminalValue, rest));

  const mapWith = (fn, array) => 
    foldWith((first, rest) => [fn(first), ...rest], [], array);

  const squareAll = (array) => mapWith((x) => x * x, array);

  console.log(squareAll([1,2,3,4,5]));

#+END_SRC

#+RESULTS:
: [ 1, 4, 9, 16, 25 ]

  
** Tail Calls (and Default Arguments)
*** Stack Overflow 
    Our implementations of mapWith and foldWith consume memory proportional
    to the size of the array on which they operate. Each time the process recurrs, 
    the engine will open a new function execution context to contine the recursion.
    But, because information that is critical to the final result remains in 
    each function body (at each level or recursion) the JavaScript engine cannot
    discard any of the execution contexts.
      Thus, doubling the size of an array, would double the size of the call stack
    and thus the amount of memory required to map or fold that array.
*** Tail-call Optimization
    A tail call occurs when a function's last act is to invoke another function,
    and then return whatever the other function returns. This permits the engine to
    throw away the prior execution context as it recurrs. Thus, if a function makes
    a call in tail position, JavaScript optimizes away the function call overhead
    and stack space.
**** Example sans TCO:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
  const length = ([first, ...rest]) => 
    first === undefined
      ? 0
      : 1 + length(rest);

#+END_SRC

**** Example w/ TCO:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
  const lengthTCO = ([first, ...rest], counter) => 
    first === undefined
      ? counter
      : length(rest, 1 + counter);

#+END_SRC
        
*** Converting to TCO
    The examples show that a tail-call optimized recursive process passes 
    every expression needed to complete the process into each recursive call. Thus
    the function signature must accept parameters to facilitate this hand-off 
    from one execution context to the next. But, once we modify our function
    signature, our initial call must be aware that we are invoking a TCO process,
    and supply a starting point for the process.
      For our length example, the "counter" parameter should begin at 0. But, we
    can use partial application to avoid having to remember to call lengthTCO
    with a 0 each time.
**** Length Example:
    
#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"


  const lengthTCO = ([first, ...rest], counter) => 
    first === undefined
      ? counter
      : lengthTCO(rest, 1 + counter);

  const callLast = (fn, ...args) =>
    (...moarArgs) =>
      fn(...moarArgs, ...args);

  const length = callLast(lengthTCO, 0);

  console.log(length(['how', 'now', 'brown', 'cow']));

#+END_SRC

#+RESULTS:
: 4
: undefined

**** Factorial Example

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"


  const factorialTCO = (num, product) => 
    num === 1
      ? product
      : factorialTCO(num - 1, num * product);

  const callLast = (fn, ...args) =>
    (...moarArgs) =>
      fn(...moarArgs, ...args);

  const factorial = callLast(factorialTCO, 1);

  console.log(factorial(5));

#+END_SRC

#+RESULTS:
: 120
: undefined

*** Default Arguments
    We can also set default values for function parameters. Within the function
    signature, we can "assign" a value to a parameter in the event that the
    function is invoked without an argument for that parameter.  
**** Example:
     
#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const factorial = (n, work = 1) =>
    n === 1
      ? work
      : factorial(n - 1, n * work)

  console.log(factorial(5));

#+END_SRC

#+RESULTS:
: 120

**** Length and mapWith Examples:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const length = ([first, ...rest], numberToBeAdded = 0) =>
    first === undefined
      ? numberToBeAdded
      : length(rest, 1 + numberToBeAdded)
 
  console.log(length(["foo", "bar", "baz"]));

  const mapWith = (fn, [first, ...rest], prepend = []) =>
    first === undefined
      ? prepend
      : mapWith(fn, rest, [...prepend, fn(first)]);

  console.log(mapWith((x) => x * x, [1, 2, 3, 4, 5]));

#+END_SRC

#+RESULTS:
: 3
: [ 1, 4, 9, 16, 25 ]

*** Defaults and Destructuring
    We saw that destructuring parameters works the same was as destructuring
    assignment. Now we learn that we can create a default parameter argument. We
    can also create a default destructuring assignment!
**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const [first, second = "two"] = ["one"];
  console.log(`${first} . ${second}`);

  const [third, fourth = "two"] = ["primus", "secundus"]; 
  console.log(`${third} . ${fourth}`);

#+END_SRC

#+RESULTS:
: one . two
: primus . secundus


** Garbage, Garbage Everywhere
*** Waste
    Our latest mapWith implementation is much improved. Using tail-call
    optimization, mapWith executes in constant space, saving memory.
      But, our implementation is still relatively slow for another reason: Each
    time our process recurrs, it creates a new array [...prepend, fn(first)], and 
    passes that array into mapWith. Once done, the arrays created from the last 
    execution context cease to matter, and are "garbage collected."
      This is wasteful, because each of these temporary arrays takes time to
    create, and is eventually discarded. So why implement recursion in this way?
*** LISP's Lists, a history lesson
    Lisp was first implemented on the IBM 704, a computer that had a 36-bit word,
    meaning that it was very fast to store and retrieve 36-bit values. The CPU's
    instruction set featured two important macros: CAR would fetch 15 bits
    representing the Contents of the Address part of the Register, while CDR would
    fetch the contents of the Decrement Part of the Register. 
      In broad terms, this means that a single 36-bit word could store two
    separate 15-bit values and and it was very fast to save and retrieve pairs of
    values. If you had two 15-bit values and wished to write them to the register,
    the CONS macro would take the values and write them to a 36-bit word.
      Thus, Cons put two values together, CAR extracted one, and CDR extracted the
    other. Lisp's basic data type is often said to be the list, but in actuality it
    was the CONS cell, the term used to describe two 15-bit values stored in one
    word. The 15-bit values were used as pointers that could refer to a location in
    memory, so in effect, a cons cell was a little data structure with two pointers
    to other cons cells.
      Lists were represented as linked lists of cons cells, with each cell's head
    pointing to an element and the tail pointing to another cons cell. Retrieval of 
    the CAR and CDR were fast because those macros were baked into the hardware.
*** Linked Lists in JavaScript
    In JavaScript we can emulate the semantics of CONS, CAR, and CDR:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
  const cons = (a, d) => [a, d];
  const car =([a,d])=>a;
  const cdr =([a,d])=>d;

  const oneToFive = cons(1, cons(2, cons(3, cons(4, cons(5, null)))));

#+END_SRC

    Although JavaScript would display out list as a series of nested arrays, because 
    array's are reference types, oneToFive is more accutarely represented as:
  
#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
  const node5 = [5, null],
        node4 = [4, node5],
        node3 = [3, node4],
        node2 = [2, node3],
        node1 = [1, node2];

  const oneToFive = node1;

#+END_SRC

    Our implementation is much faster at getting all of the elements except for
    the head of a linked list than it would be if we were using an array. Getting
    one reference to a structure that already exists is faster than copying a bunch
    of elements. 
      So, when we gather or spread arrays during our recursions - using
    [first, ...rest] - we're doing something laborious and memory-inefficient
    compared to using a linked list.

*** Arrays, what are they good for?
    If arrays are so slow, why does JavaScript sport them out of the box? Arrays
    are relatively slow when it comes to CAR and CDR, but much faster at other
    operations, like:
      1. Iteration over the list
      2. Retrieving data by index
      3. Changing elements in place


** Plain Old JavaScript Objects
*** Dictionaries
    Lists were performant because they closely mapped hardware, but they're not
    particularly user friendly. How is one to remember what data is stored where?
      Dictionaries evolved out of a need to name the data stored in lists. 
    Dictionaries store key-value pairs, but the underlying implementation could
    be a hashed colletion, a tree of some sort, or something else. JavaScript calls
    its dictionaries "objects."
      In JavaScript an object is a map from string keys to values.
*** Object Literals
**** Syntax: { key: 'value', anotherKey: 'anotherValue' }
**** Like arrays, objects are reference types
**** Value access with bracket notation or dot notation if the name conforms 
**** Expressions can be used for keys when enclosed in square brackets
**** Keys can store any value: functions, arrays, other objects, etc.
*** Three different ways to store functions:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

  const combinator = {
    idiotBird : function (x) {
      return x;
    },
    kestrel : function kestrel (x) {
      return (y) => (x);
    },
    blackBird (a, b) {
     return (c) => a(b(c));
    }
  }

  var bigBird = combinator.blackBird(combinator.kestrel, combinator.idiotBird)(3);

  console.log(bigBird());

#+END_SRC

#+RESULTS:
: 3
: undefined

*** Destructuring Objects
**** Literal Destructuring:
     
#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

  const knight = {
    name: {
      first: 'Matthew',
      last: 'Hoselton'
    },
    quest: 'to seek the Y combinator',
    color: 'blue'
  }

  const {name: {first: given, last: surname}, quest, color} = user;

  console.log(given + ' ' + surname);

#+END_SRC

#+RESULTS:
: Matthew Hoselton
: undefined

**** Destructuring Parameters:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

  const knight = {
    name: {
      first: 'Matthew',
      last: 'Hoselton'
    },
    quest: 'to seek the Y combinator',
    color: 'blue'
  }

  const description = ({name: {first: given, last: surname}, quest, color}) =>
   `Sir ${surname} is on a quest ${quest}`

  console.log(description(knight));

#+END_SRC

#+RESULTS:
: Sir Hoselton is on a quest to seek the y combinator
: undefined

**** Sugar (for when the object key is a valid variable name):

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

  const knight = {
    name: {
      first: 'Matthew',
      last: 'Hoselton'
    },
    quest: 'to seek the Y combinator',
    color: 'blue'
  }

  const description = ({name: {first, last}, quest, color}) =>
   `Sir ${last} is on a quest ${quest}`

  console.log(description(knight));

#+END_SRC

#+RESULTS:
: Sir Hoselton is on a quest to seek the Y combinator
: undefined

*** Linked Lists Revisited
**** Object Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const EMPTY = {};
  const oneTwoThree = { first: 1, 
                        rest: { 
                          first: 2,
                          rest: { 
                            first: 3, 
                            rest: EMPTY  
                          }
                        }
                      };

  console.log(oneTwoThree.first);
  console.log(oneTwoThree.rest);

#+END_SRC

#+RESULTS:
: 1
: { first: 2, rest: { first: 3, rest: {} } }

**** Length Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const EMPTY = {};
  const oneTwoThree = {first: 1, rest: {first: 2, rest: {first: 3, rest: EMPTY}}};

  const length = (node, counter = 0) =>
    node === EMPTY
      ? counter
      : length(node.rest, counter + 1)

  console.log(length(oneTwoThree));

#+END_SRC

#+RESULTS:
: 3

**** Slow Copy Example:
     
#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const EMPTY = {};
  const oneTwoThree = {first: 1, rest: {first: 2, rest: {first: 3, rest: EMPTY}}};

  const slowcopy = (node) => 
    node === EMPTY
      ? EMPTY
      : { first: node.first, rest: slowcopy(node.rest)};

  console.log(slowcopy(oneTwoThree));

#+END_SRC

#+RESULTS:
: { first: 1, rest: { first: 2, rest: { first: 3, rest: {} } } }

**** Reverse Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const EMPTY = {};
  const oneTwoThree = {first: 1, rest: {first: 2, rest: {first: 3, rest: EMPTY}}};

  const reverse = (node, delayed = EMPTY) => 
    node === EMPTY
      ? delayed
      : reverse(node.rest, {first: node.first, rest: delayed});

  console.log(reverse(oneTwoThree));

#+END_SRC

#+RESULTS:
: { first: 3, rest: { first: 2, rest: { first: 1, rest: {} } } }

**** reverseMap Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const EMPTY = {};
  const oneTwoThree = {first: 1, rest: {first: 2, rest: {first: 3, rest: EMPTY}}};

  const reverseMap = (fn, node, delayed = EMPTY) => 
    node === EMPTY
      ? delayed
      : reverseMap(fn, node.rest, {first: fn(node.first), rest: delayed});

  console.log(reverseMap((x) => x * x, oneTwoThree));

#+END_SRC

#+RESULTS:
: { first: 9, rest: { first: 4, rest: { first: 1, rest: {} } } }

**** Map Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const EMPTY = {};
  const oneTwoThree = {first: 1, rest: {first: 2, rest: {first: 3, rest: EMPTY}}};

  const reverse = (node, delayed = EMPTY) => 
    node === EMPTY
      ? delayed
      : reverse(node.rest, {first: node.first, rest: delayed});

  const map = (fn, node, delayed = EMPTY) => 
    node === EMPTY
      ? reverse(delayed)
      : map(fn, node.rest, {first: fn(node.first), rest: delayed});

  console.log(map((x) => x * x, oneTwoThree));

#+END_SRC

#+RESULTS:
: { first: 1, rest: { first: 4, rest: { first: 9, rest: {} } } }

**** Discussion:
     Our object based map function takes twice as long as straight iteration,
     because it iterates over the entire list twice: once to map and once to
     reverse the list. Likewise, it takes twice as much memory, because it
     constructs a reverse of the desired result before throwing it away.
       This is still much, much faster than making partial copies of arrays.  For a
     list of length n, we created n superfluous nodes and copied n superfluous
     values. Whereas out naive array algorithm created 2n superflous arrays and
     copied n^2 superfluous values.


** Mutation
   In JavaScript, almost every type of value can mutate: their binding stays the
   same, but their structure changes. For now, we'll focus on mutations with arrays
   and objects. 
     Just as you can access a value from within an array or object using bracket
   or dot notation, you can reassign a value using the same.
     Remember that we can assign two different bindings to the same value. For
   reference types, like objects, there is only ever one value. Each binding is
   merely an alias.
     JavaScript permits the reassignment of new values to existing bindings, as
   well as the reassignment and assignment of new values to elements of container
   such as arrays and objects. Mutating existing objects has special implications
   when two bindings are aliases of the same value.
     Note well that devlaring a variable const does not prevent us from mutating
   its value, only from rebinding its name. 
*** Mutation Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

  const allHallowsEve = [2012, 10, 31];
  (function (halloween) {
    halloween[0] = 2013;
  })(allHallowsEve);

  console.log(allHallowsEve);

#+END_SRC

#+RESULTS:
| 2013 | 10 | 31 |

*** moar simple mutation example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

  const allHallowsEve = [2012, 10, 31];
  const halloween = allHallowsEve;
  halloween[0] = 2013;
  console.log(allHallowsEve);

#+END_SRC

#+RESULTS:
| 2013 | 10 | 31 |

*** Mutation and Data Structures
    Generally, mutation makes some algorithms shorter to write and possibly
    faster, by conserving space. But mutation often makes a process harder to 
    reason about, as we then have to consider whether the mutations will cause
    unwanted side effects.
*** Building with Mutation
    One pattern many people follow is to be liberal with mutation when 
    constructing data, but conservative with mutation when consuming data.
      If we want to make a copy of a linked list without iterating over it twice
    and making a copy that will be gc'd later, we can use mutation. The following
    algorithm makes copies of nodes as it goes, and mutates the last node in the
    list so that it can splice the next one on.
**** Copy Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

  const copy = (node, head = null, tail = null) => {
    if (node === EMPTY) {
      return head; 
    } else if (tail === null) {
      const { first, rest } = node;
      const newNode = { first, rest };
      return copy(rest, newNode, newNode);
    } else {
      const { first, rest } = node;
      const newNode = { first, rest }; tail.rest = newNode;
      return copy(node.rest, head, newNode);
    }
  }

#+END_SRC

**** Map Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

const EMPTY = {};
const OneToFive = {first: 1,
                   rest: {
                     first: 2,
                     rest: {
                       first: 3,
                       rest: {
                         first: 4,
                         rest: {
                           first: 5,
                           rest: EMPTY }}}}};

  const mapWith = (fn, node, head = null, tail = null) => {
    if (node === EMPTY) {
      return head; 
    } else if (tail === null) {
      const { first, rest } = node;
      const newNode = { first: fn(first), rest };
      return mapWith(fn, rest, newNode, newNode);
    } else {
      const { first, rest } = node;
      const newNode = { first: fn(first), rest };
      tail.rest = newNode;
      return mapWith(fn, node.rest, head, newNode);
    }
  }

console.log(mapWith((x) => 1.0 / x, OneToFive));

#+END_SRC

#+RESULTS:
: { first: 1,
:   rest: 
:    { first: 0.5,
:      rest: { first: 0.3333333333333333, rest: [Object] } } }
: undefined


** Reassignment
   JavaScript does not permit us to rebind a name that has been bound with const.
   But, we can shadow it by using const to declare a new binding with a new
   function or block scope. And, we can rebind parameters bound in a function or
   with the let keyword.
*** let
    Like const, let names can be shadowed by bindings in local environments.
    Unlike const, let bindings can be rebound, assigned a different value in the
    same environment.
*** var
    JavaScript has one more way to bind a name to a value: var. Var is a lot like
    let, it can be reassigned. But instead of scoping to containing blocks, var 
    scopes to containing functions. 
      All var declarations are hoisted to the top of the function, a little like
    function declarations. But, remember that assignments are not hoisted, creating
    a temporal zone in which the name-binding exists but it's value is undefined.
*** why const and let were invented
    const and let first appeared in ES6. var's function scope caused confusion for
    those who didn't understand lexical scope. 
**** see YDKJS discussion of let and var in for loops


** Copy on Write


** Tortises, Hares, and Teleporting Turtles


** Functional Iterators


** Making Data Out Of Functions
