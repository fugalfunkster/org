Javascript Allonge Notepad

* Readme: An Aside: Welcome to fugalfunkster's notebook

** Org-Mode and Literate Programming

*** http://howardism.org/Technical/Emacs/literate-programming-tutorial.html

*** Not all code will appear in a block
** Terminology

*** cf : compare

** Org-Babel

** ES6 code blocks

*** node npm babel
*** http://rwx.io/blog/2015/10/06/org-with-babel-node/

*** In this doc, code blocks will be labeled as "Ex:" with their own bullet to expand
*** Note that many of these code blocks begin with return when the result isn't 
*** logges to stdout (in this case, console.log)
**** this is required to recieve the return value of an expression 
**** because org-babel executes the code-block within a function wrapper

** Properties
*** Here's the doc-wide tangle property if you wish to modify it:
**** note, this property tag must be registered with the point over the code
**** and a lil C-c C-c
***  Getting the result
**** :results output
*** using babel
**** :cmd "org-babel-node --presets es2015"
*** Do the tangle
**** What is tangling?
***** http://orgmode.org/manual/Extracting-source-code.
**** It takes "C-c C-v t" to tangle
**** Select code blocks in this document will to tangle out to recipes.js
***** but only for those blocks with the property :tangle yes

 
* Prelude: Values and Expressions over Coffee

** values are expressions
*** but not all expressions are values
*** when an expression includes an operator, it is not a value
** values and identity
*** we test whether two values are identical with === and !== 
** value types
*** primitives can be identical
*** 123 === 123 >> true
** reference types
*** reference types are always unique
*** [1,2,3]===[1,2,3] >> false


* A Rich Aroma: Basic Numbers

** literal: notation for representing a fixed value in source code
*** nums are double-precision floating point 
*** binary is base 2, some fractions base 10
*** do not have exact representations base 2
*** this is problematic, in monetary calculations for example
** operations on numbers
*** +, -, *, /, %, -:


* The First Sip: Basic Functions
 
** As little as possible about Functions
*** functions are values that represent computations to be performed

***** Ex:
  #+BEGIN_SRC js
    return () => 0
  #+END_SRC

  #+RESULTS:
  | Function |

**** We use functions by applying them to arguments (0 or more values)

***** Ex:
  #+BEGIN_SRC js
    return (() => 0 )()
  #+END_SRC

  #+RESULTS:
  : 0

**** functions return values (including other functions)
**** functions evaluate expressions
*** blocks
**** blocks contain zero or more statements, separated by semicolons
**** a block containg no statements evaluates to undefined
*** undefined, the absence of value - another primitive value
**** void is an operator that takes any value
**** and always evaluates to undefined
**** idiomatically: void 0 >> undefined
*** statements
**** all expressions are statements - but some return undefined when applied

***** Ex:
 #+BEGIN_SRC js
   return () => {2 + 2}
 #+END_SRC

 #+RESULTS:
 | Function |

***** cf Ex: 
#+BEGIN_SRC js
  return (() => {2+2})()
#+END_SRC

#+RESULTS:
: undefined

**** not all statements are expressions
*** the return keyword
**** allows us to return a value from a function,
**** when that function evaluates a block
**** return immediately terminates the function application and 
**** returns the result of evaluating its expression

***** Ex:
 #+BEGIN_SRC js
  return (() => { return 2+2; })()  
 #+END_SRC

 #+RESULTS:
 : 4

*** functions are reference types


** Ah. I'd like to Have an Argument, Please.
*** a quick summary of functions and bodies
**** Expressions consist either of representations of values,
**** operators that combine expressions, and special forms
**** like object/array/function literal notation
**** A return statement accepts any valid JS expression
*** I. - Call by value
**** javascript will evaluate all expressions applied to a function
**** then applies the function to the resulting value(s)
*** variables, bindings, and environment
**** Every time a function is invoked, a new environment is created
**** each environment maps variable names to argument values
**** like a dictionary {x: 2}

***** Ex:
#+BEGIN_SRC js
  ((x) => x)(2)
#+END_SRC

#+RESULTS:
: undefined

**** recall YDKJS discussion of scope/environments/etc...
*** II - Call by sharing
**** when js binds a value-type to a name it makes a copy of the value
**** when js binds a reference-type to a name, it uses a reference


** Closures and Scope
*** Free Variables - those not bound within the function
**** bound with a var/let/const or via an argument
**** Functions containing no free variables are called pure functions
***** But a pure function can contain a closure

***** Ex:
#+BEGIN_SRC js
  return ((x) => (y) => x)(1)(2)
#+END_SRC

#+RESULTS:
: 1

**** Functions containing one or more free variables are called closures
***** closures cannot contain pure functions, because free variables
***** remain accessable to inner functions
*** Intro to Combinators!
**** the I Combinator (aka the Identity Function)
***** (x) => x
**** the K Combinator (aka Kestrel)
***** (x) => (y) => x
*** shadowing - local scope shadows parent scope
*** the global environment
**** many programmers enclose each javascript file within a function expression
***** (() => { . . . })();


** That Constant Coffee Craving
*** Immediately Invoked Function Expressions
**** We can bind any value we want for an expression by wrapping the expression
**** in a function and subsequently invoking the function with our value

***** ex: 
#+BEGIN_SRC js
  return ((pi) => (diameter) => diameter * pi)(3.14)(10)
#+END_SRC

#+RESULTS:
: 31.400000000000002

**** inside-out

***** Ex:
#+BEGIN_SRC js
  return ((diameter) => ((pi) => diameter * pi)(3.14))(10)
#+END_SRC

#+RESULTS:
: 31.400000000000002

**** invoking functions is considerably more expensive than evaluating functions
***** every time we invoke the outer function, we'll invoke the inner function
*** const - can bind any expression (including functions)
**** the const keyword introduces one or more bindings in its enclosing block
***** const statements must occur inside blocks,
***** we can't use them when we write a fat arrow that has an expression as its body
**** naming functions is elegant when functions are expressions
**** const can affect multiple bindings using commas
*** nested blocks - not just for functions
**** other kinds of blocks
***** if statements are not expressions, its clauses are statements or blocks
***** const scopes to these blocks too!
*** const obeys lexical scope
**** blocks delineate const-binding's environment
**** const shadows just like parameter/argument bindings
*** Bind names as close to where we need them as possible
**** this design rule is called the Principle of Least Priviledge
**** it has both quality and security implications
*** rebinding - not with const
**** although we can rebind named parameters/arguments to a different value
**** javascript does not permit us to rebind const-s


** Naming Functions
*** the function keyword
**** can have a name! - and should for code clarity and debugging
***** confusingly, we could still bind the named functions with const
***** this would result in a binding in the enclosing environment
***** but the function would retain its given name
***** so we would have created a named function expression
****** the name of the function is a property of the function 
**** the body must be a block
**** thus we must use the return keyword to return a value from the block
**** Note on named function expressions 
***** the function name is not available in the enclosing scope
***** but the function name is available within the body of the function
***** preserves recursion without resorting to shenanegans
*** function declarations
**** a statement instead of an expression
**** the function's name becomes bound in the environment
**** note, function declarations are hoisted
*** function declarations should not occur within other blocks or expressions
**** of course, functions declarations often do occur inside other function blocks
**** see for example, the note on the global environment in Closures and Scope


** Combinators and Function Decorators
*** higher order functions
**** any function that takes a function as argument, returns functions, or both
*** combinators
**** Technical Definition
***** "A combinator is a higher-order function that uses only function application
***** and earlier defined combinators to define a result from its arguments"
**** Looser definition
***** higher-order pure functions that take only functions as arguments
***** and return a function
**** the B combinator (aka Blackbird)
***** const compose = (a, b) => (c) => a(b(c))
**** combinators are useful for reasoning about what you're doing and how (verbs)
**** be more explicit when reasoning about what you're working with (nouns)
*** function decorators
**** definition
***** a higher-order function that takes one function as an argument,
***** and returns a function (a variation of the argument function)
**** function decorators need not be pure

     
** Building Blocks
*** composition
**** Ex: const cookAndEat = (food) => eat(cook(food));
**** the trick is to organize your code so you can compose functions
*** partial application
**** When a function takes multiple arguments, we need not apply all arguments
***** if we can return a function with arguments pre-supplied
**** orthogonal (involving right angles) to composition


** Magic Names
*** this
**** bound to the function's context (dynamic)
*** arguments
**** an array like object that contains all of the arguments passed to a function
**** we'll use it to build functions that can take a variable number of arguments
*** on fat arrows
**** this and arguments take on the binding from the enclosing scope!
*** Function Design Principles
**** If you call a function more than once, give it a name and first-class status
**** If the function only represents an expression to be computed, use fat arrows
**** The distinction helps sort out the syntatic differences re: magic words
     

** Summary
*** Functions are values that can be part of expressions, returned from other functions
*** Functions are reference values
*** Functions are applied to arguments
*** The arguments are passed by sharing, which is also called pass by value
*** Fat arrow functions have expressions or blocks as their bodies
*** function keyword functions always have blocks as their bodies
*** Function bodies have zero or more statements
*** Expression bodies evaluate to the value of the expression
*** Block bodies evaluate to whatever is returned with the return keyword, else undefined
*** JS uses const to bind values to names within block scope
*** JS uses function declarations to bind functions to names within function scope
*** Function declarations are hoisted
*** Function application creates an environment, with scope
*** Blocks also create scopes if const statements exist within
*** Scopes are nested and free variable references closed over
*** Variables can shadow variables in an enclosing scope


* Recipies with Basic Functions

** Partial Application
*** Recipe: 

#+BEGIN_SRC js :tangle yes
const callFirst = (fn, larg) =>
  function (rest) {
  return fn.call(this, larg, rest);
};

const callLast = (fn, rarg) =>
  function (rest) {
  return fn.call(this, rest, rarg);
};
#+END_SRC

*** TODO let author know that ...rest as a function param causes error
*** Example:

#+BEGIN_SRC js
const callFirst = (fn, larg) =>
  function (rest) {
  return fn.call(this, larg, rest);
};

const greet = (me, you) =>
  `Hello, ${you}, my name is ${me}`;
 
const heliosSaysHello = callFirst(greet, 'Helios');

console.log(heliosSaysHello('Celine'));

#+END_SRC

#+RESULTS:
: Hello, Celine, my name is Helios
: undefined

*** note that an application of callLast could be named sayHelloToCeline
*** Gathering and Spreading allow partial application for many args
*** TODO Recipe:

#+BEGIN_SRC js tangle: yes
 const callLeft = (fn, args) =>
  (remainingArgs) =>
    fn(args, remainingArgs);

 const callRight = (fn, args) =>
  (remainingArgs) =>
    fn(remainingArgs, args);

#+END_SRC

#+RESULTS:
: undefined

*** play with these examples in the repl
*** design a function with three arguments and partially apply them
*** try a function with four arguments


** Unary
*** Definition
**** A function decorator that modfies a function so that it takes only one argument
*** Recipe:

#+BEGIN_SRC js :tangle yes
const unary = (fn) =>
   fn.length === 1
     ? fn
     : function (something) {
         return fn.call(this, something);
};
#+END_SRC

#+RESULTS:
: undefined

*** Example:

#+BEGIN_SRC js
const unary = (fn) =>
   fn.length === 1
     ? fn
     : function (something) {
         return fn.call(this, something);
};
console.log(['1', '2', '3'].map(unary(parseInt)));
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 |

*** Note that the unary operator is necessary above because parseInt is defined
*** as parseInt(string[, radix]). parseInt takes an optional radix argument. 
*** And when you call parseInt with map, the index (an argument of map) is 
*** interpreted as a radix.


** Tap

*** the K combinator (Kestrel)
**** const K = (x) => (y) => x;
*** Recipe:

#+BEGIN_SRC js
const tap = (value) =>
 (fn) => (
   typeof(fn) === 'function' && fn(value),
     value
   );
#+END_SRC

#+RESULTS:
: undefined

*** Description:
**** tap takes a value and returns a function that always returns the value
**** but, if you pass it a function, it executes the function (using the value 
**** as an argument) for side-effects
*** Application Example:

#+BEGIN_SRC js
const tap = (value) =>
 (fn) => (
   typeof(fn) === 'function' && fn(value),
     value
   );

tap('espresso')(it => {
  console.log(`Our drink is '${it}'`);
});
#+END_SRC

#+RESULTS:
: Out drink is 'espresso'
: undefined

*** Recipe: w/o 'currying'

#+BEGIN_SRC js
const tap = (value, fn) => {
   typeof(fn) === 'function' && fn(value),
   value
};
#+END_SRC

#+RESULTS:
: undefined
 
*** Recipe: (currying optional)

#+BEGIN_SRC js :tangle yes
const tap = (value, fn) => {
  const curried = (fn) => (
    typeof(fn) === 'function' && fn(value),
    value
  );
 
  return fn === 'undefined'
    ? curried
    : curried(fn);
};
#+END_SRC

#+RESULTS:
: undefined

*** a poor mans debugger, and useful for working with object and instance methods


** Maybe
*** sometimes you want to vet a value before you pass it to a function
**** in JS you might: value !== null && value !== void 0
**** to ensure that the value is not null or undefined
**** naturally there's a function decorator for that
*** Recipe:

#+BEGIN_SRC js :tangle yes
'use strict'
const maybe = (fun) =>
  function (args) {
    if (args.length === 0) {
      return
    } else {
      for (let arg of args) {
        if (arg == null) return;
      }
    return fn.apply(this, args)
    }
};
#+END_SRC

#+RESULTS:
: undefined

*** note: plays nicely with instance methods (foreshadowing)


** Once
*** Ensures that a function can only be called once
*** Recipe:

#+BEGIN_SRC js :tangle yes
'use strict'
const once = (fn) => {
  let done = false;
 
  return function () {
    return done ? void 0 : ((done = true), fn.apply(this, arguments))
  }
};
#+END_SRC

*** Example:

#+BEGIN_SRC js
'use strict'
const once = (fn) => {
  let done = false;
 
  return function () {
    return done ? void 0 : ((done = true), fn.apply(this, arguments))
  }
};

const askedOnABlindDate = once(
  () => 'sure'
);

console.log(askedOnABlindDate());
console.log(askedOnABlindDate());
console.log(askedOnABlindDate());
console.log(askedOnABlindDate());

#+END_SRC

#+RESULTS:
: sure
: undefined
: undefined
: undefined
: undefined

*** there's a closure here, to manage the internal state of 'done'
*** see stateful method decorators... (foreshadowing)


** Left-Variadic Functions
*** Variadic functions accept a variable number of arguments.
**** JS now lets you do this when using rest parameters. Ex: (x, y, ...z)
**** This may be useful for certian kinds of destructuring algorithms
**** But JS only permits gathering parameters from the end of the parameter list
***** AKA: Right Variadic Functions
*** Left Variadic Functions require some fussing
**** thankfully, the rest parameter is (acts like?) a proper array
**** so we can grab all argument with the rest parameter, and slice them up to 
**** grab the right-most arguments, and bundle the rest
*** Recipe:

#+BEGIN_SRC js :tangle yes
const leftVariadic = (fn) => {
  if (fn.length < 1) {
    return fn;
  } else {
    return function (args) {
      const gathered = args.slice(0, args.length - fn.length + 1), spread = args.slice(args.length - fn.length + 1);
      return fn.apply(
        this, [gathered].concat(spread)
      ); }
    } 
};

#+END_SRC

#+RESULTS:
: undefined

*** Example:
    
#+BEGIN_SRC js
const leftVariadic = (fn) => {
  if (fn.length < 1) {
    return fn;
  } else {
    return function (args) {
      const gathered = args.slice(0, args.length - fn.length + 1), spread = args.slice(args.length - fn.length + 1);
      return fn.apply(
        this, [gathered].concat(spread)
      ); }
    } 
};

const butLastAndLast = leftVariadic((butLast, last) => [butLast, last]);
console.log(butLastAndLast(['why', 'hello', 'there', 'little', 'droid']));
#+END_SRC

#+RESULTS:
| (why hello there little) | droid |

*** TODO wierd error with ...args, and argument to butLastAndLAst should be an array
*** Destructuring
**** Javascript can now destructure arrays when assigning variables 
**** Recipe:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
'use strict'
const [first, ...butFirst] = ['why', 'hello', 'there', 'little', 'droid'];
console.log(butFirst);
console.log(first); 
#+END_SRC

#+RESULTS:
: [ 'hello', 'there', 'little', 'droid' ]
: why

**** Note again, this is right variadic destructuring
*** leftGather
**** We can use the rest parameter, and Array#slice to make our own leftGather function
**** we have to supply the length of the array into which we will destructure
**** so that excess arguments can be collected in the left parameter
**** Recipe:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :tangle yes
const leftGather = (outputArrayLength) => { 
  return function (inputArray) {
    return [inputArray.slice(0, 
            inputArray.length - outputArrayLength + 1)]
           .concat(
             inputArray.slice(inputArray.length - outputArrayLength + 1)
           )
    } 
};
#+END_SRC

**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
const leftGather = (outputArrayLength) => { 
  return function (inputArray) {
    return [inputArray.slice(0, 
            inputArray.length - outputArrayLength + 1)]
           .concat(
             inputArray.slice(inputArray.length - outputArrayLength + 1)
           )
    } 
};

const [butLast, last] = leftGather(2)(['why', 'hello', 'there', 'little', 'droid']);
console.log(butLast);
console.log(last);

#+END_SRC  

#+RESULTS:
: [ 'why', 'hello', 'there', 'little' ]
: droid

     
** Compose and Pipeline
*** The B Combinator (again)
*** Recipe:

#+BEGIN_SRC js :tangle yes
  const compose = (a, b) =>
  (c) => a(b(c))
#+END_SRC

*** Example:
 
#+BEGIN_SRC js
  const compose = (a, b) =>
    (c) => a(b(c))

  const addOne = (number) => number + 1;
  const doubleOf = (number) => number * 2;
  const doubleOfAddOne = compose(doubleOf, addOne);

  console.log(doubleOfAddOne(3));

#+END_SRC

#+RESULTS:
: 8
: undefined

*** Variadic compose through recursion 
**** Recipe:

 #+BEGIN_SRC js
 const compose = (a, rest) =>
   rest.length === 0
     ? a
     : (c) => a(compose(rest)(c))

 #+END_SRC

*** Semantics
**** Compose isn't necessarily helpful for compound actions that are realted,
**** like intermediate steps in a calculation.
**** But, to combine multiple, single-purpose functions, compose works nicely.
**** Thus, compost is at its best when defining a new function
**** that combines the effects of existing functions
*** Pipeline
**** Compose accepts arguments that execute from right to left,
**** ex: (doubleOf, addThree)
**** which is not the most intuitive, we have to write the function name of the 
**** first argument to reflect that it is acting on the result of the next argument
**** pipeline solves this by allowing function names that are syntatically insensitive
*** Recipe:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :tangle yes
  const pipeline = (...fns) => 
    (value) =>
      fns.reduce((acc, fn) => fn(acc), value);
#+END_SRC

*** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" 
  const pipeline = (...fns) => 
    (value) =>
      fns.reduce((acc, fn) => fn(acc), value); 

  const addOne = (number) => number + 1;
  const double = (number) => number * 2;
  const setter = pipeline(addOne, double);

console.log(setter(2));
#+END_SRC

#+RESULTS:
: 6
: undefined


* Picking the Bean: Choice and Truthiness
** Boolean
*** true and false are value types, true === true, false === false
** truthiness
*** 6 kinds of wrong
**** 0, '', NaN, undefined, null, false
*** Everything else is truthy
** "Logical" operators evaluate truthiness, not boolean values
*** ! - negation operator
**** unary prefix
**** returns false if its argument is truthy
**** returns true if its argument is falsey
***** !! is a way to convert a truthy value to the boolean true
*** && - logical and
**** binary infix
**** && evaluates its left-hand expression, and if falsey, returns that value
**** else, && evaluates and returns its right-hand expression
*** || - logical or
**** binary infix
**** || evaluates its left-hand expression, and if truthey, returns that value
**** else, || evaluates and returns its right-hand expression
*** first ? second : third  - the ternary operator
**** if the ternary's first argument is truthy,
**** it evaluates it's second argument,
**** otherwise it evaluates its third argument
**** an expression, not a statement (like if/else)
** These operators provide flow control, not pure logical operators
*** Function parameters are eagerly evaluated
**** This means that JavaScript always evaluates expressions provided as parameters
**** to a function, before passing those values into the function for invocation
**** Recall Applicative Order and Normal Order
***** See SICP and HtDP
**** If we need to roll our own control-flow semantics,
**** we must pass functions as parameters to other functions,
**** not expressions, which would be evaluated
*** Flow Control operators have "short-cut" semantics


* Composing and Decomposing Data

** Arrays and Destructuring Arguments
*** Arrays are ordered collections of elements
**** Arrays are reference types
**** Literals - [element, element, element]
***** Array literals are expressions that evaluate to an array
**** Element References
***** In JavaScript, arrays are 0 based
***** You can extract an element within an array by using bracket notation
***** Example:

#+BEGIN_SRC js
  const x = [], a = [x];
  console.log(a[0] === x);

#+END_SRC

#+RESULTS:
: true
: undefined

***** As the previous example demonstrates, 
***** arrays relate to their elements by reference
*** Destructuring Arrays
**** New ES6 Syntax
***** In addition to bracket notation, we can extract elements of an array
***** by destructuring the array.
***** Destructuring an array mirrors array declaration.
***** On the left side of an assignment,
***** we have brackers surrounding the name binding(s)
***** And on the right, the array to destructure
**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
// declare
  const container = ['goodies'];
// destructure
  const unwrap = (wrapped) => { 
    const [something] = wrapped;
    return something; 
  }
  console.log(unwrap(container));

#+END_SRC

#+RESULTS:
: goodies
: undefined

*** Gathering and Spreading
**** Gathering (extracting an array from an array)
***** We can also extract arrays from an array, for example extracting the head
***** and the remaining elements of the array (the "rest")
****** Recall our right and left variadiac functions
**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const [car, ...cdr] = [1, 2, 3, 4, 5];
  console.log(car);
  console.log(cdr);
#+END_SRC

#+RESULTS:
: 1
: [ 2, 3, 4, 5 ]
**** Spreading (assembling an array with an array)
**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
  const oneTwoThree = ['one', 'two', 'three'];
  console.log(['zero', ...oneTwoThree]);

#+END_SRC

#+RESULTS:
| zero | one | two | three |

*** Application
**** Destructuring is not Pattern Matching
***** When destructuring, the sides of the assignment operator should align
***** In other programming languages, a mismatched destructuring attempt will err
***** JavaScript, however, simply assigns undefined when destructuring fails
***** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
  const [thistle, that, theOther] = ['duck feet', 'tiger tail'];
  console.log(theOther);

  const [...what] = [];
  console.log(what);

#+END_SRC

#+RESULTS:
: undefined
: []
: undefined

**** Destructuring and Return Values
***** Some languages support multiple return values, ie: a function can return
***** several things at once, like a value and an error code. We can emulate that
***** with destructuring
***** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const description = (nameAndOccupation) => { 
    if (nameAndOccupation.length < 2) {
      return ["", "occupation missing"] 
    } else {
      const [[first, last], occupation] = nameAndOccupation;
      return [`${first} is a ${occupation}`, "ok"];
    }
  }

  const [reg, status] = description([["Reginald", "Braithwaite"], "programmer"]);

  console.log(reg);
  console.log(status);
#+END_SRC

#+RESULTS:
: Reginald is a programmer
: ok

**** Destructuring parameters
***** Consider that the parameters to a function are also a collection of elements
***** We can destructure those too! permitting us to create functions that accept
***** a variable number of arguments
***** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
 const theWholeShebang = (car, ...cdr) => [car, cdr];
 console.log(theWholeShebang('why', 'hello', 'there', 'little', 'droid'));

#+END_SRC

#+RESULTS:
: [ 'why', [ 'hello', 'there', 'little', 'droid' ] ]


** Self-Similarity
*** What is a list?
    Lists are a collection composed of zero or more elements.
      In the previous chapter, we created arrays through literal declaration
    and then destructured arrays into their constituent elements. These two
    operations are opposites.
      We can also define a list in terms of rules, that - if followed - 
    create a list. Traditionally, there are two rules that define a list. A list is
    either:
      1. Empty
      2. Consists of an element concatenated with a list
    Thus, [] is a list. So is ["baz", []]. 
*** A process to determing whether a value is an empty list:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const isEmpty = ([first, ...rest]) => first === undefined; 

  console.log(isEmpty([]));
  console.log(isEmpty([0]));
  console.log(isEmpty([[]]));

#+END_SRC

#+RESULTS:
: true
: false
: false

*** A recursive process to determine the length of an array

 #+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

   const length = ([first, ...rest]) =>
     first === undefined 
       ? 0
       : 1 + length(rest);

   console.log(length([]));
   console.log(length([1,2,3]));

 #+END_SRC

 #+RESULTS:
 : 0
 : 3
*** Recursion
    Our length function is recursive, it calls itself. This makes sense because
    our definition of a list is recursive, and if a list is self-similar, it is
    natural to create an algorithm that is also self similar.
      Recursive algorithms follow the "divide and conquer" strategy:
    1. Divide the problem into smaller problems
    2. If a smaller problem is solvable, solve the small problem
    3. If a smaller problem is not solvable, divide and conquer that problem
    4. When all problems are solved, compose the solutions   
*** Linear Recursion
    Linear recursion varies from this strategy in that it entails breaking off
    a piece of a problem, the terminal case, solving that piece and then sticking
    it onto a solution for the rest of the problem.
*** Flatten-ing

#+BEGIN_SRC  js :cmd "org-babel-node --presets es2015" :results output

  const flatten = ([first, ...rest]) => {
    if (first === undefined) {
      return [];
    } else if (!Array.isArray(first)) {
      return [first, ...flatten(rest)];
    } else {
      return [...flatten(first), ...flatten(rest)];
    }
}

console.log(flatten(['foo', [3, 4, []]]));

#+END_SRC

#+RESULTS:
: [ 'foo', 3, 4 ]

*** Map-ing:
    Mapping, applying a function to each element of an array, is a form of 
    linear recursion.
**** Recipe:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" 
  const mapWith = (fn, [first, ...rest]) => {
    first === undefined
      ? []
      : [fn(first), mapWith(fn, rest)];
  }

#+END_SRC
**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" 
  const mapMaker = (fn, [first, ...rest]) => 
    first === undefined ? [] : [fn(first), ...mapMaker(fn, rest)];

  console.log(mapMaker((x) => x * x, [1,2,3,4]));

#+END_SRC

#+RESULTS:

*** Fold-ing:
    With the exception of the length example earlier, all of our examples have used
    the spread operator, ... , to rebuild our solution. We might instead want to
    concatenate the values from each step of the process.
**** sumSquares Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const sumSquares = ([first, ...rest]) => 
    first === undefined 
      ? 0
      : first * first + sumSquares(rest);

  console.log(sumSquares([1,2,3]));

#+END_SRC

#+RESULTS:
: 14

**** sumSquares vs. Map
     There are two differences between sumSquares and our map example:
       1. Given the terminal case of an empty list, we return 0 instead of []
       2. We catenate the square of each element to the result of fn(rest) 
**** foldWith, a moar general mapWith:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const foldWith = (fn, terminalValue, [first, ...rest]) => 
    first === undefined
      ? terminalValue
      : fn(first, foldWith(fn, terminalValue, rest));

  console.log(foldWith((x, rest) => x * x + rest, 0, [1,2,3]));

#+END_SRC

#+RESULTS:
: 14

*** Folding is a form of linear recursion, mapping is a form of folding 
    We can represent a map as a fold, we just need to supply the array-rebuilding 
    code
**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const foldWith = (fn, terminalValue, [first, ...rest]) => 
    first === undefined
      ? terminalValue
      : fn(first, foldWith(fn, terminalValue, rest));

  const mapWith = (fn, array) => 
    foldWith((first, rest) => [fn(first), ...rest], [], array);

  const squareAll = (array) => mapWith((x) => x * x, array);

  console.log(squareAll([1,2,3,4,5]));

#+END_SRC

#+RESULTS:
: [ 1, 4, 9, 16, 25 ]

  
** Tail Calls (and Default Arguments)

** Garbage, Garbage Everywhere

** Plain Old JavaScript Objects

** Mutation

** Reassignment

** Copy on Write

** Tortises, Hares, and Teleporting Turtles

** Functional Iterators

** Making Data Out Of Functions
