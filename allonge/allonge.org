Javascript Allonge Notepad

* Readme: An Aside: Welcome to fugalfunkster's notebook

** Org-Mode and Literate Programming

*** http://howardism.org/Technical/Emacs/literate-programming-tutorial.html

*** Not all code will appear in a block
** Terminology

*** cf : compare

** Org-Babel

** ES6 code blocks

*** node npm babel
*** http://rwx.io/blog/2015/10/06/org-with-babel-node/

*** In this doc, code blocks will be labeled as "Ex:" with their own bullet to expand
*** Note that many of these code blocks begin with return when the result isn't 
*** logges to stdout (in this case, console.log)
**** this is required to recieve the return value of an expression 
**** because org-babel executes the code-block within a function wrapper
** Do the tangle

*** What is tangling?
**** http://orgmode.org/manual/Extracting-source-code.
*** It takes "C-c C-v t" to tangle
*** Select code blocks in this document will to tangle out to recipes.js
**** but only for those blocks with the property :tangle yes
*** Here's the doc-wide tangle property if you wish to modify it:
**** note, this property tag must be registered with the point over the code
**** and a lil C-c C-c

 
* Prelude: Values and Expressions over Coffee

** values are expressions
*** but not all expressions are values
*** when an expression includes an operator, it is not a value
** values and identity
*** we test whether two values are identical with === and !== 
** value types
*** primitives can be identical
*** 123 === 123 >> true
** reference types
*** reference types are always unique
*** [1,2,3]===[1,2,3] >> false


* A Rich Aroma: Basic Numbers

** literal: notation for representing a fixed value in source code
*** nums are double-precision floating point 
*** binary is base 2, some fractions base 10
*** do not have exact representations base 2
*** this is problematic, in monetary calculations for example
** operations on numbers
*** +, -, *, /, %, -:


* The first sip: Basic Functions
 
** As little as possible about Functions
*** functions are values that represent computations to be performed

***** Ex:
  #+BEGIN_SRC js
    return () => 0
  #+END_SRC

  #+RESULTS:
  | Function |

**** We use functions by applying them to arguments (0 or more values)

***** Ex:
  #+BEGIN_SRC js
    return (() => 0 )()
  #+END_SRC

  #+RESULTS:
  : 0

**** functions return values (including other functions)
**** functions evaluate expressions
*** blocks
**** blocks contain zero or more statements, separated by semicolons
**** a block containg no statements evaluates to undefined
*** undefined, the absence of value - another primitive value
**** void is an operator that takes any value
**** and always evaluates to undefined
**** idiomatically: void 0 >> undefined
*** statements
**** all expressions are statements - but some return undefined when applied

***** Ex:
 #+BEGIN_SRC js
   return () => {2 + 2}
 #+END_SRC

 #+RESULTS:
 | Function |

***** cf Ex: 
#+BEGIN_SRC js
  return (() => {2+2})()
#+END_SRC

#+RESULTS:
: undefined

**** not all statements are expressions
*** the return keyword
**** allows us to return a value from a function,
**** when that function evaluates a block
**** return immediately terminates the function application and 
**** returns the result of evaluating its expression

***** Ex:
 #+BEGIN_SRC js
  return (() => { return 2+2; })()  
 #+END_SRC

 #+RESULTS:
 : 4

*** functions are reference types


** Ah. I'd like to Have an Argument, Please.
*** a quick summary of functions and bodies
**** Expressions consist either of representations of values,
**** operators that combine expressions, and special forms
**** like object/array/function literal notation
**** A return statement accepts any valid JS expression
*** I. - Call by value
**** javascript will evaluate all expressions applied to a function
**** then applies the function to the resulting value(s)
*** variables, bindings, and environment
**** Every time a function is invoked, a new environment is created
**** each environment maps variable names to argument values
**** like a dictionary {x: 2}

***** Ex:
#+BEGIN_SRC js
  ((x) => x)(2)
#+END_SRC

#+RESULTS:
: undefined

**** recall YDKJS discussion of scope/environments/etc...
*** II - Call by sharing
**** when js binds a value-type to a name it makes a copy of the value
**** when js binds a reference-type to a name, it uses a reference


** Closures and Scope
*** Free Variables - those not bound within the function
**** bound with a var/let/const or via an argument
**** Functions containing no free variables are called pure functions
***** But a pure function can contain a closure

***** Ex:
#+BEGIN_SRC js
  return ((x) => (y) => x)(1)(2)
#+END_SRC

#+RESULTS:
: 1

**** Functions containing one or more free variables are called closures
***** closures cannot contain pure functions, because free variables
***** remain accessable to inner functions
*** Intro to Combinators!
**** the I Combinator (aka the Identity Function)
***** (x) => x
**** the K Combinator (aka Kestrel)
***** (x) => (y) => x
*** shadowing - local scope shadows parent scope
*** the global environment
**** many programmers enclose each javascript file within a function expression
***** (() => { . . . })();


** That Constant Coffee Craving
*** Immediately Invoked Function Expressions
**** We can bind any value we want for an expression by wrapping the expression
**** in a function and subsequently invoking the function with our value

***** ex: 
#+BEGIN_SRC js
  return ((pi) => (diameter) => diameter * pi)(3.14)(10)
#+END_SRC

#+RESULTS:
: 31.400000000000002

**** inside-out

***** Ex:
#+BEGIN_SRC js
  return ((diameter) => ((pi) => diameter * pi)(3.14))(10)
#+END_SRC

#+RESULTS:
: 31.400000000000002

**** invoking functions is considerably more expensive than evaluating functions
***** every time we invoke the outer function, we'll invoke the inner function
*** const - can bind any expression (including functions)
**** the const keyword introduces one or more bindings in its enclosing block
***** const statements must occur inside blocks,
***** we can't use them when we write a fat arrow that has an expression as its body
**** naming functions is elegant when functions are expressions
**** const can affect multiple bindings using commas
*** nested blocks - not just for functions
**** other kinds of blocks
***** if statements are not expressions, its clauses are statements or blocks
***** const scopes to these blocks too!
*** const obeys lexical scope
**** blocks delineate const-binding's environment
**** const shadows just like parameter/argument bindings
*** Bind names as close to where we need them as possible
**** this design rule is called the Principle of Least Priviledge
**** it has both quality and security implications
*** rebinding - not with const
**** although we can rebind named parameters/arguments to a different value
**** javascript does not permit us to rebind const-s


** Naming Functions
*** the function keyword
**** can have a name! - and should for code clarity and debugging
***** confusingly, we could still bind the named functions with const
***** this would result in a binding in the enclosing environment
***** but the function would retain its given name
***** so we would have created a named function expression
****** the name of the function is a property of the function 
**** the body must be a block
**** thus we must use the return keyword to return a value from the block
**** Note on named function expressions 
***** the function name is not available in the enclosing scope
***** but the function name is available within the body of the function
***** preserves recursion without resorting to shenanegans
*** function declarations
**** a statement instead of an expression
**** the function's name becomes bound in the environment
**** note, function declarations are hoisted
*** function declarations should not occur within other blocks or expressions
**** of course, functions declarations often do occur inside other function blocks
**** see for example, the note on the global environment in Closures and Scope


** Combinators and Function Decorators
*** higher order functions
**** any function that takes a function as argument, returns functions, or both
*** combinators
**** Technical Definition
***** "A combinator is a higher-order function that uses only function application
***** and earlier defined combinators to define a result from its arguments"
**** Looser definition
***** higher-order pure functions that take only functions as arguments
***** and return a function
**** the B combinator (aka Blackbird)
***** const compose = (a, b) => (c) => a(b(c))
**** combinators are useful for reasoning about what you're doing and how (verbs)
**** be more explicit when reasoning about what you're working with (nouns)
*** function decorators
**** definition
***** a higher-order function that takes one function as an argument,
***** and returns a function (a variation of the argument function)
**** function decorators need not be pure


** Building Blocks
*** composition
**** Ex: const cookAndEat = (food) => eat(cook(food));
**** the trick is to organize your code so you can compose functions
*** partial application
**** When a function takes multiple arguments, we need not apply all arguments
***** if we can return a function with arguments pre-supplied
**** orthogonal (involving right angles) to composition


** Magic Names
*** this
**** bound to the function's context (dynamic)
*** arguments
**** an array like object that contains all of the arguments passed to a function
**** we'll use it to build functions that can take a variable number of arguments
*** on fat arrows
**** this and arguments take on the binding from the enclosing scope!
*** Function Design Principles
**** If you call a function more than once, give it a name and first-class status
**** If the function only represents an expression to be computed, use fat arrows
**** The distinction helps sort out the syntatic differences re: magic words
     

** Summary
*** Functions are values that can be part of expressions, returned from other functions
*** Functions are reference values
*** Functions are applied to arguments
*** The arguments are passed by sharing, which is also called pass by value
*** Fat arrow functions have expressions or blocks as their bodies
*** function keyword functions always have blocks as their bodies
*** Function bodies have zero or more statements
*** Expression bodies evaluate to the value of the expression
*** Block bodies evaluate to whatever is returned with the return keyword, else undefined
*** JS uses const to bind values to names within block scope
*** JS uses function declarations to bind functions to names within function scope
*** Function declarations are hoisted
*** Function application creates an environment, with scope
*** Blocks also create scopes if const statements exist within
*** Scopes are nested and free variable references closed over
*** Variables can shadow variables in an enclosing scope


* Recipies with Basic Functions

** Partial Application
*** Recipe Ex: 

#+BEGIN_SRC js :tangle yes
const callFirst = (fn, larg) =>
  function (rest) {
  return fn.call(this, larg, rest);
};

const callLast = (fn, rarg) =>
  function (rest) {
  return fn.call(this, rest, rarg);
};
#+END_SRC

*** TODO let author know that ...rest as a function param causes error
*** Application Ex:

#+BEGIN_SRC js
const callFirst = (fn, larg) =>
  function (rest) {
  return fn.call(this, larg, rest);
};

const greet = (me, you) =>
  `Hello, ${you}, my name is ${me}`;
 
const heliosSaysHello = callFirst(greet, 'Helios');

console.log(heliosSaysHello('Celine'));

#+END_SRC

#+RESULTS:
: Hello, Celine, my name is Helios
: undefined

*** note that an application of callLast could be named sayHelloToCeline
*** Gathering and Spreading allow partial application for many args
*** TODO Recipe Ex:

#+BEGIN_SRC js tangle: yes
 const callLeft = (fn, args) =>
  (remainingArgs) =>
    fn(args, remainingArgs);

 const callRight = (fn, args) =>
  (remainingArgs) =>
    fn(remainingArgs, args);

#+END_SRC

#+RESULTS:
: undefined

*** play with these examples in the repl
*** design a function with three arguments and partially apply them
*** try a function with four arguments


** Unary
*** Definition
**** A function decorator that modfies a function so that it takes only one argument
*** Recipe Ex:

#+BEGIN_SRC js :tangle yes
const unary = (fn) =>
   fn.length === 1
     ? fn
     : function (something) {
         return fn.call(this, something);
};
#+END_SRC

#+RESULTS:
: undefined

*** Application Example:

#+BEGIN_SRC js
const unary = (fn) =>
   fn.length === 1
     ? fn
     : function (something) {
         return fn.call(this, something);
};
console.log(['1', '2', '3'].map(unary(parseInt)));
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 |

*** Note that the unary operator is necessary above because parseInt is defined
*** as parseInt(string[, radix]). parseInt takes an optional radix argument. 
*** And when you call parseInt with map, the index (an argument of map) is 
*** interpreted as a radix.


** Tap

*** the K combinator (Kestrel)
**** const K = (x) => (y) => x;
*** Recipe Ex:

#+BEGIN_SRC js
const tap = (value) =>
 (fn) => (
   typeof(fn) === 'function' && fn(value),
     value
   );
#+END_SRC

#+RESULTS:
: undefined

*** Description:
**** tap takes a value and returns a function that always returns the value
**** but, if you pass it a function, it executes the function (using the value 
**** as an argument) for side-effects
*** Application Example:

#+BEGIN_SRC js
const tap = (value) =>
 (fn) => (
   typeof(fn) === 'function' && fn(value),
     value
   );

tap('espresso')(it => {
  console.log(`Our drink is '${it}'`);
});
#+END_SRC

#+RESULTS:
: Out drink is 'espresso'
: undefined

*** Recipe Ex: w/o 'currying'

#+BEGIN_SRC js
const tap = (value, fn) => {
   typeof(fn) === 'function' && fn(value),
   value
};
#+END_SRC

#+RESULTS:
: undefined
 
*** Recipe Ex: (currying optional)

#+BEGIN_SRC js :tangle yes
const tap = (value, fn) => {
  const curried = (fn) => (
    typeof(fn) === 'function' && fn(value),
    value
  );
 
  return fn === 'undefined'
    ? curried
    : curried(fn);
};
#+END_SRC

#+RESULTS:
: undefined

*** a poor mans debugger, and useful for working with object and instance methods


** Maybe
*** sometimes you want to vet a value before you pass it to a function
**** in JS you might: value !== null && value !== void 0
**** to ensure that the value is not null or undefined
**** naturally there's a function decorator for that
*** Recipe Ex:

#+BEGIN_SRC js :tangle yes
'use strict'
const maybe = (fun) =>
  function (args) {
    if (args.length === 0) {
      return
    } else {
      for (let arg of args) {
        if (arg == null) return;
      }
    return fn.apply(this, args)
    }
};
#+END_SRC

#+RESULTS:
: undefined

*** note: plays nicely with instance methods (foreshadowing)


** Once
*** Ensures that a function can only be called once
*** Recipe Ex:

#+BEGIN_SRC js :tangle yes
'use strict'
const once = (fn) => {
  let done = false;
 
  return function () {
    return done ? void 0 : ((done = true), fn.apply(this, arguments))
  }
};
#+END_SRC

*** Application Ex:

#+BEGIN_SRC js
'use strict'
const once = (fn) => {
  let done = false;
 
  return function () {
    return done ? void 0 : ((done = true), fn.apply(this, arguments))
  }
};

const askedOnABlindDate = once(
  () => 'sure'
);

console.log(askedOnABlindDate());
console.log(askedOnABlindDate());
console.log(askedOnABlindDate());
console.log(askedOnABlindDate());

#+END_SRC

#+RESULTS:
: sure
: undefined
: undefined
: undefined
: undefined

*** there's a closure here, to manage the internal state of 'done'
*** see stateful method decorators... (foreshadowing)


** Left-Variadic Function
*** Variadic functions accept a variable number of arguments.
**** JS now lets you do this when using rest parameters. Ex: (x, y, ...z)
**** This may be useful for certian kinds of destructuring algorithms
**** But JS only permits gathering parameters from the end of the parameter list
***** AKA: Right Variadic Functions
*** Left Variadic Functions require some fussing
**** thankfully, the rest parameter is (acts like?) a proper array
**** so we can grab all argument with the rest parameter, and slice them up to 
**** grab the right-most arguments, and bundle the rest
*** Recipe Ex:

#+BEGIN_SRC js :tangle yes
const leftVariadic = (fn) => {
  if (fn.length < 1) {
    return fn;
  } else {
    return function (args) {
      const gathered = args.slice(0, args.length - fn.length + 1), spread = args.slice(args.length - fn.length + 1);
      return fn.apply(
        this, [gathered].concat(spread)
      ); }
    } 
};

#+END_SRC

#+RESULTS:
: undefined

*** Application Ex:
    
#+BEGIN_SRC js
const leftVariadic = (fn) => {
  if (fn.length < 1) {
    return fn;
  } else {
    return function (args) {
      const gathered = args.slice(0, args.length - fn.length + 1), spread = args.slice(args.length - fn.length + 1);
      return fn.apply(
        this, [gathered].concat(spread)
      ); }
    } 
};

const butLastAndLast = leftVariadic((butLast, last) => [butLast, last]);
console.log(butLastAndLast(['why', 'hello', 'there', 'little', 'droid']));
#+END_SRC

#+RESULTS:
| (why hello there little) | droid |

*** TODO wierd error with ...args, and argument to butLastAndLAst should be an array
*** Destructuring
**** Javascript can now destructure arrays when assigning variables 
**** Recipe Ex:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
'use strict'
const [first, ...butFirst] = ['why', 'hello', 'there', 'little', 'droid'];
console.log(first, butFirst);
console.log(first); 
#+END_SRC

#+RESULTS:
: why [ 'hello', 'there', 'little', 'droid' ]
: why
: undefined

**** Note again, this is right variadic destructuring
*** leftGather
**** We can use the rest parameter, and Array#slice to make our own leftGather function
**** we have to supply the length of the array into which we will destructure
**** so that excess arguments can be collected in the left parameter
**** Recipe Ex:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :tangle yes
const leftGather = (outputArrayLength) => { 
  return function (inputArray) {
    return [inputArray.slice(0, 
            inputArray.length - outputArrayLength + 1)]
           .concat(
             inputArray.slice(inputArray.length - outputArrayLength + 1)
           )
    } 
};
#+END_SRC

#+RESULTS:
: undefined

**** Application Ex:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
'use strict'
const leftGather = (outputArrayLength) => {
  return (
    function(inputArray) {
      return [inputArray.slice(0, inputArray.length - outputArrayLength + 1), 
              inputArray.slice(inputArray.length - outputArrayLength + 1)];
    });
}

const [butLast, last] = leftGather(2)(['why', 'hello', 'there', 'little', 'droid']);
console.log(butLast);
console.log(last);

#+END_SRC  

#+RESULTS:
| why | hello | there | little |

**** TODO why only one console.log working? that's so strange, schrodinger's arguments
**** TODO seem related to display of arrays as tables, one table ruins what follows

** Compose and Pipeline
 


* Picking the Bean: Choice and Truthiness


* Composing and Decomposing Data
