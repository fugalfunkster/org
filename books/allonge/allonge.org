Javascript Allonge Notepad

* Aside: Welcome to fugalfunkster's notebook

** Hello... But, why? 
   My name is Matthew, and I remember things better when I write them down.
   Normally, I like to take notes with pen and paper, and I keep myself organized
   with index cards. but now that I'm learning to program computers, I've reached 
   the limit of that medium. In the search for something more idiomatic, 
   interactive, and sharable, I found org mode.
     Org mode is a mode (modality) for emacs, packed full of tools for organizing 
   ones thoughts and getting things done. Note that this document is just a text 
   file with a .org file type. Viewed without the aid of org mode, the document
   contains meaningful but useless markup. When edited in emacs' org mode, that
   markup breathes structure and interactivity into the document.
     This notebook is the product of my study of Reginald Braithwaite's "Javascript
   Allonge." 

** Org-Mode and Literate Programming
   This document is saved as a text file, suffixed with .org 

*** http://howardism.org/Technical/Emacs/literate-programming-tutorial.html

*** Not all code will appear in a block
** Terminology

*** cf : compare

** Org-Babel

** ES6 code blocks

*** node npm babel
*** http://rwx.io/blog/2015/10/06/org-with-babel-node/

*** In this doc, code blocks will be labeled as "Ex:" with their own bullet to expand
*** Note that many of these code blocks begin with return when the result isn't 
*** logged to stdout (in this case, console.log)
**** this is required to recieve the return value of an expression 
**** because org-babel executes the code-block within a function wrapper

** Properties
*** Here's the doc-wide tangle property if you wish to modify it:
**** note, this property tag must be registered with the point over the code
**** and a lil C-c C-c
***  Getting the result
**** :results output
*** using babel
**** :cmd "org-babel-node --presets es2015"
*** Do the tangle
**** What is tangling?
***** http://orgmode.org/manual/Extracting-source-code.
**** It takes "C-c C-v t" to tangle
**** Select code blocks in this document will to tangle out to recipes.js
***** but only for those blocks with the property :tangle yes

 
* Prelude: Values and Expressions over Coffee

** values are expressions
*** but not all expressions are values
*** when an expression includes an operator, it is not a value
** values and identity
*** we test whether two values are identical with === and !== 
** value types
*** primitives can be identical
*** 123 === 123 >> true
** reference types
*** reference types are always unique
*** [1,2,3]===[1,2,3] >> false


* A Rich Aroma: Basic Numbers

** literal: notation for representing a fixed value in source code
*** nums are double-precision floating point 
*** binary is base 2, some fractions base 10
*** do not have exact representations base 2
*** this is problematic, in monetary calculations for example
** operations on numbers
*** +, -, *, /, %, -:

    
* The First Sip: Basic Functions
 
** As little as possible about Functions
*** functions are values that represent computations to be performed
***** Ex:
  #+BEGIN_SRC js
    return () => 0
  #+END_SRC

  #+RESULTS:
  | Function |

**** We use functions by applying them to arguments (0 or more values)
***** Ex:
  #+BEGIN_SRC js
    return (() => 0 )()
  #+END_SRC

  #+RESULTS:
  : 0

**** functions return values (including other functions)
**** functions evaluate expressions
*** blocks
**** blocks contain zero or more statements, separated by semicolons
**** a block containg no statements evaluates to undefined
*** undefined, the absence of value - another primitive value
**** void is an operator that takes any value
**** and always evaluates to undefined
**** idiomatically: void 0 >> undefined
*** statements
**** all expressions are statements - but some return undefined when applied

***** Ex:
 #+BEGIN_SRC js
   return () => {2 + 2}
 #+END_SRC

 #+RESULTS:
 | Function |

***** cf Ex: 
#+BEGIN_SRC js
  return (() => {2+2})()
#+END_SRC

#+RESULTS:
: undefined

**** not all statements are expressions
*** the return keyword
**** allows us to return a value from a function,
**** when that function evaluates a block
**** return immediately terminates the function application and 
**** returns the result of evaluating its expression

***** Ex:
 #+BEGIN_SRC js
  return (() => { return 2+2; })()  
 #+END_SRC

 #+RESULTS:
 : 4

*** functions are reference types


** Ah. I'd like to Have an Argument, Please.
*** a quick summary of functions and bodies
**** Expressions consist either of representations of values,
**** operators that combine expressions, and special forms
**** like object/array/function literal notation
**** A return statement accepts any valid JS expression
*** I. - Call by value
**** javascript will evaluate all expressions applied to a function
**** then applies the function to the resulting value(s)
*** variables, bindings, and environment
**** Every time a function is invoked, a new environment is created
**** each environment maps variable names to argument values
**** like a dictionary {x: 2}

***** Ex:
#+BEGIN_SRC js
  ((x) => x)(2)
#+END_SRC

#+RESULTS:
: undefined

**** recall YDKJS discussion of scope/environments/etc...
*** II - Call by sharing
**** when js binds a value-type to a name it makes a copy of the value
**** when js binds a reference-type to a name, it uses a reference


** Closures and Scope
*** Free Variables - those not bound within the function
**** bound with a var/let/const or via an argument
**** Functions containing no free variables are called pure functions
***** But a pure function can contain a closure
***** Ex:

#+BEGIN_SRC js
  return ((x) => (y) => x)(1)(2)
#+END_SRC

#+RESULTS:
: 1

**** Functions containing one or more free variables are called closures
***** closures cannot contain pure functions, because free variables
***** remain accessable to inner functions
*** Intro to Combinators!
**** the I Combinator (aka the Identity Function)
***** (x) => x
**** the K Combinator (aka Kestrel)
***** (x) => (y) => x
*** shadowing - local scope shadows parent scope
*** the global environment
**** many programmers enclose each javascript file within a function expression
***** (() => { . . . })();


** That Constant Coffee Craving
*** Immediately Invoked Function Expressions
**** We can bind any value we want for an expression by wrapping the expression
**** in a function and subsequently invoking the function with our value

***** ex: 
#+BEGIN_SRC js
  return ((pi) => (diameter) => diameter * pi)(3.14)(10)
#+END_SRC

#+RESULTS:
: 31.400000000000002

**** inside-out

***** Ex:
#+BEGIN_SRC js
  return ((diameter) => ((pi) => diameter * pi)(3.14))(10)
#+END_SRC

#+RESULTS:
: 31.400000000000002

**** invoking functions is considerably more expensive than evaluating functions
***** every time we invoke the outer function, we'll invoke the inner function
*** const - can bind any expression (including functions)
**** the const keyword introduces one or more bindings in its enclosing block
***** const statements must occur inside blocks,
***** we can't use them when we write a fat arrow that has an expression as its body
**** naming functions is elegant when functions are expressions
**** const can affect multiple bindings using commas
*** nested blocks - not just for functions
**** other kinds of blocks
***** if statements are not expressions, its clauses are statements or blocks
***** const scopes to these blocks too!
*** const obeys lexical scope
**** blocks delineate const-binding's environment
**** const shadows just like parameter/argument bindings
*** Bind names as close to where we need them as possible
**** this design rule is called the Principle of Least Priviledge
**** it has both quality and security implications
*** rebinding - not with const
**** although we can rebind named parameters/arguments to a different value
**** javascript does not permit us to rebind const-s


** Naming Functions
*** the function keyword
**** can have a name! - and should for code clarity and debugging
***** confusingly, we could still bind the named functions with const
***** this would result in a binding in the enclosing environment
***** but the function would retain its given name
***** so we would have created a named function expression
****** the name of the function is a property of the function 
**** the body must be a block
**** thus we must use the return keyword to return a value from the block
**** Note on named function expressions 
***** the function name is not available in the enclosing scope
***** but the function name is available within the body of the function
***** preserves recursion without resorting to shenanegans
*** function declarations
**** a statement instead of an expression
**** the function's name becomes bound in the environment
**** note, function declarations are hoisted
*** function declarations should not occur within other blocks or expressions
**** of course, functions declarations often do occur inside other function blocks
**** see for example, the note on the global environment in Closures and Scope


** Combinators and Function Decorators
*** higher order functions
**** any function that takes a function as argument, returns functions, or both
*** combinators
**** Technical Definition
***** "A combinator is a higher-order function that uses only function application
***** and earlier defined combinators to define a result from its arguments"
**** Looser definition
***** higher-order pure functions that take only functions as arguments
***** and return a function
**** the B combinator (aka Blackbird)
***** const compose = (a, b) => (c) => a(b(c))
**** combinators are useful for reasoning about what you're doing and how (verbs)
**** be more explicit when reasoning about what you're working with (nouns)
*** function decorators
**** definition
***** a higher-order function that takes one function as an argument,
***** and returns a function (a variation of the argument function)
**** function decorators need not be pure

     
** Building Blocks
*** composition
**** Ex: const cookAndEat = (food) => eat(cook(food));
**** the trick is to organize your code so you can compose functions
*** partial application
**** When a function takes multiple arguments, we need not apply all arguments
***** if we can return a function with arguments pre-supplied
**** orthogonal (involving right angles) to composition


** Magic Names
*** this
**** bound to the function's context (dynamic)
*** arguments
**** an array like object that contains all of the arguments passed to a function
**** we'll use it to build functions that can take a variable number of arguments
*** on fat arrows
**** this and arguments take on the binding from the enclosing scope!
*** Function Design Principles
**** If you call a function more than once, give it a name and first-class status
**** If the function only represents an expression to be computed, use fat arrows
**** The distinction helps sort out the syntatic differences re: magic words
     

** Summary
*** Functions are values that can be part of expressions, returned from other functions
*** Functions are reference values
*** Functions are applied to arguments
*** The arguments are passed by sharing, which is also called pass by value
*** Fat arrow functions have expressions or blocks as their bodies
*** function keyword functions always have blocks as their bodies
*** Function bodies have zero or more statements
*** Expression bodies evaluate to the value of the expression
*** Block bodies evaluate to whatever is returned with the return keyword, else undefined
*** JS uses const to bind values to names within block scope
*** JS uses function declarations to bind functions to names within function scope
*** Function declarations are hoisted
*** Function application creates an environment, with scope
*** Blocks also create scopes if const statements exist within
*** Scopes are nested and free variable references closed over
*** Variables can shadow variables in an enclosing scope


* Recipies with Basic Functions

** Partial Application
*** Recipe: 

#+BEGIN_SRC js :tangle yes
const callFirst = (fn, larg) =>
  function (rest) {
  return fn.call(this, larg, rest);
};

const callLast = (fn, rarg) =>
  function (rest) {
  return fn.call(this, rest, rarg);
};
#+END_SRC

*** TODO ...rest as a function param causes error
*** Example:

#+BEGIN_SRC js cmd: "org-babel-node --presets es2015" :results output
const callFirst = (fn, larg) =>
  function (rest) {
  return fn.call(this, larg, rest);
};

const greet = (me, you) =>
  `Hello, ${you}, my name is ${me}`;
 
const heliosSaysHello = callFirst(greet, 'Helios');

console.log(heliosSaysHello('Celine'));

#+END_SRC

#+RESULTS:
: Hello, Celine, my name is Helios

*** note that an application of callLast could be named sayHelloToCeline
*** Gathering and Spreading allow partial application for many args
*** TODO Recipe:

#+BEGIN_SRC js cmd: "org-babel-node --presets es2015" tangle: yes
 const callLeft = (fn, ...args) =>
  (remainingArgs) =>
    fn(...args, ...remainingArgs);

 const callRight = (fn, ...args) =>
  (remainingArgs) =>
    fn(remainingArgs, args);

const greet = (me, you) =>
  `Hello, ${you}, my name is ${me}`;
 
const heliosSaysHello = callLeft(greet, 'Helios');

console.log(heliosSaysHello('Celine'));

#+END_SRC

#+RESULTS:

*** play with these examples in the repl
*** design a function with three arguments and partially apply them
*** try a function with four arguments

** Unary
*** Definition
**** A function decorator that modfies a function so that it takes only one argument
*** Recipe:

#+BEGIN_SRC js :tangle yes
const unary = (fn) =>
   fn.length === 1
     ? fn
     : function (something) {
         return fn.call(this, something);
};
#+END_SRC

#+RESULTS:
: undefined

*** Example:

#+BEGIN_SRC js
const unary = (fn) =>
   fn.length === 1
     ? fn
     : function (something) {
         return fn.call(this, something);
};
console.log(['1', '2', '3'].map(unary(parseInt)));
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 |

*** Note that the unary operator is necessary above because parseInt is defined
*** as parseInt(string[, radix]). parseInt takes an optional radix argument. 
*** And when you call parseInt with map, the index (an argument of map) is 
*** interpreted as a radix.


** Tap

*** the K combinator (Kestrel)
**** const K = (x) => (y) => x;
*** Recipe:

#+BEGIN_SRC js
const tap = (value) =>
 (fn) => (
   typeof(fn) === 'function' && fn(value),
     value
   );
#+END_SRC

#+RESULTS:
: undefined

*** Description:
**** tap takes a value and returns a function that always returns the value
**** but, if you pass it a function, it executes the function (using the value 
**** as an argument) for side-effects
*** Application Example:

#+BEGIN_SRC js
const tap = (value) =>
 (fn) => (
   typeof(fn) === 'function' && fn(value),
     value
   );

tap('espresso')(it => {
  console.log(`Our drink is '${it}'`);
});
#+END_SRC

#+RESULTS:
: Out drink is 'espresso'
: undefined

*** Recipe: w/o 'currying'

#+BEGIN_SRC js
const tap = (value, fn) => {
   typeof(fn) === 'function' && fn(value),
   value
};
#+END_SRC

#+RESULTS:
: undefined
 
*** Recipe: (currying optional)

#+BEGIN_SRC js :tangle yes
const tap = (value, fn) => {
  const curried = (fn) => (
    typeof(fn) === 'function' && fn(value),
    value
  );
 
  return fn === 'undefined'
    ? curried
    : curried(fn);
};
#+END_SRC

#+RESULTS:
: undefined

*** a poor mans debugger, and useful for working with object and instance methods


** Maybe
*** sometimes you want to vet a value before you pass it to a function
**** in JS you might: value !== null && value !== void 0
**** to ensure that the value is not null or undefined
**** naturally there's a function decorator for that
*** Recipe:

#+BEGIN_SRC js :tangle yes
'use strict'
const maybe = (fun) =>
  function (args) {
    if (args.length === 0) {
      return
    } else {
      for (let arg of args) {
        if (arg == null) return;
      }
    return fn.apply(this, args)
    }
};
#+END_SRC

#+RESULTS:
: undefined

*** note: plays nicely with instance methods (foreshadowing)


** Once
*** Ensures that a function can only be called once
*** Recipe:

#+BEGIN_SRC js :tangle yes
'use strict'
const once = (fn) => {
  let done = false;
 
  return function () {
    return done ? void 0 : ((done = true), fn.apply(this, arguments))
  }
};
#+END_SRC

*** Example:

#+BEGIN_SRC js
'use strict'
const once = (fn) => {
  let done = false;
 
  return function () {
    return done ? void 0 : ((done = true), fn.apply(this, arguments))
  }
};

const askedOnABlindDate = once(
  () => 'sure'
);

console.log(askedOnABlindDate());
console.log(askedOnABlindDate());
console.log(askedOnABlindDate());
console.log(askedOnABlindDate());

#+END_SRC

#+RESULTS:
: sure
: undefined
: undefined
: undefined
: undefined

*** there's a closure here, to manage the internal state of 'done'
*** see stateful method decorators... (foreshadowing)


** Left-Variadic Functions
*** Variadic functions accept a variable number of arguments.
**** JS now lets you do this when using rest parameters. Ex: (x, y, ...z)
**** This may be useful for certian kinds of destructuring algorithms
**** But JS only permits gathering parameters from the end of the parameter list
***** AKA: Right Variadic Functions
*** Left Variadic Functions require some fussing
**** thankfully, the rest parameter is (acts like?) a proper array
**** so we can grab all argument with the rest parameter, and slice them up to 
**** grab the right-most arguments, and bundle the rest
*** Recipe:

#+BEGIN_SRC js :tangle yes
const leftVariadic = (fn) => {
  if (fn.length < 1) {
    return fn;
  } else {
    return function (args) {
      const gathered = args.slice(0, args.length - fn.length + 1), spread = args.slice(args.length - fn.length + 1);
      return fn.apply(
        this, [gathered].concat(spread)
      ); }
    } 
};

#+END_SRC

#+RESULTS:
: undefined

*** Example:
    
#+BEGIN_SRC js
const leftVariadic = (fn) => {
  if (fn.length < 1) {
    return fn;
  } else {
    return function (args) {
      const gathered = args.slice(0, args.length - fn.length + 1), spread = args.slice(args.length - fn.length + 1);
      return fn.apply(
        this, [gathered].concat(spread)
      ); }
    } 
};

const butLastAndLast = leftVariadic((butLast, last) => [butLast, last]);
console.log(butLastAndLast(['why', 'hello', 'there', 'little', 'droid']));
#+END_SRC

#+RESULTS:
| (why hello there little) | droid |

*** TODO wierd error with ...args, and argument to butLastAndLAst should be an array
*** Destructuring
**** Javascript can now destructure arrays when assigning variables 
**** Recipe:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
'use strict'
const [first, ...butFirst] = ['why', 'hello', 'there', 'little', 'droid'];
console.log(butFirst);
console.log(first); 
#+END_SRC

#+RESULTS:
: [ 'hello', 'there', 'little', 'droid' ]
: why

**** Note again, this is right variadic destructuring
*** leftGather
**** We can use the rest parameter, and Array#slice to make our own leftGather function
**** we have to supply the length of the array into which we will destructure
**** so that excess arguments can be collected in the left parameter
**** Recipe:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :tangle yes
const leftGather = (outputArrayLength) => { 
  return function (inputArray) {
    return [inputArray.slice(0, 
            inputArray.length - outputArrayLength + 1)]
           .concat(
             inputArray.slice(inputArray.length - outputArrayLength + 1)
           )
    } 
};
#+END_SRC

**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
const leftGather = (outputArrayLength) => { 
  return function (inputArray) {
    return [inputArray.slice(0, 
            inputArray.length - outputArrayLength + 1)]
           .concat(
             inputArray.slice(inputArray.length - outputArrayLength + 1)
           )
    } 
};

const [butLast, last] = leftGather(2)(['why', 'hello', 'there', 'little', 'droid']);
console.log(butLast);
console.log(last);

#+END_SRC  

#+RESULTS:
: [ 'why', 'hello', 'there', 'little' ]
: droid

     
** Compose and Pipeline
*** The B Combinator (again)
*** Recipe:

#+BEGIN_SRC js :tangle yes
  const compose = (a, b) =>
  (c) => a(b(c))
#+END_SRC

*** Example:
 
#+BEGIN_SRC js
  const compose = (a, b) =>
    (c) => a(b(c))

  const addOne = (number) => number + 1;
  const doubleOf = (number) => number * 2;
  const doubleOfAddOne = compose(doubleOf, addOne);

  console.log(doubleOfAddOne(3));

#+END_SRC

#+RESULTS:
: 8
: undefined

*** Variadic compose through recursion 
**** Recipe:

 #+BEGIN_SRC js
 const compose = (a, rest) =>
   rest.length === 0
     ? a
     : (c) => a(compose(rest)(c))

 #+END_SRC

*** Semantics
**** Compose isn't necessarily helpful for compound actions that are realted,
**** like intermediate steps in a calculation.
**** But, to combine multiple, single-purpose functions, compose works nicely.
**** Thus, compost is at its best when defining a new function
**** that combines the effects of existing functions
*** Pipeline
**** Compose accepts arguments that execute from right to left,
**** ex: (doubleOf, addThree)
**** which is not the most intuitive, we have to write the function name of the 
**** first argument to reflect that it is acting on the result of the next argument
**** pipeline solves this by allowing function names that are syntatically insensitive
*** Recipe:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :tangle yes
  const pipeline = (...fns) => 
    (value) =>
      fns.reduce((acc, fn) => fn(acc), value);
#+END_SRC

*** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" 
  const pipeline = (...fns) => 
    (value) =>
      fns.reduce((acc, fn) => fn(acc), value); 

  const addOne = (number) => number + 1;
  const double = (number) => number * 2;
  const setter = pipeline(addOne, double);

console.log(setter(2));
#+END_SRC

#+RESULTS:
: 6
: undefined


* Picking the Bean: Choice and Truthiness
** Boolean
*** true and false are value types, true === true, false === false
** truthiness
*** 6 kinds of wrong
**** 0, '', NaN, undefined, null, false
*** Everything else is truthy
** "Logical" operators evaluate truthiness, not boolean values
*** ! - negation operator
**** unary prefix
**** returns false if its argument is truthy
**** returns true if its argument is falsey
***** !! is a way to convert a truthy value to the boolean true
*** && - logical and
**** binary infix
**** && evaluates its left-hand expression, and if falsey, returns that value
**** else, && evaluates and returns its right-hand expression
*** || - logical or
**** binary infix
**** || evaluates its left-hand expression, and if truthey, returns that value
**** else, || evaluates and returns its right-hand expression
*** first ? second : third  - the ternary operator
**** if the ternary's first argument is truthy,
**** it evaluates it's second argument,
**** otherwise it evaluates its third argument
**** an expression, not a statement (like if/else)
** These operators provide flow control, not pure logical operators
*** Function parameters are eagerly evaluated
**** This means that JavaScript always evaluates expressions provided as parameters
**** to a function, before passing those values into the function for invocation
**** Recall Applicative Order and Normal Order
***** See SICP and HtDP
**** If we need to roll our own control-flow semantics,
**** we must pass functions as parameters to other functions,
**** not expressions, which would be evaluated
*** Flow Control operators have "short-cut" semantics


* Composing and Decomposing Data

** Arrays and Destructuring Arguments
*** Arrays are ordered collections of elements
**** Arrays are reference types
**** Literals - [element, element, element]
***** Array literals are expressions that evaluate to an array
**** Element References
***** In JavaScript, arrays are 0 based
***** You can extract an element within an array by using bracket notation
***** Example:

#+BEGIN_SRC js
  const x = [], a = [x];
  console.log(a[0] === x);

#+END_SRC

#+RESULTS:
: true
: undefined

***** As the previous example demonstrates, 
***** arrays relate to their elements by reference
*** Destructuring Arrays
**** New ES6 Syntax
***** In addition to bracket notation, we can extract elements of an array
***** by destructuring the array.
***** Destructuring an array mirrors array declaration.
***** On the left side of an assignment,
***** we have brackers surrounding the name binding(s)
***** And on the right, the array to destructure
**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
// declare
  const container = ['goodies'];
// destructure
  const unwrap = (wrapped) => { 
    const [something] = wrapped;
    return something; 
  }
  console.log(unwrap(container));

#+END_SRC

#+RESULTS:
: goodies
: undefined

*** Gathering and Spreading
**** Gathering (extracting an array from an array)
***** We can also extract arrays from an array, for example extracting the head
***** and the remaining elements of the array (the "rest")
****** Recall our right and left variadiac functions
**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const [car, ...cdr] = [1, 2, 3, 4, 5];
  console.log(car);
  console.log(cdr);
#+END_SRC

#+RESULTS:
: 1
: [ 2, 3, 4, 5 ]
**** Spreading (assembling an array with an array)
**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
  const oneTwoThree = ['one', 'two', 'three'];
  console.log(['zero', ...oneTwoThree]);

#+END_SRC

#+RESULTS:
| zero | one | two | three |

*** Application
**** Destructuring is not Pattern Matching
***** When destructuring, the sides of the assignment operator should align
***** In other programming languages, a mismatched destructuring attempt will err
***** JavaScript, however, simply assigns undefined when destructuring fails
***** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
  const [thistle, that, theOther] = ['duck feet', 'tiger tail'];
  console.log(theOther);

  const [...what] = [];
  console.log(what);

#+END_SRC

#+RESULTS:
: undefined
: []
: undefined

**** Destructuring and Return Values
***** Some languages support multiple return values, ie: a function can return
***** several things at once, like a value and an error code. We can emulate that
***** with destructuring
***** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const description = (nameAndOccupation) => { 
    if (nameAndOccupation.length < 2) {
      return ["", "occupation missing"] 
    } else {
      const [[first, last], occupation] = nameAndOccupation;
      return [`${first} is a ${occupation}`, "ok"];
    }
  }

  const [reg, status] = description([["Reginald", "Braithwaite"], "programmer"]);

  console.log(reg);
  console.log(status);
#+END_SRC

#+RESULTS:
: Reginald is a programmer
: ok

**** Destructuring parameters
***** Consider that the parameters to a function are also a collection of elements
***** We can destructure those too! permitting us to create functions that accept
***** a variable number of arguments
***** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
 const theWholeShebang = (car, ...cdr) => [car, cdr];
 console.log(theWholeShebang('why', 'hello', 'there', 'little', 'droid'));

#+END_SRC

#+RESULTS:
: [ 'why', [ 'hello', 'there', 'little', 'droid' ] ]


** Self-Similarity
*** What is a list?
    Lists are a collection composed of zero or more elements.
      In the previous chapter, we created arrays through literal declaration
    and then destructured arrays into their constituent elements. These two
    operations are opposites.
      We can also define a list in terms of rules, that - if followed - 
    create a list. Traditionally, there are two rules that define a list. A list is
    either:
      1. Empty
      2. Consists of an element concatenated with a list
    Thus, [] is a list. So is ["baz", []]. 
*** A process to determing whether a value is an empty list:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const isEmpty = ([first, ...rest]) => first === undefined; 

  console.log(isEmpty([]));
  console.log(isEmpty([0]));
  console.log(isEmpty([[]]));

#+END_SRC

#+RESULTS:
: true
: false
: false

*** A recursive process to determine the length of an array

 #+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

   const length = ([first, ...rest]) =>
     first === undefined 
       ? 0
       : 1 + length(rest);

   console.log(length([]));
   console.log(length([1,2,3]));

 #+END_SRC

 #+RESULTS:
 : 0
 : 3
*** Recursion
    Our length function is recursive, it calls itself. This makes sense because
    our definition of a list is recursive, and if a list is self-similar, it is
    natural to create an algorithm that is also self similar.
      Recursive algorithms follow the "divide and conquer" strategy:
    1. Divide the problem into smaller problems
    2. If a smaller problem is solvable, solve the small problem
    3. If a smaller problem is not solvable, divide and conquer that problem
    4. When all problems are solved, compose the solutions   
*** Linear Recursion
    Linear recursion varies from this strategy in that it entails breaking off
    a piece of a problem, the terminal case, solving that piece and then sticking
    it onto a solution for the rest of the problem.
*** Flatten-ing

#+BEGIN_SRC  js :cmd "org-babel-node --presets es2015" :results output

  const flatten = ([first, ...rest]) => {
    if (first === undefined) {
      return [];
    } else if (!Array.isArray(first)) {
      return [first, ...flatten(rest)];
    } else {
      return [...flatten(first), ...flatten(rest)];
    }
}

console.log(flatten(['foo', [3, 4, []]]));

#+END_SRC

#+RESULTS:
: [ 'foo', 3, 4 ]

*** Map-ing:
    Mapping, applying a function to each element of an array, is a form of 
    linear recursion.
**** Recipe:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" 
  const mapWith = (fn, [first, ...rest]) => {
    first === undefined
      ? []
      : [fn(first), mapWith(fn, rest)];
  }

#+END_SRC
**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" 
  const mapMaker = (fn, [first, ...rest]) => 
    first === undefined ? [] : [fn(first), ...mapMaker(fn, rest)];

  console.log(mapMaker((x) => x * x, [1,2,3,4]));

#+END_SRC

#+RESULTS:

*** Fold-ing:
    With the exception of the length example earlier, all of our examples have used
    the spread operator, ... , to rebuild our solution. We might instead want to
    concatenate the values from each step of the process.
**** sumSquares Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const sumSquares = ([first, ...rest]) => 
    first === undefined 
      ? 0
      : first * first + sumSquares(rest);

  console.log(sumSquares([1,2,3]));

#+END_SRC

#+RESULTS:
: 14

**** sumSquares vs. Map
     There are two differences between sumSquares and our map example:
       1. Given the terminal case of an empty list, we return 0 instead of []
       2. We catenate the square of each element to the result of fn(rest) 
**** foldWith, a moar general mapWith:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const foldWith = (fn, terminalValue, [first, ...rest]) => 
    first === undefined
      ? terminalValue
      : fn(first, foldWith(fn, terminalValue, rest));

  console.log(foldWith((x, rest) => x * x + rest, 0, [1,2,3]));

#+END_SRC

#+RESULTS:
: 14

*** Folding is a form of linear recursion, mapping is a form of folding 
    We can represent a map as a fold, we just need to supply the array-rebuilding 
    code
**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const foldWith = (fn, terminalValue, [first, ...rest]) => 
    first === undefined
      ? terminalValue
      : fn(first, foldWith(fn, terminalValue, rest));

  const mapWith = (fn, array) => 
    foldWith((first, rest) => [fn(first), ...rest], [], array);

  const squareAll = (array) => mapWith((x) => x * x, array);

  console.log(squareAll([1,2,3,4,5]));

#+END_SRC

#+RESULTS:
: [ 1, 4, 9, 16, 25 ]

  
** Tail Calls (and Default Arguments)
*** Stack Overflow 
    Our implementations of mapWith and foldWith consume memory proportional
    to the size of the array on which they operate. Each time the process recurrs, 
    the engine will open a new function execution context to contine the recursion.
    But, because information that is critical to the final result remains in 
    each function body (at each level or recursion) the JavaScript engine cannot
    discard any of the execution contexts.
      Thus, doubling the size of an array, would double the size of the call stack
    and thus the amount of memory required to map or fold that array.
*** Tail-call Optimization
    A tail call occurs when a function's last act is to invoke another function,
    and then return whatever the other function returns. This permits the engine to
    throw away the prior execution context as it recurrs. Thus, if a function makes
    a call in tail position, JavaScript optimizes away the function call overhead
    and stack space.
**** Example sans TCO:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
  const length = ([first, ...rest]) => 
    first === undefined
      ? 0
      : 1 + length(rest);

#+END_SRC

**** Example w/ TCO:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
  const lengthTCO = ([first, ...rest], counter) => 
    first === undefined
      ? counter
      : length(rest, 1 + counter);

#+END_SRC
        
*** Converting to TCO
    The examples show that a tail-call optimized recursive process passes 
    every expression needed to complete the process into each recursive call. Thus
    the function signature must accept parameters to facilitate this hand-off 
    from one execution context to the next. But, once we modify our function
    signature, our initial call must be aware that we are invoking a TCO process,
    and supply a starting point for the process.
      For our length example, the "counter" parameter should begin at 0. But, we
    can use partial application to avoid having to remember to call lengthTCO
    with a 0 each time.
**** Length Example:
    
#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"


  const lengthTCO = ([first, ...rest], counter) => 
    first === undefined
      ? counter
      : lengthTCO(rest, 1 + counter);

  const callLast = (fn, ...args) =>
    (...moarArgs) =>
      fn(...moarArgs, ...args);

  const length = callLast(lengthTCO, 0);

  console.log(length(['how', 'now', 'brown', 'cow']));

#+END_SRC

#+RESULTS:
: 4
: undefined

**** Factorial Example

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"


  const factorialTCO = (num, product) => 
    num === 1
      ? product
      : factorialTCO(num - 1, num * product);

  const callLast = (fn, ...args) =>
    (...moarArgs) =>
      fn(...moarArgs, ...args);

  const factorial = callLast(factorialTCO, 1);

  console.log(factorial(5));

#+END_SRC

#+RESULTS:
: 120
: undefined

*** Default Arguments
    We can also set default values for function parameters. Within the function
    signature, we can "assign" a value to a parameter in the event that the
    function is invoked without an argument for that parameter.  
**** Example:
     
#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const factorial = (n, work = 1) =>
    n === 1
      ? work
      : factorial(n - 1, n * work)

  console.log(factorial(5));

#+END_SRC

#+RESULTS:
: 120

**** Length and mapWith Examples:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const length = ([first, ...rest], numberToBeAdded = 0) =>
    first === undefined
      ? numberToBeAdded
      : length(rest, 1 + numberToBeAdded)
 
  console.log(length(["foo", "bar", "baz"]));

  const mapWith = (fn, [first, ...rest], prepend = []) =>
    first === undefined
      ? prepend
      : mapWith(fn, rest, [...prepend, fn(first)]);

  console.log(mapWith((x) => x * x, [1, 2, 3, 4, 5]));

#+END_SRC

#+RESULTS:
: 3
: [ 1, 4, 9, 16, 25 ]

*** Defaults and Destructuring
    We saw that destructuring parameters works the same was as destructuring
    assignment. Now we learn that we can create a default parameter argument. We
    can also create a default destructuring assignment!
**** Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const [first, second = "two"] = ["one"];
  console.log(`${first} . ${second}`);

  const [third, fourth = "two"] = ["primus", "secundus"]; 
  console.log(`${third} . ${fourth}`);

#+END_SRC

#+RESULTS:
: one . two
: primus . secundus


** Garbage, Garbage Everywhere
*** Waste
    Our latest mapWith implementation is much improved. Using tail-call
    optimization, mapWith executes in constant space, saving memory.
      But, our implementation is still relatively slow for another reason: Each
    time our process recurrs, it creates a new array [...prepend, fn(first)], and 
    passes that array into mapWith. Once done, the arrays created from the last 
    execution context cease to matter, and are "garbage collected."
      This is wasteful, because each of these temporary arrays takes time to
    create, and is eventually discarded. So why implement recursion in this way?
*** LISP's Lists, a history lesson
    Lisp was first implemented on the IBM 704, a computer that had a 36-bit word,
    meaning that it was very fast to store and retrieve 36-bit values. The CPU's
    instruction set featured two important macros: CAR would fetch 15 bits
    representing the Contents of the Address part of the Register, while CDR would
    fetch the contents of the Decrement Part of the Register. 
      In broad terms, this means that a single 36-bit word could store two
    separate 15-bit values and and it was very fast to save and retrieve pairs of
    values. If you had two 15-bit values and wished to write them to the register,
    the CONS macro would take the values and write them to a 36-bit word.
      Thus, Cons put two values together, CAR extracted one, and CDR extracted the
    other. Lisp's basic data type is often said to be the list, but in actuality it
    was the CONS cell, the term used to describe two 15-bit values stored in one
    word. The 15-bit values were used as pointers that could refer to a location in
    memory, so in effect, a cons cell was a little data structure with two pointers
    to other cons cells.
      Lists were represented as linked lists of cons cells, with each cell's head
    pointing to an element and the tail pointing to another cons cell. Retrieval of 
    the CAR and CDR were fast because those macros were baked into the hardware.
*** Linked Lists in JavaScript
    In JavaScript we can emulate the semantics of CONS, CAR, and CDR:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
  const cons = (a, d) => [a, d];
  const car =([a,d])=>a;
  const cdr =([a,d])=>d;

  const oneToFive = cons(1, cons(2, cons(3, cons(4, cons(5, null)))));

#+END_SRC

    Although JavaScript would display out list as a series of nested arrays, because 
    array's are reference types, oneToFive is more accutarely represented as:
  
#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
  const node5 = [5, null],
        node4 = [4, node5],
        node3 = [3, node4],
        node2 = [2, node3],
        node1 = [1, node2];

  const oneToFive = node1;

#+END_SRC

    Our implementation is much faster at getting all of the elements except for
    the head of a linked list than it would be if we were using an array. Getting
    one reference to a structure that already exists is faster than copying a bunch
    of elements. 
      So, when we gather or spread arrays during our recursions - using
    [first, ...rest] - we're doing something laborious and memory-inefficient
    compared to using a linked list.

*** Arrays, what are they good for?
    If arrays are so slow, why does JavaScript sport them out of the box? Arrays
    are relatively slow when it comes to CAR and CDR, but much faster at other
    operations, like:
      1. Iteration over the list
      2. Retrieving data by index
      3. Changing elements in place


** Plain Old JavaScript Objects
*** Dictionaries
    Lists were performant because they closely mapped hardware, but they're not
    particularly user friendly. How is one to remember what data is stored where?
      Dictionaries evolved out of a need to name the data stored in lists. 
    Dictionaries store key-value pairs, but the underlying implementation could
    be a hashed colletion, a tree of some sort, or something else. JavaScript calls
    its dictionaries "objects."
      In JavaScript an object is a map from string keys to values.
*** Object Literals
**** Syntax: { key: 'value', anotherKey: 'anotherValue' }
**** Like arrays, objects are reference types
**** Value access with bracket notation or dot notation if the name conforms 
**** Expressions can be used for keys when enclosed in square brackets
**** Keys can store any value: functions, arrays, other objects, etc.
*** Three different ways to store functions:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

  const combinator = {
    idiotBird : function (x) {
      return x;
    },
    kestrel : function kestrel (x) {
      return (y) => (x);
    },
    blackBird (a, b) {
     return (c) => a(b(c));
    }
  }

  var bigBird = combinator.blackBird(combinator.kestrel, combinator.idiotBird)(3);

  console.log(bigBird());

#+END_SRC

#+RESULTS:
: 3
: undefined

*** Destructuring Objects
**** Literal Destructuring:
     
#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

  const knight = {
    name: {
      first: 'Matthew',
      last: 'Hoselton'
    },
    quest: 'to seek the Y combinator',
    color: 'blue'
  }

  const {name: {first: given, last: surname}, quest, color} = user;

  console.log(given + ' ' + surname);

#+END_SRC

#+RESULTS:
: Matthew Hoselton
: undefined

**** Destructuring Parameters:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

  const knight = {
    name: {
      first: 'Matthew',
      last: 'Hoselton'
    },
    quest: 'to seek the Y combinator',
    color: 'blue'
  }

  const description = ({name: {first: given, last: surname}, quest, color}) =>
   `Sir ${surname} is on a quest ${quest}`

  console.log(description(knight));

#+END_SRC

#+RESULTS:
: Sir Hoselton is on a quest to seek the y combinator
: undefined

**** Sugar (for when the object key is a valid variable name):

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

  const knight = {
    name: {
      first: 'Matthew',
      last: 'Hoselton'
    },
    quest: 'to seek the Y combinator',
    color: 'blue'
  }

  const description = ({name: {first, last}, quest, color}) =>
   `Sir ${last} is on a quest ${quest}`

  console.log(description(knight));

#+END_SRC

#+RESULTS:
: Sir Hoselton is on a quest to seek the Y combinator
: undefined

*** Linked Lists Revisited
**** Object Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const EMPTY = {};
  const oneTwoThree = { first: 1, 
                        rest: { 
                          first: 2,
                          rest: { 
                            first: 3, 
                            rest: EMPTY  
                          }
                        }
                      };

  console.log(oneTwoThree.first);
  console.log(oneTwoThree.rest);

#+END_SRC

#+RESULTS:
: 1
: { first: 2, rest: { first: 3, rest: {} } }

**** Length Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const EMPTY = {};
  const oneTwoThree = {first: 1, rest: {first: 2, rest: {first: 3, rest: EMPTY}}};

  const length = (node, counter = 0) =>
    node === EMPTY
      ? counter
      : length(node.rest, counter + 1)

  console.log(length(oneTwoThree));

#+END_SRC

#+RESULTS:
: 3

**** Slow Copy Example:
     
#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const EMPTY = {};
  const oneTwoThree = {first: 1, rest: {first: 2, rest: {first: 3, rest: EMPTY}}};

  const slowcopy = (node) => 
    node === EMPTY
      ? EMPTY
      : { first: node.first, rest: slowcopy(node.rest)};

  console.log(slowcopy(oneTwoThree));

#+END_SRC

#+RESULTS:
: { first: 1, rest: { first: 2, rest: { first: 3, rest: {} } } }

**** Reverse Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const EMPTY = {};
  const oneTwoThree = {first: 1, rest: {first: 2, rest: {first: 3, rest: EMPTY}}};

  const reverse = (node, delayed = EMPTY) => 
    node === EMPTY
      ? delayed
      : reverse(node.rest, {first: node.first, rest: delayed});

  console.log(reverse(oneTwoThree));

#+END_SRC

#+RESULTS:
: { first: 3, rest: { first: 2, rest: { first: 1, rest: {} } } }

**** reverseMap Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const EMPTY = {};
  const oneTwoThree = {first: 1, rest: {first: 2, rest: {first: 3, rest: EMPTY}}};

  const reverseMap = (fn, node, delayed = EMPTY) => 
    node === EMPTY
      ? delayed
      : reverseMap(fn, node.rest, {first: fn(node.first), rest: delayed});

  console.log(reverseMap((x) => x * x, oneTwoThree));

#+END_SRC

#+RESULTS:
: { first: 9, rest: { first: 4, rest: { first: 1, rest: {} } } }

**** Map Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const EMPTY = {};
  const oneTwoThree = {first: 1, rest: {first: 2, rest: {first: 3, rest: EMPTY}}};

  const reverse = (node, delayed = EMPTY) => 
    node === EMPTY
      ? delayed
      : reverse(node.rest, {first: node.first, rest: delayed});

  const map = (fn, node, delayed = EMPTY) => 
    node === EMPTY
      ? reverse(delayed)
      : map(fn, node.rest, {first: fn(node.first), rest: delayed});

  console.log(map((x) => x * x, oneTwoThree));

#+END_SRC

#+RESULTS:
: { first: 1, rest: { first: 4, rest: { first: 9, rest: {} } } }

**** Discussion:
     Our object based map function takes twice as long as straight iteration,
     because it iterates over the entire list twice: once to map and once to
     reverse the list. Likewise, it takes twice as much memory, because it
     constructs a reverse of the desired result before throwing it away.
       This is still much, much faster than making partial copies of arrays.  For a
     list of length n, we created n superfluous nodes and copied n superfluous
     values. Whereas out naive array algorithm created 2n superflous arrays and
     copied n^2 superfluous values.


** Mutation
   In JavaScript, almost every type of value can mutate: their binding stays the
   same, but their structure changes. For now, we'll focus on mutations with arrays
   and objects. 
     Just as you can access a value from within an array or object using bracket
   or dot notation, you can reassign a value using the same.
     Remember that we can assign two different bindings to the same value. For
   reference types, like objects, there is only ever one value. Each binding is
   merely an alias.
     JavaScript permits the reassignment of new values to existing bindings, as
   well as the reassignment and assignment of new values to elements of container
   such as arrays and objects. Mutating existing objects has special implications
   when two bindings are aliases of the same value.
     Note well that devlaring a variable const does not prevent us from mutating
   its value, only from rebinding its name. 
*** Mutation Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

  const allHallowsEve = [2012, 10, 31];
  (function (halloween) {
    halloween[0] = 2013;
  })(allHallowsEve);

  console.log(allHallowsEve);

#+END_SRC

#+RESULTS:
| 2013 | 10 | 31 |

*** moar simple mutation example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

  const allHallowsEve = [2012, 10, 31];
  const halloween = allHallowsEve;
  halloween[0] = 2013;
  console.log(allHallowsEve);

#+END_SRC

#+RESULTS:
| 2013 | 10 | 31 |

*** Mutation and Data Structures
    Generally, mutation makes some algorithms shorter to write and possibly
    faster, by conserving space. But mutation often makes a process harder to 
    reason about, as we then have to consider whether the mutations will cause
    unwanted side effects.
*** Building with Mutation
    One pattern many people follow is to be liberal with mutation when 
    constructing data, but conservative with mutation when consuming data.
      If we want to make a copy of a linked list without iterating over it twice
    and making a copy that will be gc'd later, we can use mutation. The following
    algorithm makes copies of nodes as it goes, and mutates the last node in the
    list so that it can splice the next one on.
**** Copy Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

  const copy = (node, head = null, tail = null) => {
    if (node === EMPTY) {
      return head; 
    } else if (tail === null) {
      const { first, rest } = node;
      const newNode = { first, rest };
      return copy(rest, newNode, newNode);
    } else {
      const { first, rest } = node;
      const newNode = { first, rest }; tail.rest = newNode;
      return copy(node.rest, head, newNode);
    }
  }

#+END_SRC

**** Map Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

const EMPTY = {};
const OneToFive = {first: 1,
                   rest: {
                     first: 2,
                     rest: {
                       first: 3,
                       rest: {
                         first: 4,
                         rest: {
                           first: 5,
                           rest: EMPTY }}}}};

  const mapWith = (fn, node, head = null, tail = null) => {
    if (node === EMPTY) {
      return head; 
    } else if (tail === null) {
      const { first, rest } = node;
      const newNode = { first: fn(first), rest };
      return mapWith(fn, rest, newNode, newNode);
    } else {
      const { first, rest } = node;
      const newNode = { first: fn(first), rest };
      tail.rest = newNode;
      return mapWith(fn, node.rest, head, newNode);
    }
  }

console.log(mapWith((x) => 1.0 / x, OneToFive));

#+END_SRC

#+RESULTS:
: { first: 1,
:   rest: 
:    { first: 0.5,
:      rest: { first: 0.3333333333333333, rest: [Object] } } }
: undefined


** Reassignment
   JavaScript does not permit us to rebind a name that has been bound with const.
   But, we can shadow it by using const to declare a new binding with a new
   function or block scope. And, we can rebind parameters bound in a function or
   with the let keyword.
*** let
    Like const, let names can be shadowed by bindings in local environments.
    Unlike const, let bindings can be rebound, assigned a different value in the
    same environment.
*** var
    JavaScript has one more way to bind a name to a value: var. Var is a lot like
    let, it can be reassigned. But instead of scoping to containing blocks, var 
    scopes to containing functions. 
      All var declarations are hoisted to the top of the function, a little like
    function declarations. But, remember that assignments are not hoisted, creating
    a temporal zone in which the name-binding exists but it's value is undefined.
*** why const and let were invented
    const and let first appeared in ES6. var's function scope caused confusion for
    those who didn't understand lexical scope. 
**** see YDKJS discussion of let and var in for loops


** Copy on Write
*** On Arrays and Linked Lists
    We used destructuring to access the ...rest of an array, in the form of a
    copy of that array, less its head. We have also used CDR and node.rest
    traversal to request the rest of a linked list, and recieve the nodes of
    the elements of the original list.
      The difference between the two is consequential, modifications to the ...rest
    of an array affect a copy of the original. Whereas modifications to the CDR of
    a list change the same nodes referred to by the list's head(s).
      This is remarkably unsafe: Only if we know that a list doesn't share any
    elements with another list can we can safely modify it.
**** Array Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const parentArray = [1, 2, 3];
  const [aFirst, ...childArray] = parentArray;

  parentArray[2] = "three";
  childArray[0] = "two";
 
  console.log(parentArray);
  console.log(childArray);
  
#+END_SRC

#+RESULTS:
: [ 1, 2, 'three' ]
: [ 'two', 3 ]

**** Linked List Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const EMPTY = { first: {}, rest: {} };
  const parentList = { first: 1, rest: { first: 2, rest: { first: 3, rest: EMPTY }}};
  const childList = parentList.rest;

  parentList.rest.rest.first = "three";
  childList.first = "two";
  
  console.log(parentList);
  console.log(childList);
  
#+END_SRC

#+RESULTS:
: { first: 1,
:   rest: { first: 'two', rest: { first: 'three', rest: [Object] } } }
: { first: 'two',
:   rest: { first: 'three', rest: { first: {}, rest: {} } } }

*** A few utilities for linked lists:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const copy = (node, head = null, tail = null) => { 
    if (node === EMPTY) {
      return head;
    } else if (tail === null) {
      const { first, rest } = node;
      const newNode = { first, rest };
      return copy(rest, newNode, newNode);
    } else {
      const { first, rest } = node;
      const newNode = { first, rest };
      tail.rest = newNode;
      return copy(node.rest, head, newNode);
    }
  }

  const first = ({first, rest}) => first;
  const rest = ({first, rest}) => rest;
  const EMPTY = {first: {}, rest: {}};
  
  const reverse = (node, delayed = EMPTY) => 
    node === EMPTY
      ? delayed
      : reverse(rest(node), { first: first(node), rest: delayed });

  const mapWith = (fn, node, delayed = EMPTY) =>
    node === EMPTY
      ? reverse(delayed)
      : mapWith(fn, rest(node), { first: fn(first(node)), rest: delayed });

  const at = (index, list) =>
    index === 0
      ? first(list)
      : at(index - 1, rest(list));

  const set = (index, value, list, originalList = list) =>
    index === 0
      ? (list.first = value, originalList)
      : set(index - 1, value, rest(list), originalList)
 
  const parentList = { first: 1, rest: { first: 2, rest: { first: 3, rest: EMPTY }}};
  const childList = rest(parentList);

  set(2, "three", parentList);
  set(0, "two", childList);

  console.log(parentList);
  console.log(childList);

#+END_SRC

#+RESULTS:
: { first: 1,
:   rest: { first: 'two', rest: { first: 'three', rest: [Object] } } }
: { first: 'two',
:   rest: { first: 'three', rest: { first: {}, rest: {} } } }

*** TODO Copy-on-read (code example doesn't reflect book, or scope of section)
    One strategy to avoid unwanted side-effects when mutating a linked list's node
    is to make a copy whenever we take the rest of a list.

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const copy = (node, head = null, tail = null) => { 
    if (node === EMPTY) {
      return head;
    } else if (tail === null) {
      const { first, rest } = node;
      const newNode = { first, rest };
      return copy(rest, newNode, newNode);
    } else {
      const { first, rest } = node;
      const newNode = { first, rest };
      tail.rest = newNode;
      return copy(node.rest, head, newNode);
    }
  }

  const first = ({first, rest}) => first;
  const EMPTY = {first: {}, rest: {}};
  
  const reverse = (node, delayed = EMPTY) => 
    node === EMPTY
      ? delayed
      : reverse(rest(node), { first: first(node), rest: delayed });

  const mapWith = (fn, node, delayed = EMPTY) =>
    node === EMPTY
      ? reverse(delayed)
      : mapWith(fn, rest(node), { first: fn(first(node)), rest: delayed });

  const at = (index, list) =>
    index === 0
      ? first(list)
      : at(index - 1, rest(list));

  const set = (index, value, list, originalList = list) =>
    index === 0
      ? (list.first = value, originalList)
      : set(index - 1, value, rest(list), originalList)
 
  const rest = ({first, rest}) => copy(rest);

  const parentList = { first: 1, rest: { first: 2, rest: { first: 3, rest: EMPTY }}};
  const childList = rest(parentList);

  const newParentList = set(2, "three", parentList);
  set(0, "two", childList);

  console.log(parentList);
  console.log(newParentList);
  console.log(childList);

#+END_SRC

#+RESULTS:
: { first: 1,
:   rest: { first: 2, rest: { first: 3, rest: [Object] } } }
: { first: 1,
:   rest: { first: 2, rest: { first: 3, rest: [Object] } } }
: { first: 'two',
:   rest: { first: 3, rest: { first: {}, rest: {} } } }

      This strategy is called "copy-on-read" because when we attempt to access the
    rest of a list, we automatically make a copy, in anticipation of subsequent
    mutation, to ensure that those mutations don't affect the parent list. 
      But, while effective at avoiding mutations to the parent, this technique is
    a costly prophylactic measure to take everytime we want the rest of a list.

*** Copy-on-write
    Instead of calling copy each time we take the rest of a list, we could only
    copy when we call set - until we are going to mutate state.

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output


  const rest = ({first, rest}) => rest;

  const EMPTY = {first: {}, rest: {}};

  const set = (index, value, list) =>
    index === 0
      ? { first: value, rest: list.rest }
      : { first: list.first, rest: set(index - 1, value, list.rest) };

  const parentList = { first: 1, rest: { first: 2, rest: { first: 3, rest: EMPTY }}};
  const childList = rest(parentList);

  const newParentList = set(2, "three", parentList);
  const newChildList = set(0, "two", childList);

  console.log(parentList);
  console.log(childList);

  console.log(newParentList);
  console.log(newChildList);

#+END_SRC

#+RESULTS:
: { first: 1,
:   rest: { first: 2, rest: { first: 3, rest: [Object] } } }
: { first: 2, rest: { first: 3, rest: { first: {}, rest: {} } } }
: { first: 1,
:   rest: { first: 2, rest: { first: 'three', rest: [Object] } } }
: { first: 'two',
:   rest: { first: 3, rest: { first: {}, rest: {} } } }

*** Tradeoffs
    Like all strategies, COW (copy-on-write) makes a tradeoff. It's much cheaper
    than copying structures when you make an infrequent number of small changes,
    but if you tend to make a lot of changes to some that you aren't sharing, it's
    more expensive.
      Note that the copy function doesn't COW. Instead it follows the pattern that
    while constructing something, we own it and can be liberal with mutation. Once
    we're done with it and give it to someone else, we need to be resume our more
    conservative approach to mutation, and implement a strategy like copy-on-read
    or copy-on-write.
    

** Tortises, Hares, and Teleporting Turtles


** Functional Iterators
*** Fold revisited
    Let's revisit folding. Remember that folding is a form of linear recursion.
    foldWith accepts a function, a terminal value, and a data structure. Fold allows
    us to the action that we wish to perform on the array (the function) from the
    process of traversing that array via linear recursion.   
*** callLeft, foldArrayWith, and arraySum Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
  const callLeft = (fn, ...args) =>
    (...remainingArgs) =>
      fn(...args, ...remainingArgs);

  const foldArrayWith = (fn, terminalValue, [first, ...rest]) =>
    first === undefined
      ? terminalValue
      : fn(first, foldArrayWith(fn, terminalValue, rest));

  const arraySum = callLeft(foldArrayWith, (a, b) => a + b, 0);
  
  console.log(arraySum([1, 4, 9, 16, 25]));

#+END_SRC

#+RESULTS:
: 55

*** Separating Concerns
    Our arraySum function mostly concerns itself with summing, but it relies on
    foldArrayWith, so it can only sum arrays. foldArray combines the traversal with
    arrays, a specific data structure. What if we want to sum trees? or linked
    lists? Let's make our code more modular by separating our summing function from
    the data-structure traversal process.
**** First, generalize our summing function for any foldable data structure.

 #+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

   const foldArray = (array) => callRight(foldArrayWith, array);
  
   const sumFoldable = (folder) => folder((a, b) => a + b, 0);

   sumFoldable(foldArray([1, 4, 9, 16, 25]));

 #+END_SRC

**** Second, implement a fold that works on tree structures

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const callRight = (fn, ...args) =>
    (...remainingArgs) =>
      fn(...remainingArgs, ...args);

  const foldTreeWith = (fn, terminalValue, [first, ...rest]) =>
    first === undefined
      ? terminalValue
      : Array.isArray(first)
        ? fn(foldTreeWith(fn, terminalValue, first),
                          foldTreeWith(fn, terminalValue, rest))
        : fn(first, foldTreeWith(fn, terminalValue, rest));

  const foldTree = (tree) => callRight(foldTreeWith, tree);
  
  const sumFoldable = (folder) => folder((a, b) => a + b, 0);

 console.log(sumFoldable(foldTree([1, [4, [9, 16]], 25])));

#+END_SRC

#+RESULTS:
: 55
      
*** Iterating
    Folds can do anything that for loops can do. What fold accomplished with linear
    recursion, for accomplishes with iteration (specific to arrays?). 
      We can also iterate with while loops, but we have to micro-manage the state
    of the iteration. We can internalize the state to array sum, as in the first
    example. And we can manage that state within a pojo, as in the second example.
    In the third example things get interesting, we can take the state of our
    iteration and move it into a stateful iterator function. And we can modify
    iterator function for other types of data structures - for lists our iterator
    holds the state of the current pair to determine wether the iterator is done.
**** while Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

  const arraySum = (array) => {
    let done;
    let sum = 0;
    let i = 0;
  
    while ((done = i == array.length, !done)) {
      const value = array[i++];
      sum += value;
    }

    return sum
  }
 
  console.log(arraySum([1, 4, 9, 16, 25]));

#+END_SRC

#+RESULTS:
: 55
: undefined

**** TODO we can represent out state with a pojo (err obj not declar in text):

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const arraySum = (array) => {
    let done;
    let sum = 0;
    let index = 0;
    let eachIteration = {};

    while ((eachIteration = { 
              done: index === array.length,
              value: index < array.length ? array[index] : undefined },
            ++index,
            !eachIteration.done)) {
              sum += eachIteration.value;
    }

    return sum;
  }

  console.log(arraySum([1, 4, 9, 16, 25]));

#+END_SRC

#+RESULTS:
: 55

**** we can extract the state keeping bits into an iterator function:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"
  const arrayIterator = (array) => {
    let i = 0;
    return () => {
      const done = i === array.length;
      return { done,
               value: done ? undefined : array[i++] }
    }
  }

  const iteratorSum = (iterator) => {
    let eachIteration, sum = 0;

    while ((eachIteration = iterator(), !eachIteration.done)) {
      sum += eachIteration.value;
    }

    return sum;  
  }

console.log(iteratorSum(arrayIterator([1, 4, 9, 16, 25])));

#+END_SRC

#+RESULTS:
: 55
: undefined

**** now iterators with lists
     
#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

  const EMPTY = null;
  
  const isEmpty = (node) =>
    node === EMPTY;

  const pair = (first, rest = EMPTY) =>
    ({first, rest});

  const list = (...elements) =>{
    const [first, ...rest] = elements;
    return elements.length === 0
      ? EMPTY
      : pair(first, list(...rest))
  }

  const print = (aPair) =>
    isEmpty(aPair)
      ? ""
      : `${aPair.first} ${print(aPair.rest)}`

  const listIterator = (aPair) =>
    () => {
      const done = isEmpty(aPair);
      if (done) {
        return {done};
      } else {
        const {first, rest} = aPair;
        aPair = aPair.rest;
        return { done, value: first }
      }
    }

  const iteratorSum = (iterator) => {
    let eachIteration;
    let sum = 0;
    
    while ((eachIteration = iterator(), !eachIteration.done)) {
      sum += eachIteration.value;
    }
    
    return sum
  }

  const aListIterator = listIterator(list(1, 4, 9, 16, 25)); 

  console.log(iteratorSum(aListIterator));

#+END_SRC

#+RESULTS:
: 55
: undefined

*** Unfolding and laziness
**** Iterators are functions.
     When they iterate over an array or linked list, they
     are traversing something that is already there. But they could just as easily
     manufacture data as they go.
**** FibonacciIterator Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

const fibIter = () => {
  let previous = 0;
  let current = 1;

  return () => {
    
    let value = previous;
    previous = current;
    current = value + previous;

    return {done: false, value}
  }

}

const infinifib = fibIter();

console.log(infinifib().value);
console.log(infinifib().value);
console.log(infinifib().value);
console.log(infinifib().value);
console.log(infinifib().value);
console.log(infinifib().value);
console.log(infinifib().value);
console.log(infinifib().value);

#+END_SRC

#+RESULTS:
: 0
: 1
: 1
: 2
: 3
: 5
: 8
: 13
**** unfold
     A function that starts with a seed and expands it into a data structure is
     called an unfold. It's possible to write a generic unfold mechanism, as we did
     with fold. 
**** Mapping an iterator Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const NumberIterator = (number = 0) =>
    () =>
      ({ done: false, value: number++ })

  const mapIteratorWith = (fn, iterator) => 
    () => {
      const {done, value} = iterator();
        return ({done, value: done ? undefined : fn(value)});
    }

  const squares = mapIteratorWith((x) => x * x, NumberIterator(1));

  console.log( squares().value);
  console.log( squares().value);
  console.log( squares().value);
  console.log( squares().value);

#+END_SRC

#+RESULTS:
: 1
: 4
: 9
: 16

**** taking from infinite iterators
     take is a function that accepts an iterator as an argument, and returns an
     iterator that only returns a fixed number of elements
**** take example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" results: output

const fibIter = () => {
  let previous = 0;
  let current = 1;

  return () => {
    
    let value = previous;
    previous = current;
    current = value + previous;

    return {done: false, value}
  }
}

  const take = (iterator, numberToTake) => {
    let count = 0;
    return () => {
      if (++count <= numberToTake) {
        return iterator();
      } else {
        return {done: true};
      }
    };
  };

  const toArray = (iterator) => {
    let eachIteration;
    let array = [];
    while ((eachIteration = iterator(), !eachIteration.done)) {
      array.push(eachIteration.value);
    }
    return array;
  }

  console.log(toArray(take(fibIter(), 5)));

#+END_SRC

#+RESULTS:
| 0 | 1 | 1 | 2 | 3 |

**** TODO take with filterIteratorWith

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const callLeft = (fn, ...args) =>
    (...remainingArgs) =>
      fn(...args, ...remainingArgs);

  const NumberIterator = (number = 0) =>
    () =>
      ({ done: false, value: number++ })

  const take = (iterator, numberToTake) => {
    let count = 0;
    return () => {
      if (++count <= numberToTake) {
        return iterator();
      } else {
        return {done: true};
      }
    };
  };

  const filterIteratorWith = (fn, iterator) =>
    () => {
      do {
        const {done, value} = iterator();
      } while (!done && !fn(value));
      return {done, value};
    }

  const toArray = (iterator) => {
    let eachIteration;
    let array = [];
    while ((eachIteration = iterator(), !eachIteration.done)) {
      array.push(eachIteration.value);
    }
    return array;
  }

  const mapIteratorWith = (fn, iterator) => 
    () => {
      const {done, value} = iterator();
        return ({done, value: done ? undefined : fn(value)});
    }

  const squareOf = callLeft(mapIteratorWith, (x) => x * x);

  const oddsOf = callLeft(filterIteratorWith, (n) => n % 2 === 1);

  console.log(toArray(take(squareOf(oddsOf(NumberIterator(1))), 5)));

#+END_SRC

#+RESULTS:

*** Bonus
    Many programmers coming to JavaScript from other languages are familiar with
    three canonical operations on collections: folding, filtering, and finding.
**** lazy find example:
     
#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const firstInIteration = (fn, iterator) =>
    take(filterIteratorWith(fn, iterator), 1);

#+END_SRC

**** eager find example

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const firstInArray = (fn, array) =>
    array.filter(fn)[0];

#+END_SRC

*** caveat - iterators are stateful
    Please note that unlike most of the other functions discusses in this book,
    iterators are stateful!. There are some important implications of stateful
    functions. One is that while functions like take(...) appear to create an
    entirely new iterator, in reality they return a decorated reference to the
    original iterator. So as you traverse the new decorator, you're changing the
    state of the original!
      Once you pass an iterator to a function, you can expect that you no longer
    "own" that iterator, and that its state has either changes or will change.


** Making Data Out Of Functions
*** The kestrel and the idiot
    A constant function is a function that alwaus returns the same thing, no
    matter what you give it. The kestrel, of K is a function that makes constant
    functions. The identity function is a function that evaluates to whatever
    parameter you pass it.
**** The kestrel

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

 const K = (x) => (y) => x;

 const fortyTwo = K(42);

 console.log(fortyTwo(6));

#+END_SRC

#+RESULTS:
: 42
: undefined

**** The idiot bird

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015"

 const I = (x) => x;

 const fortyTwo = I(42);

 console.log(fortyTwo);


#+END_SRC

#+RESULTS:
: 42
: undefined

**** K(I)
     Given two values, we can say that K always returns the first value.
     If the first value is I, then K(I) will always return the second value.

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const K = (x) => (y) => x;
  const I = (x) => x;

  const first = K;
  const second = K(I);

  console.log(first("primus")("secundus"));
  console.log(second("primus")("secundus"));

#+END_SRC

#+RESULTS:
: primus
: secundus

*** ignorance and backwardness
    Our K(I) example marks a different approach to functions that access data. We
    are used to functions knowing about the data they access (for example a
    function that destructures its arguments must know whether the arguments are
    arrays or objects.
      But the first and second we built out of K and I do not attempt to know about
    their data, they just faithfully return it in the same form it was provided. In
    order to use them with a two-element array, we'd need to have a piece of code
    that calls some code.
      We can create an intermediary function that delays the application of
    arguments to our first and second selector functions. This creates a data
    structure that is itself a function. Instead of passing our data to K or K(I),
    we can pass K or K(I) to our data structure function. This is exactly backwards
    of the way we write functions that operate on data.

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const K = (x) => (y) => x;
  const I = (x) => x;

  const first = K;
  const second = K(I);

  const latin = (selector) => selector("primus")("secundus");

  console.log(latin(first));
  console.log(latin(second));

#+END_SRC

#+RESULTS:
: primus
: secundus

*** the vireo
    Now that we have represented our data structure  as a function that accepts a
    selector and returns data, we can create a function that returns data
    structures.
      Our data structure is the function:
        (selector) => selector("primus")("secundus")
    To create such a data structure, we need to extract the data into parameters:
        (first, second) => (selector) => selector(first)(second)
    We can also curry the above so that each combinator only recieves one parameter
        (first) => (second) => (selector) => selector(first)(second)
    This is the V combinator, the vireo!
        (x) => (y) => (z) => z(x)(y)
    Armed with nothing more than K, I, and V, we can make a data structure that
    holds two values, the cons cell of LISP and the node of a linked list.

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const K = (x) => (y) => x;
  const I = (x) => x;
  const V = (x) => (y) => (z) => z(x)(y);

  const first = K;
  const second = K(I);
  const pair = V;

  const latin = pair("primus")("secundus");
  
  console.log(latin(first));
  console.log(latin(second));

#+END_SRC

#+RESULTS:
: primus
: secundus

*** lists with functions as data
    We can use pure functions to represent a linked list. In fact, anything that
    can be computed can be computed using functions and nothing else.

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const K = (x) => (y) => x;
  const I = (x) => x;
  const V = (x) => (y) => (z) => z(x)(y);
  const EMPTY = (() => {});

  const first = K;
  const rest = K(I);
  const pair = V;
  
  const l123 = pair(1)(pair(2)(pair(3)(EMPTY)));

  const length = (aPair) =>
    aPair === EMPTY
      ? 0
      : 1 + length(aPair(rest));

  const reverse = (aPair, delayed = EMPTY) =>
    aPair === EMPTY
      ? delayed
      : reverse(aPair(rest), pair(aPair(first))(delayed));

  const mapWith = (fn, aPair, delayed = EMPTY) =>
    aPair === EMPTY
      ? reverse(delayed)
      : mapWith(fn, aPair(rest), pair(fn(aPair(first)))(delayed));

  const doubled = mapWith((x) => x * 2, l123)

  console.log(l123(first), l123(rest)(first), (l123(rest)(rest)(first)));

  console.log(length(l123));

  console.log(doubled(first), doubled(rest)(first), doubled(rest)(rest)(first));

#+END_SRC

#+RESULTS:
: 1 2 3
: 3
: 2 4 6

*** say "please" - the ternary operator
    We keep using the same pattern in our functions: aPair === EMPTY ? this : that.
    This follows the philosophy we used with data structures: The function doing
    the work inspects the data structure.
      We can reverse this: Instead of asking a pair if it is empty and then
    deciding what to do, we can ask the pair to do it for us.
**** length and print with function based ternary Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const K = (x) => (y) => x;
  const I = (x) => x;
  const V = (x) => (y) => (z) => z(x)(y);

  const pairFirst = K;
  const pairRest = K(I);
  const pair = V;
 
  const first = (list) => 
    list(
      () => "ERROR: Can't take first of an empty list",
      (aPair) => aPair(pairFirst)
    );

  const rest  = (list) => 
    list(
      () => "ERROR: Can't take first of an empty list",
      (aPair) => aPair(pairRest)
    );

  const length = (list) => 
    list(
      () => 0,
      (aPair) => 1 + length(aPair(pairRest))
    );
  
  const print = (list) =>
    list(
      () => "EMPTYLIST",
      (aPair) => `${aPair(pairFirst)} ${print(aPair(pairRest))}`
    );

  const EMPTYLIST = (whenEmpty, unlessEmpty) => whenEmpty();

  const node = (x) =>
    (y) =>
      (whenEmpty, unlessEmpty) =>
        unlessEmpty(pair(x)(y));

  const l123 = node(1)(node(2)(node(3)(EMPTYLIST)));

  console.log(print(l123));
  console.log(length(l123));

#+END_SRC

#+RESULTS:
: 1 2 3 EMPTYLIST
: 3

**** reverse and map with function based ternary Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const K = (x) => (y) => x;
  const I = (x) => x;
  const V = (x) => (y) => (z) => z(x)(y);

  const pairFirst = K;
  const pairRest = K(I);
  const pair = V;
 
  const first = (list) => 
    list(() => "ERROR: Can't take first of an empty list",
         (aPair) => aPair(pairFirst));

  const rest  = (list) => 
    list(() => "ERROR: Can't take first of an empty list",
         (aPair) => aPair(pairRest));
  
  const print = (list) =>
    list(() => "EMPTYLIST",
         (aPair) => `${aPair(pairFirst)} ${print(aPair(pairRest))}`);

  const EMPTYLIST = (whenEmpty, unlessEmpty) => whenEmpty();

  const node = (x) =>
    (y) =>
      (whenEmpty, unlessEmpty) =>
        unlessEmpty(pair(x)(y));

  const l123 = node(1)(node(2)(node(3)(EMPTYLIST)));

  const reverse = (list, delayed = EMPTYLIST) => 
    list(() => delayed, (aPair) =>
      reverse(aPair(pairRest), node(aPair(pairFirst))(delayed)));

  const mapWith = (fn, list, delayed = EMPTYLIST) =>
    list(() => reverse(delayed),
         (aPair) => mapWith(fn, aPair(pairRest),
                    node(fn(aPair(pairFirst)))(delayed)));

  console.log(print(reverse(l123)));
  console.log(print(mapWith(x => x * x, reverse(l123))));

#+END_SRC

#+RESULTS:
: 3 2 1 EMPTYLIST
: 9 4 1 EMPTYLIST

*** functions are not the real point
    Functions are a fundamental building block of computation. They are axioms of
    combinatory logic, and can be used to compute anything that JavaScript can
    compute.
      But knowing how to make a linked list out of functions is not really
    necessary for the working programmer. Knowing that it can be done, on the
    other hand, is very important to understanding computer science.
*** a return to backward thinking
    To make pairs work, we did things backwards: We passed the first and rest
    functions to the pair, and the pair called our function. As it happened, the
    pair was composed by the Vireo (or V combinator): (x) => (y) => (z) => z(x)(y).
      But we cound have done something completely different. We could have written
    a pair that stored its elements in a POJO, or an array. All we know is that we
    can pass the pair function a function of our own, and it will be called with
    the elements of the pair. 
      The exact implementation of a pair is hidden from the code that uses a pair.
    The code that uses the data doesn't reach in and touch it: The code that uses
    the data provides some code and asks the data to do something with it. 

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const length = (list) => 
   list(() => 0,
        (aPair) => 1 + length(aPair(pairRest))
   );

  const length = (node, delayed = 0) =>
    node === EMPTY
      ? delayed
      : length(node.rest, delayed + 1);

#+END_SRC

    These two functions to compute the length of a list are fundamentally
    different. The line "node === empty" presumes that there is one canonical
    empty list value, and that you can compare things to it with the === operator.
    The function holds information about the structure of lists.
      Having a list know itself whether it is empty hides implementation
    information from the code that uses lists. This is a fundamental principle of
    good design. It is a tenent of Object-Oriented Programming, but it is not
    exclusive to OOP: We can and should design data structures to hide
    implementation information from the code that use them, whether we are working
    with functions, objects, or both.
      There are many tools for hiding implementation inforamtion, and we have now
    seen two particularly powerful patterns:
      1. Instead of directly manipulating part of an entity, pass it a function and
         have it call our function with the part we want.
      2. Instead of testing some property of an entity and making a choide of our
         own with ?: or if, pass the entity the work we want done for each case
         and let it test itself.


* Recipes with Data
** mapWith
   mapWith differs from the native JavaScript .map array method by reversing the 
   arguments - putting the function first, and then curring the function. Note
   that we could do the same thing with callRight.

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const mapWith = (fn) => 
    (list) => list.map(fn);

  const squaresOf = mapWith(n => n * n); 

  console.log(squaresOf([1, 2, 3, 4, 5]));

#+END_SRC

#+RESULTS:
: [ 1, 4, 9, 16, 25 ]

** Flip
   Flip takes a function that accepts two arguments, and flips the order of those
   arguments. 
*** flip Recipe:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const flip = (fn) =>
    (first, second) => fn(second, first);

#+END_SRC

*** flipAndCurry Recipe:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const flipAndCurry = (fn) =>
    (first) => (second) => fn(second, first);

#+END_SRC

*** self currying flip Recipe:
    
#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const flip = (fn) => 
    function (first, second) {
      if (arguments.length === 2) { 
        return fn(second, first);
      } else {
        return function (second) { 
          return fn(second, first);
        };
      };
    };

#+END_SRC

*** flipping for methods Recipes:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const flipAndCurry = (fn) => 
  (first) =>
    function (second) {
      return fn.call(this, second, first);
    }

  const flip = (fn) =>
    function (first, second) {
      return fn.call(this, second, first);
    }

  const flip = (fn) => 
    function (first, second) {
      if (arguments.length === 2) { 
        return fn.call(this, second, first);
      } else {
        return function (second) { 
          return fn.call(this, second, first);
        };
      };
    };

#+END_SRC

** Object.assign
   It's common to want to "extend" an object by assigning properties to it that
   already exist on another object. THis is a building block for "mixins."
     Object.assign makes this easy. You can copy an object by extending an empty
   object, you can extend one object (or object prototype) with another, and
   create defaults for objects to be returned from constructor functions.
*** Object.assign Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const inventory = { apples: 12, oranges: 12};
  const inventoryCopy = Object.assign({}, inventory);

  console.log(inventoryCopy);
  
  const shipment = {bananas: 54, pears: 24};
  Object.assign(inventory, shipment);

  console.log(inventory);
  console.log(inventoryCopy);

#+END_SRC

#+RESULTS:
: { apples: 12, oranges: 12 }
: { apples: 12, oranges: 12, bananas: 54, pears: 24 }
: { apples: 12, oranges: 12 }

** Why?
  
 The Y combinator:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const Y = (f) =>
  ( x => f(v => x(x)(v)) )
  ( x => f(v => x(x)(v)) );

  const factorial = Y(function (fac) { 
    return function (n) {
      return (n == 0 ? 1 : n * fac(n - 1)); }
    });

  console.log(factorial(5));

#+END_SRC

#+RESULTS:
: 120

  Here's my guide to the y-combinator!

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  // First I present the Y combinator:

  const Y = (f) =>
  ( x => f(v => x(x)(v)) )
  ( x => f(v => x(x)(v)) );

  // Next, a function to pass to the Y combinator
  // It's nothing fancy, just a function to compute factorials
  // It's interesting to note that it returns a function
  // that returns a ternary expression, reminiscent of linear recursion

  const factorial = Y(function (fac) { 
    return function (n) {
      return (n == 0 ? 1 : n * fac(n - 1)); }
    });

  // 

  factorial(5);

  // Let the substitution begin!
  // First I'll substitute function where its called.

  (Y(function (fac) {
    return function (n) {
      return (n == 0 ? 1 : n * fac(n - 1)); }
    }))(5)

  // Now, to substitute in the Y combinator
  
  (((f) =>
    ( x => f(v => x(x)(v)) )
    ( x => f(v => x(x)(v)) ))
   (function (fac) {
    return function (n) {
      return (n == 0 ? 1 : n * fac(n - 1)); }
    }))(5)

 // My, my, my, my, my. what a mess
 // lets apply our function to the combinator
 // and see if we can't clean this up

  (( x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })
   ( x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); }))(5)
   
 // Well, it does look more orderly. But I fear we'll just make a mess of it again.
 // Now to apply the inner functions to each other.
 // Hopefully this will return a function to which we can apply 5...

  (n => { 
    return (
      n == 0
        ? 1 
        : n * (v => (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })
                    (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })(v)
              )(n - 1)
    ); 
  })(5)

  // Ok, I just ran the above and got the same answer.
  // So, I'm going to proceed as if I haven't make any substitution errors.
  // Let's begin to evaluate our function!
  // First, we pass 5 to our function, binding 5 to n
  // n !== 0 so we're left with


  (5 * (v => (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })
             (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })(v)
       )(4));

  // AKA

  (5 * ((x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })
        (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })(4)));

  // Can you see where this is going?
  // If the ternary embedded in the function didn't tip you off...
  // This should definitely smell like linear recursion at this point!
  // We've got a starting value that looks like it's the beginning of a deffered computation;
  // And we're about to apply its decrement to a function that looks suspiciously similar to 
  // the Y combinator that we started with.

  // Enough talking. Substitute!
 
  (5 * (n => {
         return (
           n == 0
             ? 1
             : n * (v => (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })
                         (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })
                         (v)
                   )(n - 1)
         );
       })(4));

  // 4 !== 0
  // Again! Again!

  (5 * 4 * (v => (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })
                 (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })(v)
           )(3));

  // Simpler! Simpler!

  (5 * 4 * ((x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })
            (x => n => { return (n == 0 ? 1 : n * (v => x(x)(v))(n - 1)); })(3)));

  // Whew! That's tiring. I'm going to stop here. I think we all get the idea...
  // So what's going on, there seems to be dinstinct behavior for three pieces
  // First, X has no interaction with our factorial function. 
  // Second, V serves as a means to pass the decrement of the original input to
  // the next recursion. In this way it balances n => in our factorial function
  // Third, the factorial function 


#+END_SRC


* A Warm Cup: Basic Strings

** quasi-literals
** evaluation time


* Stir the Allonge: Objects and State
  Thus far, we have avoided objects that are meant to be changed, objects that
  model state. It's time to change that.
** Encapsulating State with Closures (Making a Stack)
*** What is hiding of state-process, and why does it matter?
    Stacks are data structures. We can interact with a stack using three basic 
    operations:
      1. Pushing a value onto the top (push)
      2. popping a value off the top (pop)
      3. and testing to see whether the stack is empty or not (isEmpty)
    These basic operations are the stable interface.
      A stack could use an array to hold its contents, or a linked list. You might
    need an index, you might not. These design choices are often driven by
    performance considerations.
      But once you decide on an underlying implementation, you must also determine
    whether to expose implementation details. For example, if a stack uses an
    array behind the scenes, you have multiple options as to how a developer might
    determine the length of the stack. If the array index is exposed, the
    developer might use that directly. However, this makes changes to the
    implementation difficult, since code depends on the presence of an index. This
    dependency is called coupling. Alternately, the stack could have a size
    function, a new, stable operation, that continues to hide the underlying
    implementation.
      Hiding information (or "state") is the design principle that allows us to
    limit the coupling between components of software.
*** How do we hide state using JavaScript?
    Because objects' elements are mutable, we can use an object to model the state
    of our stack: an array and an index. Next can implement our three basic 
    operations as functions. And, because objects can store any value, we can
    bundle these functions with our state. Finally, our functions must be able to 
    refer to our stack's state. We can accomplish this by naming the object.
**** Stack via IIFE Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

const stack = (() => {
  const obj = {
    array: [],
    index: -1,
    push (value) {
      return obj.array[obj.index += 1] = value
    },
    pop () {
      const value = obj.array[obj.index];
      obj.array[obj.index] = undefined;
      if (obj.index >= 0) {
        obj.index -= 1
      }
    return value
    },
    isEmpty () {
      return obj.index < 0
    }
  };
  return obj;
})();

console.log(stack.isEmpty());
console.log(stack.push('hello'));
console.log(stack.push('JavaScript'));
console.log(stack.isEmpty());
console.log(stack.pop());
console.log(stack.pop());
console.log(stack.isEmpty());

#+END_SRC

#+RESULTS:
: true
: hello
: JavaScript
: false
: JavaScript
: hello
: true
       
*** Method-ology (What is a method?)
    This text takes the view that a function is a method of an object if it
    belongs to that object and interacts with that object in some way. So, the
    functions implementing the operations on the stack are all absolutely methods
    of the stack. 
*** Hiding State
    The previous stack example did not encapsulate its own state. Indeed, the IIFE
    is superfluous - an object literal would have been sufficient. But, the IIFE
    provides a closure that we can use for encapsulation.
      If we need more than one stack, we don't want to repeat our code, so let's
    also create a "stack maker." We could do this by wrapping our IIFE in a
    function wrapper that returns our IIFE that returns our stack object. But
    there's an easier way.
**** Stack via IIFE w/ encapsulation Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

const stack = (() => {
  const array = [];
  let index = -1;
  const obj = {
    push (value) {
      return array[index += 1] = value
    },
    pop () {
      const value = array[index];
      array[index] = undefined;
      if (index >= 0) {
        index -= 1
      }
    return value
    },
    isEmpty () {
      return index < 0
    }
  };
  return obj;
})();

console.log(stack.isEmpty());
console.log(stack.push('hello'));
console.log(stack.push('JavaScript'));
console.log(stack.isEmpty());
console.log(stack.pop());
console.log(stack.pop());
console.log(stack.isEmpty());

#+END_SRC

#+RESULTS:
: true
: hello
: JavaScript
: false
: JavaScript
: hello
: true

**** Stack Maker Function Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

const Stack = () => {
  const array = [];
  let index = -1;
  return {
    push (value) {
      return array[index += 1] = value
    },
    pop () {
      const value = array[index];
      array[index] = undefined;
      if (index >= 0) {
        index -= 1
      }
    return value
    },
    isEmpty () {
      return index < 0
    }
  };
};

const stack = Stack();
console.log(stack.isEmpty());
console.log(stack.push('hello'));
console.log(stack.push('JavaScript'));
console.log(stack.isEmpty());
console.log(stack.pop());
console.log(stack.pop());
console.log(stack.isEmpty());

#+END_SRC

#+RESULTS:
: true
: hello
: JavaScript
: false
: JavaScript
: hello
: true

*** Is encapsulation "object oriented"?
    We've built something with hidden internal state and "methods", all without
    needing special def or private keywords. Mind you, we haven't included all
    sorts of complicated mechanisms to support inheritance, mixins, and other
    opportunities for debating the nature of the One True Object-Oriented Style
    on the Internet.
      Then, again, the key lesson experienced programmers repeat - although it
    often falls on deaf ear - is favor composition over inheritance. So maybe we
    aren't missing much.
** Composition and Extensions
*** Composition
    A deeply fundamental practice is to build components out of smaller components.
    The choice of how to divide a component into smaller components is called
    factoring, after the operation in number theory. And, when you take an already
    factored component and rearrange things so that it is factored into a different
    set of subcomponents without altering its behavior, you are refactoring.
      The simplest and easiest way to build components out of smaller components in
    JavaScript is also the most obvious: Each component is a value, and the
    components can be put together into a single object or encapsulated with a
    closure.
      Here's an abstract model that supports undo and redo composed from a pair of
    stacks, and a POJO. We can get and set attributes on our model, and we can undo
    and redo our settings.
      The techniques used for encapsulation work well with composition. In this
    case, we have a "model" that hides its attribute store as well as its
    implementation that is composed of an undo stack and redo stack.
**** Model w/ undo/redo stacks Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const shallowCopy = (source) => {
    const dest = {};
    for (let key in source) {
      dest[key] = source[key]
    }
    return dest
  };

  const Stack = () => {
    const array = [];
    let index = -1;

    return {
      push (value) {
        array[index += 1] = value
      },
      pop () {
        let value = array[index];
        if (index >= 0) {
          index -= 1
        }
        return value
      },
      isEmpty () { return index < 0}
    }
};


  const Model = function (initialAttributes) {
    let attributes = shallowCopy(initialAttributes || {});
    const redoStack = Stack();
    const undoStack = Stack();
    const obj = {
      set: (attrsToSet) => {
        undoStack.push(shallowCopy(attributes));
        if (!redoStack.isEmpty()) {
            redoStack.length = 0;
        }
        for (let key in (attrsToSet || {})) {
          attributes[key] = attrsToSet[key]
        }
        return obj
      },
      undo: () => {
        if (!undoStack.isEmpty()) {
          redoStack.push(shallowCopy(attributes));
          attributes = undoStack.pop()
        }
        return obj
      },
      redo: () => {
        if (!redoStack.isEmpty()) {
          undoStack.push(shallowCopy(attributes));
          attributes = redoStack.pop()
        }
        return obj
      },
      get: (key) => attributes[key],
      has: (key) => attributes.hasOwnProperty(key),
      attributes: () => shallowCopy(attributes)
    };
    return obj
  };

  const model = Model();
  model.set({"Doctor": "de Grasse"});
  model.set({"Doctor": "Who"});
  model.undo();
  console.log(model.get("Doctor"));
  model.redo();
  console.log(model.get("Doctor"));

#+END_SRC

#+RESULTS:
: de Grasse
: Who

*** Extension
    Another practice that many people consider fundamental is to extend an
    implementation. Meaning, they wish to define a new data structure in terms of
    adding new operations and semantics to an existing data structure.
      If we create a queue data structure we might initially create operations to
    pushTail and pullHead. But we might later wish to add operations to pullTail
    and pushHead. To modify our queue, it cannot be encapsulated.
      The design goals of encapsulation and extension exist in a natural state of
    tension. A program with elaborate encapsulation resists breakage but can also
    be difficult to refactor in other ways. Be mindful of when it's best to
    Compose and when it's best to Extend.
**** Encapsulated Queue Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const Queue = () => {
    let array = [];
    let head = 0;
    let tail = -1;
    return {
      pushTail: (value) => array[++tail] = value,
      pullHead: () => {
        if (tail >= head) {
          const value = array[head];
          array[head] = undefined;
          ++head;
          return value
        }
      },
      isEmpty: () => tail < head
    }
  };

  const queue = Queue();
  queue.pushTail("Hello");
  queue.pushTail("JavaScript");
  queue.pushTail("Allongé");
  console.log(queue.pullHead());
  console.log(queue.pullHead());

#+END_SRC

#+RESULTS:
: Hello
: JavaScript

**** De-Encapsulated Queue Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const Queue = function () {
    const queue = {
      array : [],
      head : 0,
      tail : -1,
      pushTail: (value) => queue.array[++queue.tail] = value,
      pullHead: () => {
        if (queue.tail >= queue.head) {
          const value = queue.array[queue.head];
          queue.array[queue.head] = undefined;
          ++queue.head;
          return value
        }
      },
      isEmpty: () => queue.tail < queue.head
    }
    return queue;
  };

  const queue = Queue();
  queue.pushTail("Hello");
  queue.pushTail("JavaScript");
  queue.pushTail("Allongé");
  console.log(queue.pullHead());
  console.log(queue.pullHead());

#+END_SRC

#+RESULTS:
: Hello
: JavaScript

**** Extending a Queue to a Deque Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const Queue = function () {
    const queue = {
      array : [],
      head : 0,
      tail : -1,
      pushTail: (value) => queue.array[++queue.tail] = value,
      pullHead: () => {
        if (queue.tail >= queue.head) {
          const value = queue.array[queue.head];
          queue.array[queue.head] = undefined;
          ++queue.head;
          return value
        }
      },
      isEmpty: () => queue.tail < queue.head,
      expose: () => ({
        array: queue.array,
        head: queue.head,
        tail: queue.tail
      })
    }
    return queue;
  };

  const Dequeue = function () {
    const deque = Queue();
    let increment = 0;
    return Object.assign(deque, {
      size: () => deque.tail - deque.head + 1,
      pullTail: () => {
        if (!deque.isEmpty()) {
          const value = deque.array[deque.tail];
          deque.array[deque.tail] = undefined;
          deque.tail -= 1;
          return value;
        }
      },
      pushHead: (value) => {
        if (deque.head === 0) {
          increment = deque.tail - deque.head;
          for (let i = deque.tail; i >= deque.head; i--) {
            deque.array[i + increment] = deque.array[i];
          }
          deque.tail += increment;
          deque.head += increment;
        }
        return deque.array[deque.head -= 1] = value;
      }
    })
  };

  const dequeue = Dequeue();
  dequeue.pushTail("Hello");
  dequeue.pushTail("JavaScript");
  dequeue.pushHead("Allongé");
  console.log(dequeue.pullTail());
  console.log(dequeue.pullHead());
  console.log(dequeue.pullTail());

#+END_SRC

#+RESULTS:
: JavaScript
: Allongé
: Hello

** This and That
   If we use Object.assign to copy a queue, it will return a queue that references
   the state of the original queue. Because objects hold values by reference, the
   queue copy has access to the same environment enclosed during the creation of the
   first queue.
     This is a general issue with closures. Closures couple functions to
   environments, and that makes them very elegant in the small, and very handy for
   making opaque data structures. Alas, their strength in the small is their
   weakness in the large. When you're trying to make reusable components, this
   coupling is sometimes a hindrance.
     However, we could create a queue with amnesia - a queue with methods that
   must be passed an environment on which to operate. The drawback to such an
   approach is that we have to make sure we're always passing the currect queue in
   every time we invoke a function...
**** TODO (const in for loop) copyOfQueue Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" results: output

  const Queue = () => {
    const queue = {
      array: [],
      head: 0,
      tail: -1,
       pushTail (value) {
         return queue.array[++queue.tail] = value
       },
       pullHead () {
         if (queue.tail >= queue.head) {
           const value = queue.array[queue.head];
           queue.array[queue.head] = undefined;
           queue.head += 1;
           return value
         }
       },
       isEmpty () {
         return queue.tail < queue.head;
       }
     };
     return queue
   };

  const queue = Queue();
  queue.pushTail('Hello');
  queue.pushTail('JavaScript');
  const copyOfQueue = Object.assign({}, queue);

  console.log(queue !== copyOfQueue);

  copyOfQueue.array = [];
  for (let i = 0; i < 2; ++i) {
    copyOfQueue.array[i] = queue.array[i]
  }

  console.log(queue.pullHead());
  console.log(copyOfQueue.pullHead());

#+END_SRC

#+RESULTS:
: true
: Hello
: JavaScript
: undefined

**** queueWithAmnesia Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" results: output

  const AmnesiacQueue = () => ({
    array: [],
    head: 0,
    tail: -1,
    pushTail (myself, value) {
      return myself.array[myself.tail += 1] = value
    },
    pullHead (myself) {
      if (myself.tail >= myself.head) {
        let value = myself.array[myself.head];
        myself.array[myself.head] = void 0;
        myself.head += 1;
        return value;
      }
    },
    isEmpty (myself) {
      return myself.tail < myself.head;
    }
  });

  const queueWithAmnesia = AmnesiacQueue();

  queueWithAmnesia.pushTail(queueWithAmnesia, 'Hello');
  queueWithAmnesia.pushTail(queueWithAmnesia, 'JavaScript');

  const queueWithAmnesiaToo = Object.assign({}, queueWithAmnesia);

  queueWithAmnesiaToo.array = [];
  for (let i = 0; i < 2; ++i) {
    queueWithAmnesiaToo.array[i] = queueWithAmnesia.array[i]
  }

  console.log(queueWithAmnesia.pullHead(queueWithAmnesia));
  console.log(queueWithAmnesia.pullHead(queueWithAmnesiaToo));

#+END_SRC

#+RESULTS:
: Hello
: Hello
: undefined

*** TODO what's all this ?
    When we write a function expression using the compact method syntax (or use the
    function keyword instead of the fat arrow), and then invoke that function using
    . notation, JavaScript binds the "receiver" of the "method invocation" to the
    special name this.
      Our AmnesiacQueue uses compact method notation, and we can replace the method
    parameter -myself- with -this- within the body of each function. Now, when we
    invoke the functions we've bound to pushTail and pullHead, JavaScript will
    automatically bind betterQueue to the name this within those methods.
      Every time you invoke a function that is a member of an object, javaScript
    binds that object to the name this in the environment of the function just as if
    it were an argument.
      This allows us to copy arrays. By getting rid of the closure and taking
    advantage of -this-, we have functions that are more easily portable between
    objects, and the code is simples as wel. This is very important. Being able to
    copy objects is an example of a larger concern: Being able to share functions
    between objects. That's how classes work. That's how extending objects works.
    Being able to share functions means being able to compose and reuse
    functionality.
      Closures tightly couple functions to the environments where they are created,
    limiting their flexibility. Using -this- alleviates the coupling. Copying
    objects is but one example of where that flexibility is needed. 
**** BetterQueue with -this- Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" results: output

  const BetterQueue = () => ({
    array: [],
    head: 0,
    tail: -1,
    pushTail (value) {
      return this.array[this.tail += 1] = value
    },
    pullHead () {
      if (this.tail >= this.head) {
        let value = this.array[this.head];
        this.array[this.head] = void 0;
        this.head += 1;
        return value;
      }
    },
    isEmpty () {
      return this.tail < this.head;
    }
  });

  const betterQueue = BetterQueue();
  betterQueue.pushTail('Hello');
  betterQueue.pushTail('JavaScript');

  const copyOfQueue = Object.assign({}, betterQueue);

  copyOfQueue.array = [];
  for (let i = 0; i < 2; ++i) {
    copyOfQueue.array[i] = betterQueue.array[i]
  }

  console.log(betterQueue.pullHead());
  console.log(copyOfQueue.pullHead());

#+END_SRC

#+RESULTS:

** What Context Applies When We Call a Function
   In this and that, we learned that when a function is denoted using the function
   keyword, and is called as an object method, the name this is bound in its
   environment to the object acting as a "reciever."
     We could thus construct a method that returns whatever value is bound to -this-
   and compare it to the object that references that method.
**** -this- self reference Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const someObject = {
    returnMyThis () {
      return this;
    }
  };

  console.log(someObject.returnMyThis() === someObject);

#+END_SRC

#+RESULTS:
: true

*** TODO it's all about the way the function is called
    JavaScript programmers talk about functions having a "context" when called.
    -this- is bound to the context. The important thing to understand is that the
    context for a function being called is set by the way the function is called,
    not the function itself. 
      This is an important distinction. Consider closures: A function's free
    variables are resolved by looking them up in their enclosing functions'
    environments. You can always determine the functions that define free variables
    by examining the source code of a JavaScript program, which is why this scheme
    is known as Lexical Scope.
      However, a function's context cannot be determined by examining the source
    code of a JavaScript program.
!!!!! I really don't like that reasoning. You must be able to determine a function's
    context based upon an examination of the source code. If you could not, how
    could the compiler? The compiler creates a function's context each time the
    source code invokes that function. Thus, you can certaintly examine the source
    code for function invocations, and determine what the function's context will be
    based upon the circumstances of the invocation. The important distinction is
    that function declarations can only have one lexical scope. But a function can
    have multiple execution contexts, because you can invoke a function more than
    once. 
      The following example demonstrates that when you call a function with . or []
    notation, the function's execution context is the object on which the access
    notation operates. Otherwise, you get the global environment.
**** global -this- and shared method -this- Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const global = this;

  const someObject = { 
    someFunction () {
      return this;
    }
  };

  const someFunction = someObject.someFunction;
  console.log(someFunction() === someObject);
  console.log(someFunction() === global);

  const anotherObject = {
    someFunction: someObject.someFunction
  }
  console.log(anotherObject.someFunction() === anotherObject);
  console.log(anotherObject.someFunction() === someObject);

#+END_SRC

#+RESULTS:
: false
: true
: true
: false


#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const global = this;

  const someObject = { 
    someFunction () {
      return this;
    }
  };

  const someFunction = someObject.someFunction;
  console.log(someFunction() === someObject);
  console.log(someFunction() === global);

  const anotherObject = {
    someFunction: someObject.someFunction
  }
  console.log(anotherObject.someFunction() === anotherObject);
  console.log(anotherObject.someFunction() === someObject);

#+END_SRC

*** setting your own context using call
    There are actually two other ways to set the context of a function. And, once
    again, both are determined by the caller. At the end of "objects everywhere?"
    we'll see that everything in JavaScript behaves like an object, including
    functions. We'll learn that functions have methods themselves, and one of them
    is -call-.
      When you call a function with -call-, you set the context by passing it in as
    the first parameter. Other arguments are passed to the function in the normal
    manner. Much hilatiry can result from -call- shenanigans:
**** -call- shenanigans

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const a = [1,2,3], b = [4,5,6];
  console.log(a.concat([2,1]));
  console.log(a.concat.call(b,[2,1]));

#+END_SRC

#+RESULTS:
: [ 1, 2, 3, 2, 1 ]
: [ 4, 5, 6, 2, 1 ]

*** arguments
    JavaScript has another binding in every function's environment. -arguments- is a
    special object that references a handful of array-like methods and permits
    element access using bracket notation.
      Gathering arguments with the spread operator ... accomplished most of the use
    cases people have for using the arguments special binding, and in addition, 
    gathering works with both fat arrows and with the function keyword, whereas
    -arguments- only works with the function keyword.
      There are a few things that -arguments- can do that gathering cannot. For
    example, arguments holds every argument passed to a function, regardless of
    whether the function signature contains a parameter for that argument. This,
    -arguments- works alongside a function's declared parameters.
*** application
    JavaScript also provides a fourth way to set the context for a function. .apply
    is a method implemented by every function that takes a context as its first
    argument, and it takes an array or array-like thing of arguments as its second
    argument.
**** .call and .apply example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const array = [1,2,3,4,5];

  const third = function () { 
    return arguments[2]
  }

  console.log(third(...array));
  console.log(third.call(this, ...array));
  console.log(third.apply(this, array));

#+END_SRC

#+RESULTS:
: 3
: 3
: 3

*** TODO contextualization
    The apply and call methods both take a context as the first parameter, and
    function arguments as the remaining parameters. We can write a utilitiy that
    partially applies the .apply method.
      Our contextualize function returns a new function that calls a function with
    a fixed context.
**** TODO un-travesty 209

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const a = [1,2,3];
  const accrete = (x) => a.concat(x);
  console.log(accrete([4,5]));

#+END_SRC

#+RESULTS:
: [ 1, 2, 3, 4, 5 ]

**** contextualize Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const a = [1,2,3];

  const contextualize = (fn, context) => 
    (...args) =>
      fn.apply(context, args)

  const accrete2 = contextualize(a.concat, a);
  console.log(accrete2([4,5]));

#+END_SRC

#+RESULTS:
: [ 1, 2, 3, 4, 5 ]

**** contextualize and uncontextualize Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const contextualize = (fn, context) => 
    (...args) =>
      fn.apply(context, args)

  var aFourthObject = {};
  var returnThis = function () { return this; };

  aFourthObject.uncontextualized = returnThis;
  aFourthObject.contextualized = contextualize(returnThis, aFourthObject);
  
  console.log(aFourthObject.uncontextualized() === aFourthObject);
  console.log(aFourthObject.contextualized() === aFourthObject);

  // but

  var uncontextualized = aFourthObject.uncontextualized;
  var contextualized = aFourthObject.contextualized;
  console.log(uncontextualized() === aFourthObject);
  console.log(contextualized() === aFourthObject);

#+END_SRC

#+RESULTS:
: true
: true
: false
: true

** Method Decorators
   In function decorators, we learned that a decorator takes a function as an
   argument, returns a function, and there's a semantic relationship between the
   two. If a function is a verb, a decorator is an adverb.
     Decorators can be used to decorate methods provided that they carefully
   preserve the function's context. As long as we are correctly preserving -this-
   by 
     1. using a function keyword, and
     2. invoking the decorated function with .call(this, ...) or .apply(this, ...)
   we can decorate methods as well as functions. 
     Unfortunately, using .call or .apply is substantially slower than writing
   function decorators that aren't usable as method decorators. However, in practice
   you're far more likely to introduce a defect by failing to pass the context
   through a decorator than by introducing a performance pessimization, so the
   default choice should be to write all function decorators in such a way that
   they are "context agnostic."
     In some cases, there are other considerations to writing a method decorator. If
   the decorator introduces state of any kind (such as once and memoize do), this
   must be carefully managed for the case whenseveral objects share the same method
   through the mechanism of the prototype or through sharing references to the same
   function.
*** DONE a-contextual function decorator Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const maybe = (fn) =>
    x => 
      x != null ? fn(x) : x;

const plus1 = x => x + 1;
  console.log(plus1(1));
  console.log(plus1(0));
  console.log(plus1(null));
  console.log(plus1(undefined));  // returns NaN not null

  const maybePlus1 = maybe(plus1);
  console.log(maybePlus1(1));
  console.log(maybePlus1(0));
  console.log(maybePlus1(null));
  console.log(maybePlus1(undefined));

#+END_SRC

#+RESULTS:
: 2
: 1
: 1
: NaN
: 2
: 1
: null
: undefined

*** context sensitive function decorator Example:

 #+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output
 
  const maybe = (fn) =>
    function (x) {
      return x != null ? fn.call(this, x) : x;
    };

 #+END_SRC

*** csfd(above) with variadic functions and methods Recipe:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const maybe = (fn) =>
    function (...args) {
      for (const i in args) {
        if (args[i] == null) return args[i];
      }
    return fn.apply(this, args);
  };


#+END_SRC

*** method decorator Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const maybe = (fn) =>
    function (x) {
      return x != null ? fn.call(this, x) : x;
    };

  const someObject = {
    setSize: maybe(function (size) {
      this.size = size;
    })
  };

  someObject.setSize(5);
  console.log(someObject);

  someObject.setSize(null);
  console.log(someObject);

#+END_SRC

#+RESULTS:
: { setSize: [Function], size: 5 }
: { setSize: [Function], size: 5 }

** Summary
*** State can be encapsulated/hidden/privatized with closures
*** Encapsulations can be aggregated with composition
*** Encapsulation resists extension
*** The automatic binding -this- facilitates sharing of functions
*** Functions can be named and declared with a name


* Recipes with Objects, Mutations, and State
** Memoize
   Sometimes our algorithms or programs end up calculating the same results over and
   over again. Consider a function that computes the fibonacci sequence using a
   recursive process (we won't use a named function expression intentionally). See
   below on memoizing recursive functions. Each time the process recurs, it
   performs mirror calculations in a tree.
     We could rearrange the computation to avoid this, but we can instead trade
   space for time. What we want to do is use a lookup table. Whenever we want a
   result, we first look it up. If we don't have it, we calculate it and write the
   result in the table to use in the future. If we do have the result, we return
   the result without recalculating it.
     We can apply memoized to a function and we will get back a new function that
   "memoizes" its results so that it never has to recalculate the same value twice.
   It only works for functions that are "idempotent," meaning functions that always
   return the same result given the same argument(s).
*** recursive fibonacci:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const fibonacci = (n) =>
    n < 2
      ? n
      : fibonacci(n-2) + fibonacci(n-1);

  console.log([0,1,2,3,4,5,6,7,8].map(fibonacci));
  //console.log(fibonacci(45)); very slow

#+END_SRC

#+RESULTS:
: [ 0, 1, 1, 2, 3, 5, 8, 13, 21 ]
: 1134903170
  
*** memoize Recipe:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :tangle yes

  const memoized = (fn) => {
    const lookupTable = {};
    return function (...args) {
      const key = JSON.stringify(this, args);
      return lookupTable[key] || (lookupTable[key] = fn.apply(this, args));
    }
  }

#+END_SRC

*** DONE memo and fibonacci Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const memoized = (fn) => {
    const lookupTable = {};
    return function (...args) {
      const key = JSON.stringify.apply(this, args); //why this w/o apply in book?
      return lookupTable[key] || (lookupTable[key] = fn.apply(this, args));
    }
  }

  const fastFibonacci = memoized(
    (n) =>
      n < 2
        ? n
        : fastFibonacci(n-2) + fastFibonacci(n-1)
  );

  console.log(fastFibonacci(45));

#+END_SRC

#+RESULTS:
: 1134903170

*** DONE memoizing recursive functions (ackward language, functional expressions?)
    We deliberately picked a recursive function to memoize, because it demonstrates
    a pitfall when combining decorators with named function expressions. In the code
    example below, the function bound to the name fibonacci in the other environment
    has been memoized, but the named function expression binds the name fibonacci
    inside the unmemoized function, so none of the recursive calls to fibonacci are
    ever memoized.
**** broken memoFib (it's slow!) Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const memoized = (fn) => {
    const lookupTable = {};
    return function (...args) {
      const key = JSON.stringify.apply(this, args); //why this w/o apply in book?
      return lookupTable[key] || (lookupTable[key] = fn.apply(this, args));
    }
  }

  var fibonacci = memoized( function fibonacci (n) {
    if (n < 2) {
      return n
    } else {
      return fibonacci(n-2) + fibonacci(n-1)
    }
  });

  console.log(fibonacci(45)); //it's slow!

#+END_SRC

#+RESULTS:
: 1134903170

**** better memoFib (it's fast!) Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const memoized = (fn) => {
    const lookupTable = {};
    return function (...args) {
      const key = JSON.stringify.apply(this, args); //why this w/o apply in book?
      return lookupTable[key] || (lookupTable[key] = fn.apply(this, args));
    }
  }

  var fibonacci = memoized( function (n) {
    if (n < 2) {
      return n
    } else {
      return fibonacci(n-2) + fibonacci(n-1)
    }
  });

console.log(fibonacci(45)); // its fast!

#+END_SRC

#+RESULTS:
: 1134903170

** getWith
   getWith is a very simple function. It takes the name of an attribute and returns
   a function that extracts the value of that attribute from an object.
*** getWith Recipe:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :tangle yes

  const getWith = (attr) => (object) => object[attr];

#+END_SRC

*** simple getWith Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const getWith = (attr) => (object) => object[attr]

  const inventory = { apples: 0, oranges: 144, eggs: 36 };

  console.log(getWith('oranges')(inventory));

#+END_SRC

#+RESULTS:
: 144
: undefined

*** mapWith(getWith Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const getWith = (attr) => (object) => object[attr];

  const mapWith = (fn) => 
    (list) => list.map(fn);

  const inventories = [
{ apples: 0, oranges: 144, eggs: 36 }, { apples: 240, oranges: 54, eggs: 12 }, { apples: 24, oranges: 12, eggs: 42 }
];

  console.log(mapWith(getWith('oranges'))(inventories));

#+END_SRC

#+RESULTS:
: [ 144, null, 12 ]

*** mapWith(maybe(getWith Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const getWith = (attr) => (object) => object[attr];

  const mapWith = (fn) => 
    (list) => list.map(fn);

  const maybe = (fn) =>
    x => 
      x != null ? fn(x) : x;

  const inventories = [
{ apples: 0, oranges: 144, eggs: 36 }, { apples: 240, oranges: null, eggs: 12 }, { apples: 24, oranges: 12, eggs: 42 }
];

  console.log(mapWith(maybe(getWith('oranges')))(inventories));

#+END_SRC

#+RESULTS:
: [ 144, undefined, 12 ]

*** what's in a name?
    Why use a function instead of just using bracket notation for access? We can
    manipulate functions in ways that we can't manipulate syntax. For example, do
    you remember from flip that we can define mapWith from map?
    
    var mapWith = flip(map);

    We can do the same thing with getWith, and that's why it's named so:
    
    var getWith = flip(get);

** pluckWith
   This pattern of combining mapWith and getWith is very frequent in JavvaScript
   code. So much so, that we can take it up a notch.
     pluckWith takes an attribute and returns a function that takes an array
   of POJOs, maps over the array, returning each element.attribute
*** pluckWith Recipe:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" tangle: yes

  const pluckWith = (attr) => mapWith(getWith(attr));

  // aka: const pluckWith = compose(mapWith, getWith);

#+END_SRC

*** on _.pluck
    Libraries like Underscore provide pluck, the flipped version of pluckWith: a 
    function that takes two arguments:
                                      _.pluck(array, attr)
      Our recipe is terser when you want to name a function. And, of course, if we
    have pluck we can use flip to derive pluckWith: 
                                         const pluckWith = flip(_pluck)

** Deep Mapping
   mapWith is an excellent tool, but from time to time you will find yourself
   working with arrays that represent trees rather than lists. We could next some
   mapWiths, but there's a better way. 
*** deepMapWith Recipe:
    
#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :tangle yes

  const deepMapWith = (fn) =>
    function innerdeepMapWith (tree) {
      return Array.prototype.map.call(tree, (element) =>
        Array.isArray(element)
          ? innerdeepMapWith(element)
          : fn(element)
      );
    };

#+END_SRC

*** deepMapWith Example:

#+BEGIN_SRC js :cmd "org-babel-node --presets es2015" :results output

  const report =
  [ [ { price: 1.99, id: 1 },
      { price: 4.99, id: 2 },
      { price: 7.99, id: 3 },
      { price: 1.99, id: 4 },
      { price: 2.99, id: 5 },
      { price: 6.99, id: 6 } ],
    [ { price: 5.99, id: 21 },
      { price: 1.99, id: 22 },
      { price: 1.99, id: 23 },
      { price: 1.99, id: 24 },
      { price: 5.99, id: 25 } ],
    [ { price: 7.99, id: 221 },
      { price: 4.99, id: 222 },
      { price: 7.99, id: 223 },
      { price: 10.99, id: 224 },
      { price: 9.99, id: 225 },
      { price: 9.99, id: 226 } ] ];

  const getWith = (attr) => (object) => object[attr];

  const deepMapWith = (fn) =>
    function innerdeepMapWith (tree) {
      return Array.prototype.map.call(tree, (element) =>
        Array.isArray(element)
          ? innerdeepMapWith(element)
          : fn(element)
      );
    };

  console.log(deepMapWith(getWith('price'))(report));

#+END_SRC

#+RESULTS:
: [ [ 1.99, 4.99, 7.99, 1.99, 2.99, 6.99 ],
:   [ 5.99, 1.99, 1.99, 1.99, 5.99 ],
:   [ 7.99, 4.99, 7.99, 10.99, 9.99, 9.99 ] ]


* The Coffee Factory: "Object-Oriented Programming"
  Programming with objects and classes began in Norway in the late 1960s with the
  Simula programming language. Its creators, Ole-Johan Dahl and Kristen Nygaard,
  did not use those words to describe what would eventually become the dominant
  paradigm in computing.
    A decade later, Dr. Alan Kay coined the phrase “Object-Oriented Programming”
  along with co- creating the Smalltalk programming language. He has famously
  said that to him, “OOP” was objects communicating with each other using messages,
  and that other languages copied the things that didn’t matter from Smalltalk, and
  ignored the things he thought did matter.
    Since that time, languages have either bolted object-ish ideas on top of their
  existing paradigms (like Object Pascal and OCaml), baked them in alongside
  other paradigms (like JavaScript), or embraced objects wholeheartedly.
    That being said, there really is no one definition of “object-oriented.” For one
  thing, there is no one definition of “object.”
** objects
   Some languages, like Smalltalk and Ruby, treat an object as a fully
   encapsulated entity. There is no access to an object’s private state, all you can
   do is invoke one of its methods. Other languages, like Java, permit objects to
   access each other’s state.
     Some languages (again, like Java) have very rigid objects and classes, it is
   impossible or awkward to add new methods or properties to objects at run time.
   Some are flexible about adding methods and properties at run time. And yet other
   languages treat objects as dictionaries, where properties and even methods can be
   added, modified, or removed with abandon.
     So we can see that the concept of “object” is flexible across languages.
** classes
   The concept of “class” is also flexible across languages. Object-oriented
   languages do not uniformly agree on whether classes are necessary, much less how
   they work. For example, The Common Lisp Object System defines behaviour with
   classes, and it also defines behaviour with generic functions. The Self and
   NewtonScript languages have prototypes instead of classes.
     So some “OO” languages have objects, but not classes.
     C++ has classes, but they are not “first-class entities.” You can’t assign a
   class to a variable or pass it to a function. You can, however, manipulate the
   constructors for classes, the functions that make new objects. But you can’t
   manipulate those constructors to change the behaviour of objects that have
   already been constructed, instance behaviour is early-bound by default.
     Ruby has classes, and they’re first-class entities. You can ask an object for
   its class, you can put a class in a variable, pass it to a method, or return it
   from a method, just like every other entity in the language. Classes in Ruby and
   Smalltalk even have their own class, they are instances of Class! Instance
   behaviour is late-bound and open for extension.
** constructors
   Some languages allow programs to construct objects independently, others
   (notably those that are heavily class-centric) require that objects always be
   constructed by their classes. Some languages allow any function or method to be
   used as a constructor, others require a special syntax or declaration for
   constructors.
** prototypes are not classes
   Prototypical languages like Self and NewtonScript eschew classes altogether,
   using prototypes to define common behaviour for a set of objects. The difference
   between a prototype and a class is similar to the difference between a model home
   and a blueprint for a home.
     You can say to a builder, “make me a home just like that model home,” and the
   builder makes you a home that has a lot in common with the model home. You then
   decorate your home with additional personalization. But the model home is, itself,
   a home. Although you may choose to keep it empty, you could in principle move a
   family into it. This is different than asking a builder to make you a home based
   on a blueprint. The blueprint may specify the features of the home, but it isn’t
   a home. It could never be used as a home.
     Prototypes are like model homes, and classes are like blueprints. Classes are
   not like the objects they describe. 
     Well, actually, the difference between prototypes and classes is like the
   difference between model homes and blueprints. But prototypes are not like model
   homes. In actual fact, the relationship between an object and its prototype is
   one of delegation. So if a model home had a kitchen, and you asked the builder to
   make you a home using the model as a prototype, you could customize your own
   kitchen. But if you didn’t want to have your own custom kitchen, you would just
   use the model home’s kitchen to do all your own cooking. The relationship between
   a model home and a house is sometimes described as concatenative inheritance, and
   JavaScript lets you do that too.
** "object-oriented programming" can mean almost anything
   From this whirlwind tour of “object-oriented programming,” we can see that the
   ideas behind “object-oriented programming” have some common roots in the history
   of programming languages, but each language implements its own particular flavour
   in its own particular way.
     Thus, when we talk about “objects” and “prototypes” and “classes” in JavaScript,
   we’re talking about objects, prototypes, and classes as implemented in JavaScript.
   And we must keep in mind that other languages can have a radically different take
   on these ideas.
** the JavaScript Approach 
   JavaScript has objects, and by default, those objects are dictionaries. By
   default, objects directly manipulate each other’s state. Methods can be added to,
   or removed from objects at run time.
     JavaScript has optional prototypes. Prototypes are objects in the same sense
   that model homes are homes.
     In JavaScript, object and array literals construct objects that delegate
   behaviour to the standard library’s object prototype and array prototype,
   respectively. JavaScript also supports using Ob- ject.create to construct objects
   with or without a prototype, and new to construct objects using a constructor
   function.
     Using prototypes and constructor functions, JavaScript programs can emulate
   many of the features of classes in other languages. JavaScript also has a class
   keyword that provides syntactic sugar for writing constructor functions and
   prototypes in a declarative fashion.
     By default, a JavaScript class is a constructor composed with an object as its
   associated prototype. This can be denoted with the class keyword, by working
   with a function’s default .prototype property, or by composing functions and
   objects independently.
     JavaScript classes are constructors, but they are more than C++ constructors,
   in that manipulation of their prototype extends or modifies the behaviour of the
   instances they create. JavaScript classes take a minimalist approach to OO in
   the same sense that JavaScript objects take a minimal approach to OO. For
   example, behaviour can be mixed into an object, a prototype, or a class using
   the exact same mechanism, because objects, prototypes, and a constructor’s
   prototype are all objects that are open to extension.
     In sum, JavaScript is not exactly like any other object-oriented programming
   language, and its classes aren’t like any other language that features classes,
   but then again, neither is any other object-oriented programming language, and
   neither are any other classes.


* Served by the Pot: Collections

t



#+BEGIN_SRC js :results output

var exec = require('child_process').exec;
console.log('Node Version ' + process.version);
console.log('Node Path: ' + process.env.NODE_PATH);
exec("org-babel-node --version", function (error, stdout, stderr) {
console.log('Babel Version: ' + stdout);
});

#+END_SRC

#+RESULTS:
: Node Version v4.1.1
: Node Path: /Users/fugalfunkster/code/org/node_modules:
: Babel Version: 6.7.5
: 

