#+TODO: TODO PAUSED ACTIVE | DONE

NOTES

* emacs
** Chords by Package
*** emacs
**** files
***** C-x b *name* (switch to buffer named name)
***** C-x C-f *name* (open file named name)
***** C-x C-s (save buffer to file)
***** C-x C-w (save buffer to file as)
**** windows and frames
***** C-x 0 (delete current window)
***** C-x 1 (delete all windows except the window containing the point)
***** C-x 2 (split horizontal)
***** C-x 3 (split vertical)
***** C-x o (cycle cursor to next window)
***** C-M-v (scroll other window)
**** movement
***** M-< (top of document)
***** M-v (top of screen)
***** C-p (previous line)
***** C-l (center on cursor)
***** C-n (next line)
***** C-v (bottom of screen)
***** M-> (bottom of document)
***** C-a (beginning of line)
***** M-b (back one word)
***** C-b (back one character)
***** C-f (forward one character)
***** M-f (forward one word)
***** C-e (end of line)
***** M-g g (go to line)
***** C-s (regex search)
***** C-r (regex search reverse)
**** editing
***** killing
****** C-SPACE (set mark)
****** C-w (kill region)
****** C-k (kill line)
****** M-d (kill word)
****** M-w (copy region to kill ring)
****** C-y (yank)
****** M-y (yank, then cycle through kill ring)
****** C-_ (undo)
**** eshell
***** M-x eshell
***** C-u M-x eshell
**** modes
***** M-x (set major mode)
****** clojure-mode
****** js2-mode
****** org-mode
****** mit-scheme
***** C-h m (describe mode)
**** package manager
***** M-x package-list-packages
***** M-x package-refresh-contents
***** M-x package-install
*** js2-mode
**** C-c C-e (hide element)
**** C-c C-s (show element)
*** js2-refactor
*** REPLs
**** M-x nodejs-repl
**** M-x run-sheme
*** Magit
**** M-x magit-init (create repo)
**** M-x magit-status
**** TAB (expand file contents)
**** RET (edit file)
**** s (stage)
**** S (stage all)
**** u (unstage)
**** U (unstage all)
**** k (discard file)
**** i (add to gitignore)
**** g (refresh)
**** c (commit popup)
**** P (push popup)
**** F (fetch/pull popup)
**** l (log popup)
**** n (next line)
**** p (previous line)
**** M-n (forward sibling)
**** M-p (backward sibling)
**** q (bury buffer)
**** e (ediff message)
***** n (next)
***** A / B 
**** C-h k <key> (describe function bound to <key>)
*** Emmet Mode
**** a (element, default div)
**** . (class)
**** # (id)
**** / (empty tags)
**** + (siblings)
**** > (child)
**** ^ (climb up)
**** * (multiply)
**** $ (numbering, ex: ul>li$*3
**** {} (text)
*** IDO Mode
**** C-f / C-b (toggle IDO off after C-x C-f / C-x C-b
*** neoTree
**** n (next)
**** p (previous)
**** H (show hidden)
**** g (refresh)
**** A (min/max)
**** TAB/SPC/RET (fold/unfold)
**** C-c C-n (create a file (or dir if name ends with /)
**** C-c C-d (delete a file or dir)
**** C-c C-r (rename a file or dir)
**** C-c C-c (change root dir)
*** org-mode
**** navigation
***** C-c C-n (next heading)
***** C-c C-p (previous heading)
***** C-c C-u (up to higher level heading)
***** C-c C-f (next heading at same level)
***** C-c C-b (previous heading at same level)
**** Headings
***** M-S-arrow (move/promote/demote current subtree)
***** M-RET (create bullet at same level of indentation)
***** C-x n s (narrow to subtree)
***** C-x n w (widen to full tree)
**** TODO!
***** C-C C-t (cycle todo ring)
***** M-S-RET (insert new TODO @ same level)
*** flycheck
**** C-c ! l (list all errors)
**** C-c ! n (goto next error)
**** C-c ! p (goto previous error)
**** C-c ! v (verify flychecker works)
**** C-c ! x (disable flycheck in buffer)
**** if in node, paste at top: /* jslint node: true */
*** yasnippet snippets (tab)
**** variable declarations
     c - const
     v - var
     l - let
**** functions
     f - anonymous function
     f* - generator function
     fn - named function
     rt - return
     iife - iife
     *() - arrow func
**** Control flow
     *bl - block
     *br - break
     if - if
     *else - else
     switch
     *throw
     *? - ternary
     *try
     *catch
     *finally
**** Iterations
     *for
     *while
**** module
     req - require
     *imp - import
     *exp = module.export
     *exps - module.exports = ;
**** console
     console.log
     *console.warn
     *console.error
     *console.debug
**** objects
     *method w/ trailing comma
**** react
     *gis - getInitialState
     *gdp - getDefaultProps
     *cdm - componentDidMount
     *cwu - component will unmount
     *rrea - require react
     *rdom - require reactDOM
     *ren - ReactDOM.render ()
     *rrm - render
     *rr  - react router
     *rrr - react router route
     *rrl - react router link
     *tss - this.setState ({});
     *ptm - propTypes method
     *rcc - react createClass

**** http://capitaomorte.github.io/yasnippet/index.html
*** expand regions
    lets you send code to REPL
**** C-= (select/expand)
**** TAB (format)
** Magit (Howard's talk through 8:21)
*** Magit popups allow you to toggle switches, options, etc. 
**** default options (C-t)
**** actions complete the popup process
**** popups
***** Commit (c)
****** commit w/o switches or options (c)
       this opens two windows, one one side, the commit message
       on the other side the diff for staged files
****** to submit commit message (C-c C-c)
***** Push (P)
***** Pull / Fetch (F)
***** Log (l l)
*** Create Repository (M-x magit-init) -- git init
*** Main interface (M-x magit-status) -- git status
**** Head: local branch info
**** Upstream: primary remote
**** Files can be Untracked, Unstaged, Staged
***** refresh (g)
**** When the cursor is over a particular file
***** stage file (s)
***** stage All (S)
***** discard file (k)
***** add to gitignore (i)
***** expand file contents (<tab>)
****** this lets you see the file contents
****** (<return>) on a particular line allows you to edit that file
**** Commit Popup (c c)
**** Push Popup (P P)
**** Status message ($)
**** Pull /Fetch Popup (F F)
**** log (l)
*** Movement
**** next line (n)
**** previous line (p)
**** forward sibling (M-n)
**** backward sibling (M-p)
**** bury buffer (q)
*** ediff message (e)
**** next (first) diff (n)
**** A or B for what you want to keep
**** Or edit C
*** On Merging and rebasing
**** gerrit requires a straight history, no twigs
**** to achieve this you must rebase, which magit makes easy
** Packages
*** currently installed
**** async
***** http://elpa.gnu.org/packages/async.html
**** auto-complete
**** cider
***** http://www.github.com/clojure-emacs/cider
**** clojure-mode
***** http://github.com/clojure-emacs/clojure-mode
**** clojure-mode-ex
***** http://github.com/clojure-emacs/clojure-mode
**** dash
**** emmet-mode
***** fork of zencoding mode
***** https://www.youtube.com/watch?v=p7qore_HpC4
***** README: https://github.com/rooney/zencoding/blob/master/README.md
***** https://github.com/smihica/emmet-mode
**** epl
***** Emacs Package Library
***** EPL provides a convenient high-level API for various package.el versions
***** http://github.com/cask/epl
**** PAUSED expand-region
***** http://emacsrocks.com/e09.html
***** see docs in pkg mgr
**** exec-path-from-shell
***** https://github.com/purcell/exec-path-from-shell
**** flycheck (eslint)
***** https://www.flycheck.org/
**** git-commit
***** https://github.com/magit/magit
**** ido-completing
***** https://github.com/DarwinAwardWinner/ido-ubiquitous
**** id-ubiquitous
***** https://github.com/DarwinAwardWinner/ido-ubiquitous
**** TODO js-comint
***** https://github.com/redguardtoo/js-comint
**** TODO js2-mode
***** https://github.com/mooz/js2-mode/
**** TODO js2-refactor
***** see docs in pkg mgr
**** TODO magit
***** https://github.com/magit/magit
**** magit-popup
*****  https://github.com/magit/magit
**** multi-eshell
***** http://cims.nyu.edu/~stucchio
**** TODO multiple-cursors
***** https://www.youtube.com/watch?v=jNa3axo40qM
***** https://www.youtube.com/watch?v=4wvLGJQxEjQ
***** see docs in pkg mgr
**** neotree
***** https://github.com/jaypei/emacs-neotree
**** nodejs-repl
***** https://github.com/abicky/nodejs-repl.el 
**** org
**** org-bullets
***** https://github.com/sabof/org-bullets
**** TODO org-beautify-theme
***** https://github.com/jonnay/emagicians-starter-kit/blob/master/themes/org-beautify-theme.org
**** paredit ???
**** pkg-info
***** https://github.com/lunaryorn/pkg-info.
**** TODO ??? projectile
***** https://github.com/bbatsov/projectile
**** queue ???
**** rainbow-delimiters
***** https://github.com/Fanael/rainbow-delimiters
**** s ???
**** seq
***** http://elpa.gnu.org/packages/seq.html
**** smart-forward
***** see docs in pkg mgr
**** smex
***** http://github.com/nonsequitur/smex/
**** spinner
***** https://github.com/Malabarba/spinner.el
**** tagedit ???
**** TODO DELETE tern
***** http://ternjs.net/
**** TODO undo-tree
***** http://www.dr-qubit.org/emacs.php#undo-tree
**** with-editor
***** https://github.com/magit/with-editor
**** TODO yasnippet
***** http://capitaomorte.github.io/yasnippet/index.html
***** https://www.youtube.com/watch?v=-4O-ZYjQxks
***** http://github.com/capitaomorte/yasnippet


***** 





* JavaScript


* Node & Express


* MongoDB


* React
** React Big Picture
*** Following Pete Hunt's : https://github.com/petehunt/react-howto
**** React
**** React Routing
     react-router is handy for single-page applications, a page that loads once,
     and when the user clicks on a link or button, JS running on the page updates
     the address bar, but the webpage is not refreshed. Management of the address
     bar is done by something called a router. Thus, if you aren't making a single
     page web app, you have little reason to sue a router.
**** Flux Architecture Pattern (Redux)
     "Flux architecture should only be added once many components have already 
     been built. /n React components are arranged in a heirarchy. Most of the time
     your data model also follows a heirarchy. When your React components start to
     recieve props that feel extraneous, or you have a small number of components 
     starting to get very complex, then you might want to look into flux.
**** Inline Styling*
**** Server Rendering*
     "Server rendering is often called "universal" or "isomorphic" JS. It means
     that you can take your React components and render them to static HTML on the
     server. This improves initial startup performance because the user does not
     need to wait for JS to download in order to see the initial UI, and React can
     re-use the server-rendered HTML so it doesn't need to generate it client-side.
       You need server rendering if you notice that your initial render is too
     slow or if you want to improve your search engine ranking."
**** Immutable JS*
     "Immutable.js provides a set of data structures that can help to solve
     certain performance issues when building React apps. It's a great library,
     and you'll probably use it a lot in your apps moving forward, but it's
     completely unnecessary until you have an appreciation of the performance
     implications."
**** Relay & Falcor*
     "These are technologies that help you reduce the number of AJAX requests.
     They’re still very cutting-edge, so if you don’t have a problem with too many
     AJAX requests, you don’t need Relay or Falcor."
*** Docs
**** React Facebook docs
***** getting started: https://facebook.github.io/react/docs/getting-started.html
***** tutorial: https://facebook.github.io/react/docs/tutorial.html
***** Thinking in React https://facebook.github.io/react/docs/thinking-in-react.html
**** react-router docs
***** tutorial: https://github.com/reactjs/react-router-tutorial
***** introduction: https://github.com/reactjs/react-router/blob/master/docs/Introduction.md
***** guides: https://github.com/reactjs/react-router/tree/master/docs/guides
***** API: https://github.com/reactjs/react-router/blob/master/docs/API.md
***** examples: https://github.com/reactjs/react-router/tree/master/examples
*** pieces
***** Components
***** Props
***** Stateless Functional Components
***** State
***** ES6 Classes
***** React.createClass
***** this.props.children

** Talks
*** react-router
**** https://www.youtube.com/watch?v=XZfvW1a8Xac
*** Immutability
**** Immutable Data & React: https://www.youtube.com/watch?v=I7IdS-PbEgI
** Courses
*** React Tutorial (official)
**** Components
     React is all about modular, composable components. Note that native HTML element
     names start with a lowercase letter, while custom React class names begin with an
     uppercase letter.
**** JSX
     XML in our JS! Don't worry, it's there for our convienence; it's ultimately
     transpiled to javascript. For more info:
     https://facebook.github.io/react/docs/jsx-in-depth.html
**** React.createClass({})
     We pass an object containing methods to React.createClass to create a new React
     component. 
***** The render method is super important!
      The render method returns a tree of React components that will eventually
      render to HTML. Component tags look just like html elements, but these markers
      are not transpiled to HTML strings. Additionally, these tags don't need to be
      HTML tags, we can return a tree of components that you (or someone else) built.
      This is what makes React composable.
***** HTML Tags are regular React Components
      The only difference between HTML components and defined React components is
      is that HTML components are rewritten to React.createElement(tagName)
      expressions, which avoids polluting the global namespace with defined
      components.
**** ReactDOM.render()
     ReactDOM.render() instantiates the root component, starts the framework, and
     injects the markup into a raw DOM element, provided as the second argument.
     ReactDOM.render() should only be called once all of the composite components
     have been defined.
       The ReactDOM module exposes DOM-specific method, but React can also target
     different platforms, such as React Native.
**** Composing Components
**** Using props
     Data passed from a parent component to a child component is available as a
     property on the child component. These properties are accessed through
     this.props.
**** JS in our render tree
     By surrounding a JS expression in braces inside JSX (as either an attribute or
     child of a component) you can drop text or React Components into the tree. We
     access named attributes passed to the component as keys on this.props and any
     nested elements as this.props.children.
**** Component Properties (attributes and this.props.children)
     We can pass data from a parent component to a child component in two ways:
     1. We can pass data as an attribute. Attributes look like traditional html
        attributes: name="value". The value is then available on the child component
        as this.props.name
     2. The other way is to put data in between the opening and closing tags of a
        component: <Button>Some Text</Button>. The data is available to the child
        component as this.props.children.
**** Adding Markdown with the marked library
     Markdown lets us format text inline. Ex: surrounding text with asterisks will
     add emphasis. To use markup we can bring in a third party library: marked,
     which takes markdown text and converts it to raw html.
       BUT, marked accepts a string, and returns an html string. Remember, react
     doesn't transpile JSX to html by using setInnerHTML, it creates individual
     elements using createElement.
       HOWEVER, we can override React's default protection against XSS attacks, and
     enable an insertion of raw html with an attribute called dangerouslySetHTML,
     which takes raw markup as a value, and reners that markup as the data.
       To make this a little less scary, we can scrub our input. The marked library
     allows you to pass a second argumet to marked, and we can encapsulate the
     resulting string in a context object:

#+BEGIN_SRC js

// tutorial7.js
var Comment = React.createClass({
  rawMarkup: function() {
    var rawMarkup = marked(this.props.children.toString(), {sanitize: true});
    return { __html: rawMarkup };
  },

  render: function() {
    return (
      <div className="comment">
        <h2 className="commentAuthor">
          {this.props.author}
        </h2>
        <span dangerouslySetInnerHTML={this.rawMarkup()} />
      </div>
    );
  }
});

#+END_SRC

**** Hook Up the Data Model
     We can render data dynamically by mapping over data, and saving the returned
     components in a variable to return later.

#+BEGIN_SRC js

// tutorial10.js
var CommentList = React.createClass({
  render: function() {
    var commentNodes = this.props.data.map(function(comment) {
      return (
        <Comment author={comment.author} key={comment.id}>
          {comment.text}
        </Comment>
      );
    });
    return (
      <div className="commentList">
        {commentNodes}
      </div>
    );
  }
});

#+END_SRC

**** Reactive State
     render() methods are written declaratively as functions of this.props and
     this.state. The framework guarantees the UI is always consistent with the
     inputs.
       Props are immutable, they are passed from the parent and are owned by the
     parent. To implement interactions, we introduce mutable state to the component.
     this.state is private to the component and can be changed by calling
     this.setState(). When the state updates, the component re-renders itself.
     the getInitialState() methos executes exactly once during the lifecycle of the
     component and sets up the initial state of the component.
**** Updating State
     componentDidMount() is a method called automatically by React after a component
     is rendered for the first time. The key to dynamic updates is the call to
     this.setState(), which lets us replace the previous state with a new state,
     causing a re-render.
**** Controlled Components (Forms and Input)
     In React, components should always represent the state of the view and not
     only at the point of initialization.
**** Events
     React attaches event handlers to components using onChange and onSubmit
     handlers. We can use this.state to mirror user input into input elements by
     setting the element's value to this.state, and attach a onOnChange handler
     to setState.
       With an onSubmit handler, we can clear the form fields when the form is
     submitted with valid input.
       NOTE preventDefault() is useful to prevent the browser's default action of
     submitting forms.
**** Callbacks as Props
     When we need to pass data from a child component back up to its parent, we do
     this by passing a callback (parent method) to the child as props, and tie that
     callback to an event on the child component.
**** Optimization: optimistic updates
     Instead of relying on our server to handle updating data, we can add the user
     submitted data to our view optimistically, to make the app feel faster.
*** React Fundamentals (egghead)
**** JSX
     JSX: an HTML-like syntax
     all JXS is transpiled into JS
     it's all React.createElement('h1', null, 'inner html') under the hood
**** Stateless Functional Component
     different than a class that extends React.Component
     classes components can have state
     stateless function components do not have state
     props are passed into SFCs as argument
**** The Render Method
     The Render method is only allowed to return a single node. Adjacent JSX
     elements must be wrapped in an enclosing tag. 
       Be careful with wrapping our return statement, in the render method.
**** Intro to Props
     A lot like setting an attribute on an html element, or passing arguments to a 
     function. we access props on our component as this.props.whatever.
**** interpolating in JSX <tag>{JS expressions go in here}</tag>
**** propTypes
     type checking for props.
     a property of any react component
     an object where the name is the prop name
     and the value is a React.PropTypes.Type
     - .string
     - .number
     - *.isrequired (makes the prop required)
**** default Props
     follows same pattern as propTypes
     key is prop name
     value is default value for prop
**** constructor method
     super(); provides context for this within component when using ES6 class syntax
     this.state initializes state
**** binding this in the constructor method
     you can bind this for any method by using .bind(this) in the constructor method
     
#+BEGIN_SRC js

this.update = this.update.bind(this);

#+END_SRC

**** State Basics
     state is a collection of value that a component will manage itself     
     this.state ={} lets us create state
     accessed throughout the class as this.state.txt
     we only ever set state with this.setState
     setState lets us update only what we specify
**** Owner Ownee Relationship
     when one component renders another component
     react calles this owner onee relationship
     parent component is called a composite component
     
**** TODO Using Refs to Access Components (not encouraged)
     refs let you reference an instance of a component within our application
     refs won't work with SFCs
     When you are using React components you need to be able to access specific
     references to individual components. This is done by defining a ref.
**** TODO Accessing Child Properties {this.props.children}
     When you're building your React components, you'll probably want to access
     child properties of the markup. to get at innerHTML or nested components
***** parent innerhtml
***** nested components
**** Component Lifecycle - Mounting Basics
     React components have a lifecycle, and you are able to access specific phases
     of that lifecycle. This lesson will introduce mounting and unmounting of your
     React components. When a component is added or removed, this is called mounting
     and unmounting the component.
       These lifecycle events occur in a specific order, and we can hook into them.
***** componentWillMount
***** render
***** componentDidMount
***** componentWillUnmount
**** Component Lifecycle - Mounting Usage
     The previous lesson introduced the React component lifecycle mounting and
     unmounting. In this lesson you will learn some simple uses for these hooks.
**** Component Lifecycle - Updating
     The React component lifecycle will allow you to update your components at
     runtime. This lesson will explore how to do that.
     
**** Higher Order Components (replaces mixins)
**** Composable Components
**** Dynamically Generated Components
**** Build a JSX Live Compiler
**** JSX Deep Dive
**** Precompile JSX
**** Developer Tools
*** React.js Fundamentals Course
**** Intro to the React Ecosystem
***** Declarative vs. Imperative
****** Imperative Code tells the program how to do something
******* Example: for loops describe how to iterate over an array
****** Declarative Code tells the program what to do
******* Example: map iterates over an array under the hood
****** Benefits of declarative code
******* Reduces side effects
******* minimize mutability
******* more readable code
******* less bugs
****** React is mostly declarative
******* TODO Instead of storing state in the DOm, we internalize it to each component?
******* We still have to have imperative state modifications
***** Unidirectional Dataflow
***** Composition
****** Everything is a component
****** In react, we compose components into compositions
***** Explicit Mutations
****** With React you need to explicitly call set state to change state
***** It's Just JavaScript
***** Piecing the Puzzle
****** React
****** React Router
******* Applications are made of components
******* React router allows us to map components to specific URLs
****** Webpack
******* bundles code into a single file
******** uses loaders that transform code
******* frustrating b/c documentation is poor
****** Babel
******* does the transformation from jsx to JS
******* works as loader for webpack
****** Axios
******* make http requests
***** Example App: Github Battle
**** Setting up your first React component with NPM, Babel, and Webpack
***** using NPM
****** npm init
******* makes our pacjage.json file
****** npm install
******* --save react react-dom
******** react-dom is separate from react because react has other targets than just the dom
********* ex: we might render to react-native
******* --save-dev html-webpack-plugin webpack-dev-server webpack
******* --save-dev babel-core babel-loader babel-preset-react
****** npm scripts
******* production - triggers preprocessing and outputs to ./dist/ 
******* start - triggers the webpack-dev-server, which hosts the app/index.html
***** using webpack
      Webpack allows you to preprocess files as you require or load them. In order to do
      so, webpack needs:
      1. Where is the starting point of the application, or the route javascript file.
      2. What transformation to make on the code.
      3. Where to put the code, post-transformation.
****** the webpack.config.js
******* exports an object that represents ur config
******* properties include:
******** entry (an array containing the root .js file for our app, room for more files...)
******** output (a path to a directory, and the filename for our new root .js file)
******** module (the loaders property contains an array for each transformation)
********* each loader is composed of three things:
********** which file type to run the transformation on (typically a regex)
********** directories to exclude from transformation
********** the loader to use
********** Example:
*********** {test: /\.js$/, exclude: /node_modules/, loader: 'babel-loader'}
******** plugins
         Some files don't need to be transformed, but do need to be included in the
         production dist/ directory. the html-webpack-plugin, let's us grab our html
         files, use them as a template, inject our transformed root.js, and output a new
         index.html into the dist/ dir.
****** webpack CLI and webpack-dev-server
       In the root dir of our app, we can run webpack from the cmd line
******* webpack (run through transformation)
******* webpack -w (watch: auto transform on update)
******* webpack -p (run through transformations and minify)
***** using babel
      Babel is a tool for transpiling / compiling JavaScript. Here, we use babel to
      transform our JSX to JS. 
****** .babelrc (instruct babel which transformationf to make)
****** babel-preset-react (presets, referenced in .babelrc)
****** babel-loader (loader for webpack)
**** React components
     Data is either recieved from a component's parent component, or it's contained
     in the component itself. In order for a child component to access the state of a
     parent component, we must explicitly pass the data to our child component as an
     attribute.
***** Creating a new React Component
      Every component is required to have a render method: the component's template.
****** var componentName  = React.createClass({});
***** Rendering a react component to the DOM
      Because of the parent/child relationships, you usually only have to render once,
      the most parent component will render all of its child components. If you want
      your whole app to be react, you would render the parent component to
      document.body.
***** React.DOM takes two arguments, the component and the DOM node to render to
****** ReactDOM.render(<componentName'>, document.getElementById('anchor');
***** Diffing and the Virtual Dom
      The virtual DOM is a JS representation of the actual DOM. React keeps track of
      changes between the current virtual DOM and the previous virtual DOM, and
      updates the real DOM as necessary. This conserves DOM changes, and helps us
      reason about the state of ourapplication. 
**** Pure functions. f(d)=v. Props and Nesting Components
***** Nested Components and Props
      This section is about how React can nest components and how we can pass data from
      parent components to child components.
****** Props are to components what arguments are to functions
******* treat props as immutable
****** When we invoke a component, we can pass in an attribute
******* Example: <ProfilePic imageUrl={this.props.user.image} />
****** Attributes are accessable inside the component via this.props
******* Example: Inside the ProfilePic component, this.props.imageUrl
***** Building UIs with Pure Functions and Function Composition
****** a function takes in some data and returns a view : f(d) => v
****** instead of composing functions to get data, we compose components to get a UI
****** we use pure functions, which have the following properties:
******* Pure functions always return the same result given the same arguments
******* Pure function's execution doesn't depend on the state of the application.
******* Pure functions don't modify the variables aoutside of their scope
****** see .slice vs. .splice
****** The render method is a pure function 
***** FIRST (a helpful acronym when thinking about components)
****** Focused
****** Independent
****** Reusuable
****** Small
****** Testable
**** this.props.children, getting started with React Router, and className
***** this.props.children
      this.props.children refers to the contents of an html element. Sort of like .innerHTMl
      refers to the contents of an HTML tag. this.props.children could be text, another html
      element, etc.
        For example:
          <Clock> 12:49 AM </Clock>
        this.props.children of the Clock component === "12:49 AM"
****** Using this.props.children
       When invoking a component, we can place data in between the opening and closing tag,
       that data will be available to the component as this.props.children.
         In the following example, the Home component is this.props.children to the Main
       component. Thus, when this.props.children appears within the Main component, it renders
       the Home component:

#+BEGIN_SRC js

// './app/config/routes.js'

var routes = (
  <Router history={hashHistory}>
    <Route path='/' component={Main}>
      <IndexRoute component={Home}/>
    </Route>
  </Router>
);

// './components/Main.js'

var Main = React.createClass({
   render: function () {
     return (
       <div className='main-container'>
      {this.props.children}
       </div>
     )
   }
});

// './components/Home.js'

var Home = React.createClass({
   render: function () {
     return (
       <div> Hello from Home! </div>
     )
   }
});


#+END_SRC

****** another example, passing props via this.props.children:

#+BEGIN_SRC js

var Link = React.createClass({
  changeURL: function () {
    window.location.replace(this.props.href)
  },
  render: function () {
    return (
      <span style={{color: 'blue', cursor: 'pointer'}}
            onClick={this.changeURL}>
        {this.props.children}
      </span>
    )
  }
});


var ProfileLink = React.createClass({
  render: function () {
    return (
      <div>
        <Link href={'https://www.github.com/' + this.props.username}>
          {this.props.username}
        </Link>
      </div>
    )
  }
});

#+END_SRC

***** React Router (see also react-router tutorial notes below)
      react-router gives us a declarative way to map components to URLs.
****** $ npm install react-router
****** the Router component
       The Router component is required from react-router.

#+BEGIN_SRC js

var ReactRouter = require('react-router');
var Router = ReactRouter.Router;

#+END_SRC

       In our app, the Router Component is the highest level component, and encapsulates
       Route components.

#+BEGIN_SRC js

var routes = (
  <Router history={hashHistory}>
    <Route path='/' component={Main}>
      <IndexRoute component={Home}/>
    </Route>
  </Router>
);

#+END_SRC

       The history attribute on the Router component provides means for a browser to navigate
       within the app using the defined route paths.

****** the Route component
       Each route component has two attributes. First, the component attribute determines what
       component will be rendered, and the path component defines where (at what path) that
       component will be rendered.

#+BEGIN_SRC js

var React = require('react');
var ReactRouter = require('react-router');
var Router = ReactRouter.Router;
var Route =  ReactRouter.Route;
var IndexRoute =  ReactRouter.IndexRoute;
var hashHistory = ReactRouter.hashHistory;
var Main = require('../components/Main');
var Home = require('../components/Home');

var routes = (
  <Router history={hashHistory}>
    <Route path='/' component={Main}>
      <IndexRoute component={Home}/>
    </Route>
  </Router>
);

module.exports = routes;

#+END_SRC

****** main, a component that is always active
       Sometimes we want a header or nav-bar that is always going to be active. We can
       declare such a component as the sole direct child of our Router component, and assign
       the main component a path='/' and render other route components as children of the
       main component.
         The Main component thus must be responsible for rendering its child components, and
       we use this.props.children to make that happen. react-router will keep track of which
       child component is active, thus which component is displayed as this.props.children.

#+BEGIN_SRC js

var React = require('react');
var ReactRouter = require('react-router');
var Router = ReactRouter.Router;
var Route =  ReactRouter.Route;
var IndexRoute =  ReactRouter.IndexRoute;
var hashHistory = ReactRouter.hashHistory;
var Main = require('../components/Main');
var Home = require('../components/Home');

var routes = (
  <Router history={hashHistory}>
    <Route path='/' component={Main}>
      <IndexRoute component={Home}/>
    </Route>
  </Router>
);

module.exports = routes;

#+END_SRC

****** the IndexRoute component
       An IndexRoute component is the 'default' 'active' child component. The IndexRoute is
       active when a Route component has multiple children but none of those children are
       active. 

#+BEGIN_SRC js

var React = require('react');
var ReactRouter = require('react-router');
var Router = ReactRouter.Router;
var Route =  ReactRouter.Route;
var IndexRoute =  ReactRouter.IndexRoute;
var hashHistory = ReactRouter.hashHistory;
var Main = require('../components/Main');
var Home = require('../components/Home');

var routes = (
  <Router history={hashHistory}>
    <Route path='/' component={Main}>
      <IndexRoute component={Home}/>
    </Route>
  </Router>
);

module.exports = routes;

#+END_SRC

***** className
      In JS class is a reserved word, so within a react component, we must use className to
      refer to the component's class atrributes for CSS styling. 
**** Container vs. Presentational Components, Stateless Functional Components, & PropTypes
***** Route component props
      Just like we can pass props to a normal component, we can pass props to a router
      component. These props are available on this.route.propName within the component the
      route renders.

#+BEGIN_SRC js

var routes = (
  <Router history={hashHistory}>
    <Route path='/' component={Main}>
      <IndexRoute component={Home}/>
      <Route path='playerOne' header='Player One' component={PromptContainer} />
      <Route path='playerTwo/:playerOne' header='Player Two' component={PromptContainer} />
    </Route>
  </Router>
);

#+END_SRC
#+BEGIN_SRC js

var Prompt = React.createClass({
  return (
    <div>
      <h1>{this.route.header}</h1>
    <div>
  ) 
});

#+END_SRC

***** Link components
      Link components render this.props.children, and makes it clickable like an <a> element.

#+BEGIN_SRC js 

var Link = ReactRouter.Link;

var Home = React.createClass({
   render: function () {
     return (
       <div style={blueBg}>
         <h1>Github Battle</h1>
         <p>Some fancy motto</p>
         <Link to='/playerOne'>
           <button>Get Started</button>
         </Link>
       </div>
     )
   }
});

#+END_SRC

***** Styles
      We can import styles inside a javascript file, which exports style objects we can
      import and use in our components.
****** styles file example:
 #+BEGIN_SRC js

 // './styles/index.js'
 var styles = {
   transparentBg: {
     background: 'lightblue'
   }
 }

 module.exports = styles;

 #+END_SRC

****** use example:

#+BEGIN_SRC js

var transparentBg = require('../styles').transparentBg;

function Prompt (props) {
   return (
   <div style={transparentBg} >
//....

#+END_SRC

***** getInitialState
      The way you give React components state, is by using the getInitialState method.
      getInitialState is a function that returns an object containing name:value pairs
      that represent the component's state. 

#+BEGIN_SRC js
  getInitialState: function (){
    return {
      username: ''
    }
  },

  // this.state.username is now available within the component

#+END_SRC
      
***** setState
      We can change the state of the component using setState.

#+BEGIN_SRC js

  handleUpdateUser:  function (e) {
    this.setState({
      username: e.target.value
        
    })
  },

#+END_SRC

***** hooks
      - onChange (input)
      - onSubmit (form submit button)
***** context and dynamic routes
      We can dynamically change routes within react-router. Within a component, we can access
      data without having to pass the data as props using context. This isn't a good habit,
      but We can pull in router using contextTypes, and use the react-router object to
      dynamically change routes without having to ensure that router is passed to each 
      component that needs to affect dynamic routing.
        Once we have the router object, we can 'push' a route onto the router to cause a
      re-render to a specified route.
****** contextTypes and router.push example:

 #+BEGIN_SRC js

 var PromptContainer = React.createClass({
   contextTypes: {
     router: React.PropTypes.object.isRequired
   },

 //...

   handleSubmitUser: function (e) {
     e.preventDefault();
     var username = this.state.username;
     this.setState({
       username: ''
     });

     if (this.props.routeParams.playerOne) {
       this.context.router.push({
         pathname: '/battle',
         query: {
           playerOne: this.props.routeParams.playerOne,
           playerTwo: this.state.username
         }
       })
     } else {
       this.context.router.push('/playerTwo/' + this.state.username)
     }
   },

 #+END_SRC 

****** using push
       There are two ways to use this.context.router.push. The first way is to push a route
       string and add data as if it were part of the route. This data will be available to
       the next rendered component (which will have a parameter(s) defined in its route
       component path) as this.props.routeParams.paramName.
         The second way to use push is with query and state, which essentially passes state
       to the next component via a route query string.
***** separating container components from presentational components
****** the component that handles logic renders another component that renders the UI
***** Stateless Functional Components
      Our components can be classified into two categories:
        1. Container Components, and
        2. Presentational Components. 
      Presentational components simply take in some data via props and output some UI: IE
      components that just have a render method.
        As of React v0.14, we can write presentational components with function
      shorthand!
****** Example:

#+BEGIN_SRC js 

// this:

var HelloWorld = React.createClass({
  render: function () {
    return (
      <div>Hello {this.props.name}</div>
    )
  }
})

ReactDOM.render(<HelloWorld name='Tyler' />, document.getElementById('app'))

// can be written like this:
      
function HelloWorld (props) {
  return (
    <div>Hello {props.name}</div>
  )
}

ReactDOM.render(<HelloWorld name='Tyler' />, document.getElementById('app'))

// and with arrow notation!

const HelloWorld = props => (<div>Hello {props.name}</div>);

ReactDOM.render(<HelloWorld name='Tyler' />, document.getElementById('app'))

#+END_SRC      

****** Stateless Functional components don't support shouldComponentUpdate
***** PropTypes
      PropTypes are a component property that enforces a sort of type checking for the props
      that the component accepts. If the component is passed a value for a property that is 
      not of the type specified in that component's PropTypes, the compiler will throw an
      error. This feature helps detect bugs and self-documents components by specifying what
      values the component requires to render properly.
****** Example Component Invocation:

#+BEGIN_SRC js

<Icon
  name='fontawesome|facebook-square'
  size={70}
  color='#3b5998'
  style={styles.facebook} />

#+END_SRC

****** Example PropTypes for Above Component:
#+BEGIN_SRC js

var React = require('react')
var PropTypes = React.PropTypes
var Icon = React.createClass({
  propTypes: {
    name: PropTypes.string.isRequired,
    size: PropTypes.number.isRequired,
    color: PropTypes.string.isRequired,
    style: PropTypes.object
  },
  render: ...
});

#+END_SRC

****** Using PropTypes with functions
       A few things to note that you won't be expecting with the API:
         To use PropTypes with functions the API is propTypes.func rather than
       propTypes.function. Also to use booleans, the API is propTypes.bool not
       propTypes.boolean. I'm not 100% sure why but I assume it's because with ES6 you can
       use named imports to do

#+BEGIN_SRC js 

var { array, object, number, function, boolean } = React.PropTypes

#+END_SRC

       and both function and boolean are reserved words so that would break. Instead use
       func and bool and you'd be good.
****** Deep Background on the PropTypes API: https://facebook.github.io/react/docs/reusable-components.html
**** Life Cycle Events and Conditional Rendering
     Every component has a render method, which needs to be a pure function, IE, the render
     method just receives state and props and returns a UI. But, in an app, we need to do
     other stuff, like make ajax requests for data to populate props. 
       Lifecycle methods are special methods each component can have that allow us to hook
     into the views when specific events fire. There are two major categories of lifecycle
     events:
       1. When a component gets mounted to the DOM (or unmounted)
       2. When a component recieves new data
***** Mounting / Unmounting
      A handful of lyfecycle methods are called when a component is initialized and added
      to the DOM (mounting), and when the component is removed from the DOM (unmounting). By
      definition, these methods will be invoked only once during the life of the component.
        What might we want to do when a componnent mounts or unmounts?
        - Establish some default props in our component
        - Set some initial state in our component
        - Make an Ajax request to fetch some data needed for this component
        - Set up any listeners (ie websockets or Firebase listeners)
        - Remove any listeners you initially set up (when unmounting)
***** getInitialState
       To establish a components state before rendering it we must use getInitialState. To
       change the components state, we must call thissetState, passing in a new object which
       overwrites the prior state object.

#+BEGIN_SRC js

var Login = React.createClass({
  getInitialState: function () {
    return {
      email: '',
      password: ''
    }
  },
  render: function () {
    ...
  }
})

#+END_SRC
***** getDefaultprops
       If we want to ensure that a component has a default value for a prop, even is that prop
       is not passed in by the comsuner of our component, we can use getDefaultProps.

#+BEGIN_SRC js

var Loading = React.createClass({
  getDefaultProps: function () {
    return {
      text: 'Loading'
    }
  },
  render: function () {
    ...
  }
})

#+END_SRC

***** componentWillMount
***** componentDidMount
      We can fetch data using an ajax request immediately after the component mounts to the
      DOM with componentDidMount
****** Ajax request Example:
#+BEGIN_SRC js

var FriendsList = React.createClass({
  componentDidMount: function () {
    return Axios.get(this.props.url).then(this.props.callback)
  },
  render: function () {
    ...
  }
})

#+END_SRC

****** listeners example:

#+BEGIN_SRC js

var FriendsList = React.createClass({
  componentDidMount: function () {
    ref.on('value', function (snapshot) {
      this.setState({
        friends: snapshot.val()
      })
    })
  },
  render: function () {
    ...
  }
})

#+END_SRC
***** componentWillUnmount
       Removing listeners, to avoid memory leaks, should occur when the component is about
       to be removed from the DOM.

#+BEGIN_SRC js

var FriendsList = React.createClass({
  componentWillUnmount: function () {
    ref.off()
  },
  render: function () {
    ...
  }
})

#+END_SRC

***** componentWillReceiveProps
      There will be time when you'll want to execute some code whenever your component
      receives new props from its parent component.
***** shouldComponentUpdate
      React avoids rerendering unless something has changed. This method returns a boolean,
      and if true, will cause the component, and all of its child components, will rerender.
***** MOAR INFO: https://gist.github.com/fay-jai/fc8a5093c0b5124d4b2d#file-react-lifecycle-parent-child-jsx
**** Axios, Promises, and the github API
***** Axios 
****** abstracts http requests
****** uses promises
******* .all takes an array of promises, .then runs after all of those promises are resolved
******* .then
******* .catch is for error handling
***** this keyword
      Context is important with calling React component methods, ex: .setState. To ensure
      you have the right this, you can this/that or .bind().
***** puke
**** Rendering UI
***** this.context.router.push and state
      We can push data through to our next route by placing a state property on the object we
      pass to router.push.

#+BEGIN_SRC js

handleInitiateBattle: function () {
  this.context.router.push({
    pathname: '/results',
    state: {
      playersInfo: this.state.playersInfo
    }
  })
},

#+END_SRC

***** Wrappers
**** More Container vs. Presentational Components
***** Reduce
**** Private Functional Stateless Components
     React is all about modularity. When a render method gets big, you usually want to create
     abstract pieces into sub-components. There's no need to create a separate file and
     export the function, we can create sub-components using stateless function components
     within the same file.
       Stateless functional components have the added benefit of not having to deal with the
     'this' keyword.
***** Example:

#+BEGIN_SRC js

var React = require('react');
function FriendsList (props) {
  return (
    <h1>Friends:</h1>
    <ul>
      {props.friends.map((friend, index) => {
        return (
          <li key={friend}>{friend}</li>
        )
      })}
    </ul>
  )
}
module.exports = FriendsList

#+END_SRC     

***** Refactored Example:

#+BEGIN_SRC js

var React = require('react');
function FriendItem (props) {
  return <li>{props.friend}</li>
}
function FriendsList (props) {
  return (
    <h1>Friends:</h1>
    <ul>
      {props.friends.map((friend, index) => <FriendItem friend={friend} key={friend} />)}
    </ul>
  )
}
module.exports = FriendsList

#+END_SRC
***** You must require react when using stateless functional components
**** Building a Highly Reusuable React Component
***** getDefaultProps
      Sometimes you don't want to have to pass props to modular, reusuable components. With 
      getDefaultProps, you can specify default props in the absence of that component's
      consumer passing props in. The default props are always overwritten should a component's
      consumer pass props in.
****** Example:

#+BEGIN_SRC js

var Loading = React.createClass({
  getDefaultProps: function () {
    return {
      text: 'loading',
      styles: {color: 'red'}
    }
  },
  render: function () {
    ...
  }
})

#+END_SRC
**** React Router Transition Animation and Webpack's CSS Loader
***** React.cloneElement
      A React Element is "a plain object describing a component instance or DOM node and its
      desired properties". That may sound very similar to what JSX is used for and that's
      because a React element is what JSX gets transpiled into.
        Though not used a whole lot, there are times when you'll need to clone a React
      element and attach new props to it.

#+BEGIN_SRC js

React.cloneElement(FriendList, {friends: ['Jake', 'Joe']})

#+END_SRC
***** Animations b/t route transitions
****** $ npm install --save react-addons-css-transition-group
****** Webpack loaders for css
       $ npm install --save-dev css-loader style-loader
***** keys properties      
*** Notes on react-router tutorial
**** Rendering a Route
  
     At it's heart, React Router is a component:

#+BEGIN_SRC js

  render(<Router/>, document.getElementById('app'))

#+END_SRC

     To configure a route, we need to import functionality from react-router. The Router
     component, takes a history attribute (see hashHistory below). We nest Route
     components within the Router component. Each Route component takes a path
     attribute and a component attribute. The component attribute takes a react
     component as its value, and the path attribute takes a url string as its value.
     The path url string is the url path where the component will render.

#+BEGIN_SRC js

  import { Router, Route, hashHistory } from 'react-router';

  render((
    <Router history={hashHistory}>
      <Route path="/" component={App}/>
    </Router>
  ), document.getElementById('app'));

#+END_SRC

***** hashHistory
      hashHistory manages our routing history with the hash portion of the url. It's got
      that extra junk to shim some behavior the browser has natively when using real 
      urls. There are other options, like using real urls, but hashHistory doesn't
      require any server-side configuration.


***** Adding more routes

#+BEGIN_SRC js

  import React from 'react'
  import { render } from 'react-dom'
  import App from './modules/App'
  import About from './modules/About'
  import Repos from './modules/Repos'
  import { Router, Route, hashHistory } from 'react-router'

  render((
    <Router history={hashHistory}>
      <Route path="/" component={App}/>
      {/* add the routes here */}
      <Route path="/repos" component={Repos}/>
      <Route path="/about" component={About}/>
    </Router>
  ), document.getElementById('app'))

#+END_SRC
      
**** Navigating with Link
     Links are perhaps the most used component in a React App. It's almost identical to
     an <a/> tag, except that it's aware of the Router it was rendered in. Link
     components have a to attribute, that takes a url path string as a value.
     Predictably, a link component takes the user to its specified path. Links are
     acceptable to browsers, facilitating backward/forward movement.
***** Example:

#+BEGIN_SRC js

  // modules/App.js
  import React from 'react'
  import { Link } from 'react-router'

  export default React.createClass({
    render() {
      return (
        <div>
          <h1>React Router Tutorial</h1>
          <ul role="nav">
            <li><Link to="/about">About</Link></li>
            <li><Link to="/repos">Repos</Link></li>
          </ul>
        </div>
      )
    }
  })

#+END_SRC

**** Nested Routes
     Apps are just a series of components nested inside other components. With Router,
     the routing is coupled to the nesting of components. Nested route components
     automatically become nested UI.
***** this.props.children
       We nest Route components in our call to render. Nested components Route
     components are accessablie to their parent component as {this.props.children}      
***** By Small and Simple Things are Great Things Brought to Pass
      Every route can be developed, and even rendered, as an independent application.
      Route configuration stitches component apps together. 
**** Active Links
     One way that a Link component is different than an <a/> element, is that it
     knows if the path it links to is active, so you can style it differently.
***** Active Styles
      You can add an inline style to your Link using activeLink:

#+BEGIN_SRC js

  <li><Link to="/about" activeStyle={{ color: 'red' }}>About</Link></li>
  <li><Link to="/repos" activeStyle={{ color: 'red' }}>Repos</Link></li>

#+END_SRC

***** Active Class Name
      You can also use an active class name instead of inline styles:

#+BEGIN_SRC js

  <li><Link to="/about" activeClassName="active">About</Link></li>
  <li><Link to="/repos" activeClassName="active">Repos</Link></li>

#+END_SRC

      Of, course we'll need a stylesheet for that to be of any use. We can add one
      using a Link.

#+BEGIN_SRC js

  <link rel="stylesheet" href="index.css" />

#+END_SRC

#+BEGIN_SRC css

.active {
  color: green;
}

#+END_SRC

***** Nav Link Wrappers
      Most links in your site don't need to know they're active, usually just primary
      navigation links need to know. It's useful to wrap those so you don't have to
      remember what your activeClassName or activeStyle is everywhere.
        We can use the spread attribute to create a component that clones props and 
      includes specified props. 

#+BEGIN_SRC js

// modules/NavLink.js
import React from 'react'
import { Link } from 'react-router'

export default React.createClass({
  render() {
    return <Link {...this.props} activeClassName="active"/>
  }
})

#+END_SRC
#+BEGIN_SRC js

// App.js
import NavLink from './NavLink'

// ...

<li><NavLink to="/about">About</NavLink></li>
<li><NavLink to="/repos">Repos</NavLink></li>

#+END_SRC

**** URL Params
     Consider the following urls:
       /repos/reactjs/react-router
       /repos/facebook/react
     These urls would match a route path like this:
       /repos/:username/:repoName
***** Adding a Route with Parameters
      Let's teach our app to render this component:

#+BEGIN_SRC js

  // modules/Repo.js
  import React from 'react'

  export default React.createClass({
    render() {
      return (
        <div>
          <h2>{this.props.params.repoName}</h2>
        </div>
      )
    }
  })

#+END_SRC      

      Now we must provide the route to the component.

#+BEGIN_SRC js

  // index.js
  import Repo from './modules/Repo'

  render((
    <Router history={hashHistory}>
      <Route path="/" component={App}>
        <Route path="/repos" component={Repos}/>
        {/* add the new route */}
        <Route path="/repos/:userName/:repoName" component={Repo}/>
        <Route path="/about" component={About}/>
      </Route>
    </Router>
  ), document.getElementById('app'))

#+END_SRC

      And we can add some links to this new route in repos.js:

#+BEGIN_SRC js

  // Repos.js
  import { Link } from 'react-router'
  // ...
  export default React.createClass({
    render() {
      return (
        <div>
          <h2>Repos</h2>

          {/* add some links */}
          <ul>
            <li><Link to="/repos/reactjs/react-router">React Router</Link></li>
            <li><Link to="/repos/facebook/react">React</Link></li>
          </ul>

        </div>
      )
    }
  })

#+END_SRC

      Now go test your links out. Note that the parameter name in the route path
      becomes the property name in the component. Both repoName and userName are
      available on this.props.params of your component. You should probably add some
      prop types to help others and yourself out later.

**** More Nesting
     Notice how the list of links to different repositories goes away when we navigate
     to a repository? What if we want the list to persist, just like the global
     navigation persists?

#+BEGIN_SRC js

  // index.js
  // ...
  <Route path="/repos" component={Repos}>
    <Route path="/repos/:userName/:repoName" component={Repo}/>
  </Route>

#+END_SRC
#+BEGIN_SRC js

  // Repos.js
  // ...
  <div>
    <h2>Repos</h2>
    <ul>
      <li><Link to="/repos/reactjs/react-router">React Router</Link></li>
      <li><Link to="/repos/facebook/react">React</Link></li>
    </ul>
    {/* will render `Repo.js` when at /repos/:userName/:repoName */}
    {this.props.children}
  </div>

#+END_SRC

***** Active Links
      Let's bring in our NavLink from before so we can add the active class name to
      these links:

#+BEGIN_SRC js

  // modules/Repos.js
  // import it
  import NavLink from './NavLink'

  // ...
  <li><NavLink to="/repos/reactjs/react-router">React Router</NavLink></li>
  <li><NavLink to="/repos/facebook/react">React</NavLink></li>
  // ...

#+END_SRC

      Notice how both the /repos link up top and the individual repo links are both
      active? When child routes are active, so are the parents.

**** Index Routes
     When we visit / in this app it's just our navigation and a blank page. We'd like
     to render a Home component there. Lets create a Home component and then talk
     about how to render it at /.

#+BEGIN_SRC js

  // modules/Home.js
  import React from 'react'

  export default React.createClass({
    render() {
      return <div>Home</div>
    }
  })

#+END_SRC

     One option is to see if we have any children in App, and if not, render Home:

#+BEGIN_SRC js

  // App.js
  import Home from './Home'

  // ...
  <div>
    {/* ... */}
    {this.props.children || <Home/>}
  </div>
  //...

#+END_SRC

     This would work fine, but its likely we'll want Home to be attached to a route
     like About and Repos in the future. A few reasons include:
       1. Participating in a data fetching abstraction that relies on matched routes
          and their components.
       2. Participating in onEnter hooks
       3. Participating in code-splitting
     Also, it just feels good to keep App decoupled from Home and let the route
     config decide what to render as the children. Remember, we want to build small
     apps inside small apps, not big ones!

Lets add a new route to index.js.

#+BEGIN_SRC js 

  // index.js
  // new imports:
  // add `IndexRoute` to 'react-router' imports
  import { Router, Route, hashHistory, IndexRoute } from 'react-router'
  // and the Home component
  import Home from './modules/Home'

  // ...

  render((
    <Router history={hashHistory}>
      <Route path="/" component={App}>

        {/* add it here, as a child of `/` */}
        <IndexRoute component={Home}/>

        <Route path="/repos" component={Repos}>
          <Route path="/repos/:userName/:repoName" component={Repo}/>
        </Route>
        <Route path="/about" component={About}/>
      </Route>
    </Router>
  ), document.getElementById('app'))

#+END_SRC


      Now open http://localhost:8080 and you'll see the new component is rendered.
        Notice how the IndexRoute has no path. It becomes this.props.children of the
      parent when no other child of the parent matches, or in other words, when the
      parent's route matches exactly.
        Index routes can twist people's brains up sometimes. Hopefully it will sink in
      with a bit more time. Just think about a web server that looks for index.html
      when you're at /. Same idea, React Router looks for an index route if a route's
      path matches exactly.

**** Index Links
     Have you noticed in our app that we don't have any navigation to get back to
     rendering the Home component?
       Lets add a link to / and see what happens:

#+BEGIN_SRC js

  // in App.js
  // ...
  <li><NavLink to="/">Home</NavLink></li>
  // ...

#+END_SRC

     Now navigate around. Notice anything weird? The link to Home is always active!
     As we learned earlier, parent routes are active when child routes are active.
     Unfortunately, / is the parent of everything.
       For this link, we want it to only be active when the index route is active.
     There are two ways to let the router know you're linking to the "index route"
     so it only adds the active class (or styles) when the index route is rendered.

***** IndexLink
      First lets use the IndexLink

#+BEGIN_SRC js

  // App.js
  import { IndexLink, Link } from 'react-router'

  // ...
  <li><IndexLink to="/" activeClassName="active">Home</IndexLink></li>

#+END_SRC

***** onlyActiveOnIndex Property
      We can use Link as well by passing it the onlyActiveOnIndex prop (IndexLink
      just wraps Link with this property for convenience).

#+BEGIN_SRC js

  <li><Link to="/" activeClassName="active" onlyActiveOnIndex={true}>Home</Link></li>

#+END_SRC

     That's fine, but we already abstracted away having to know what the
     activeClassName is with Nav.
       Remember, in NavLink we're passing along all of our props to Link with the
     {...spread} syntax, so we can actually add the prop when we render a NavLink
     and it will make its way down to the Link:

#+BEGIN_SRC js

  <li><NavLink to="/" onlyActiveOnIndex={true}>Home</NavLink></li>

#+END_SRC

**** Clean URLs with Browser History
     The URLs in our app right now are built on a hack: the hash. Its the default
     because it will always work, but there's a better way.
       Modern browsers let JavaScript manipulate the URL without making an http
     request, so we don't need to rely on the hash (#) portion of the url to do
     routing, but there's a catch (we'll get to it later).
***** Configuring Browser History
      Open up index.js and import browserHistory instead of hashHistory.

#+BEGIN_SRC js

  // index.js
  // ...
  // bring in `browserHistory` instead of `hashHistory`
  import { Router, Route, browserHistory, IndexRoute } from 'react-router'

  render((
    <Router history={browserHistory}>
      {/* ... */}
    </Router>
  ), document.getElementById('app'))

#+END_SRC

      Now go click around and admire your clean urls.
      Oh yeah, the catch. Click on a link and then refresh your browser. What happens?

        Cannot GET /repos

***** Configuring Your Server
      Your server needs to deliver your app no matter what url comes in, because
      your app, in the browser, is manipulating the url. Our current server doesn't
      know how to handle the URL.
        The Webpack Dev Server has an option to enable this. Open up package.json
      and add --history-api-fallback.

      "start": "webpack-dev-server --inline --content-base . --history-api-fallback"

      We also need to change our relative paths to absolute paths in index.html
      since the urls will be at deep paths and the app, if it starts at a deep path,
      won't be able to find the files.

#+BEGIN_SRC html

  <!-- index.html -->
  <!-- index.css -> /index.css -->
  <link rel=stylesheet href=/index.css>

  <!-- bundle.js -> /bundle.js -->
  <script src="/bundle.js"></script>

#+END_SRC

      Stop your server if it's running, then npm start again. Look at those clean urls
      :)

**** Production-ish Server
     None of this has anything to do with React Router, but since we're talking
     about web servers, we might as well take it one step closer to the real-world.
     We'll also need it for server rendering in the next section.
       Webpack dev server is not a production server. Let's make a production
     server and a little environment-aware script to boot up the right server
     depending on the environment.

     Let's install a couple modules:

       npm install express if-env compression --save

     First, we'll use the handy if-env in package.json. Update your scripts entry in
     package.json to look like this:

#+BEGIN_SRC js

  // package.json
  "scripts": {
    "start": "if-env NODE_ENV=production && npm run start:prod || npm run start:dev",
    "start:dev": "webpack-dev-server --inline --content-base . --history-api-fallback",
    "start:prod": "webpack && node server.js"
  },

#+END_SRC

     Now when we run npm start it will check if our NODE_ENV is production. If it is,
     we run npm run start:prod, if it's not, we run npm run start:dev.
       Now we're ready to create a production server with Express and add a new file
     at root dir. Here's a first attempt:

#+BEGIN_SRC js

  // server.js
  var express = require('express')
  var path = require('path')
  var compression = require('compression')

  var app = express()

  // serve our static stuff like index.css
  app.use(express.static(__dirname))

  // send all requests to index.html so browserHistory in React Router works
  app.get('*', function (req, res) {
    res.sendFile(path.join(__dirname, 'index.html'))
  })

  var PORT = process.env.PORT || 8080
  app.listen(PORT, function() {
    console.log('Production Express server running at localhost:' + PORT)
  })

#+END_SRC

Now run:

#+BEGIN_SRC bash

  NODE_ENV=production npm start
  # For Windows users:
  # SET NODE_ENV=production npm start

#+END_SRC
 
     Congratulations! You now have a production server for this app. After clicking
     around, try navigating to http://localhost:8080/package.json. Whoops. Let's
     fix that. We're going to shuffle around a couple files and update some paths
     scattered across the app.
       1. make a public directory.
       2. Move index.html and index.css into it.
     Now let's update server.js to point to the right directory for static assets:

#+BEGIN_SRC js

  // server.js
  // ...
  // add path.join here
  app.use(express.static(path.join(__dirname, 'public')))

  // ...
  app.get('*', function (req, res) {
    // and drop 'public' in the middle of here
    res.sendFile(path.join(__dirname, 'public', 'index.html'))
  })

#+END_SRC

     We also need to tell wepback to build to this new directory:

#+BEGIN_SRC js

  // webpack.config.js
  // ...
  output: {
    path: 'public',
    // ...
  }

#+END_SRC

     And finally (!) add it to the --content-base argument to npm run start:dev script:

#+BEGIN_SRC json

  "start:dev": "webpack-dev-server --inline --content-base public --history-api-fallback",

#+END_SRC     

     If we had the time in this tutorial, we could use the WebpackDevServer API in a
     JavaScript file instead of the CLI in an npm script and then turn this path into
     config shared across all of these files. But, we're already on a tangent, so that
     will have to wait for another time.
       Okay, now that we aren't serving up the root of our project as public files,
     let's add some code minification to Webpack and gzipping to express.

#+BEGIN_SRC js

  // webpack.config.js

  // make sure to import this
  var webpack = require('webpack')

  module.exports = {
  // ...

    // add this handful of plugins that optimize the build
    // when we're in production
    plugins: process.env.NODE_ENV === 'production' ? [
      new webpack.optimize.DedupePlugin(),
      new webpack.optimize.OccurrenceOrderPlugin(),
      new webpack.optimize.UglifyJsPlugin()
    ] : [],

    // ...
  }

#+END_SRC

     And compression in express:

#+BEGIN_SRC js

  // server.js
  // ...
  var compression = require('compression')

  var app = express()
  // must be first!
  app.use(compression())

#+END_SRC

     Now go start your server in production mode:

       NODE_ENV=production npm start

     You'll see some UglifyJS logging and then in the browser, you can see the assets
     are being served with gzip compression.

**** Navigating Programatically
     While most navigation happens with Link, you can programatically navigate around
     an application in response to form submissions, button clicks, etc.
       Let's make a little form in Repos that programatically navigates.

#+BEGIN_SRC js 

  // modules/Repos.js
  import React from 'react'
  import NavLink from './NavLink'

  export default React.createClass({
    // add this method
    handleSubmit(event) {
      event.preventDefault()
      const userName = event.target.elements[0].value
      const repo = event.target.elements[1].value
      const path = `/repos/${userName}/${repo}`
      console.log(path)
    },
    render() {
      return (
        <div>
          <h2>Repos</h2>
          <ul>
            <li><NavLink to="/repos/reactjs/react-router">React Router</NavLink></li>
            <li><NavLink to="/repos/facebook/react">React</NavLink></li>
            {/* add this form */}
            <li>
              <form onSubmit={this.handleSubmit}>
                <input type="text" placeholder="userName"/> / {' '}
                <input type="text" placeholder="repo"/>{' '}
                <button type="submit">Go</button>
              </form>
            </li>
          </ul>
          {this.props.children}
        </div>
      )
    }
  })

#+END_SRC

     There are two ways you can do this, the first is simpler than the second.
       First we can use the browserHistory singleton that we passed into Router in
     index.js and push a new url into the history.

#+BEGIN_SRC js 

  // Repos.js
  import { browserHistory } from 'react-router'

  // ...
    handleSubmit(event) {
      // ...
      const path = `/repos/${userName}/${repo}`
      browserHistory.push(path)
    },
  // ...

#+END_SRC


     There's a potential problem with this though. If you pass a different history to
     Router than you use here, it won't work. It's not very common to use anything
     other than browserHistory, so this is acceptable practice. If you're concerned
     about it, you can make a module that exports the history you want to use across
     the app, or...
       You can also use the router that Router provides on "context". First, you ask
     for context in the component, and then you can use it:

#+BEGIN_SRC js

  export default React.createClass({

    // ask for `router` from context
    contextTypes: {
      router: React.PropTypes.object
    },

    // ...

    handleSubmit(event) {
      // ...
      this.context.router.push(path)
    },

    // ..
  })

#+END_SRC


This way you'll be sure to be pushing to whatever history gets passed to Router. It also makes testing a bit easier since you can more easily stub context than singletons.

**** TODO Server Rendering
     Alright, first things first. Server rendering, at its core is a simple concept
     in React.

#+BEGIN_SRC js

  render(<App/>, domNode)
  // can be rendered on the server as
  const markup = renderToString(<App/>)

#+END_SRC


     It's not rocket science, but it also isn't trivial. First I'm going to just
     throw a bunch of webpack shenanigans at you with little explanation, then
     we'll talk about the Router.
       Since node doesn't (and shouldn't) understand JSX, we need to compile the code
     somehow. Using something like babel/register is not fit for production use, so
     we'll use webpack to build a server bundle, just like we use it to build a
     client bundle.

     Make a new file called webpack.server.config.js and put this stuff in there:

#+BEGIN_SRC js


var fs = require('fs')
var path = require('path')

module.exports = {

  entry: path.resolve(__dirname, 'server.js'),

  output: {
    filename: 'server.bundle.js'
  },

  target: 'node',

  // keep node_module paths out of the bundle
  externals: fs.readdirSync(path.resolve(__dirname, 'node_modules')).concat([
    'react-dom/server', 'react/addons',
  ]).reduce(function (ext, mod) {
    ext[mod] = 'commonjs ' + mod
    return ext
  }, {}),

  node: {
    __filename: true,
    __dirname: true
  },

  module: {
    loaders: [
      { test: /\.js$/, exclude: /node_modules/, loader: 'babel-loader?presets[]=es2015&presets[]=react' }
    ]
  }

}

#+END_SRC


     Hopefully some of that makes sense, we aren't going to cover what all of that
     stuff does, it's sufficient to say that now we can run our server.js file through
     webpack and then run it.
       Now we need to make some scripts to build server bundle before we try to run
     our app. Update your package.json script config to look like this:

#+BEGIN_SRC js

"scripts": {
  "start": "if-env NODE_ENV=production && npm run start:prod || npm run start:dev",
  "start:dev": "webpack-dev-server --inline --content-base public/ --history-api-fallback",
  "start:prod": "npm run build && node server.bundle.js",
  "build:client": "webpack",
  "build:server": "webpack --config webpack.server.config.js",
  "build": "npm run build:client && npm run build:server"
},

#+END_SRC

     Now when we run NODE_ENV=production npm start both the client and server bundles
     get created by Webpack.
       Okay, let's talk about the Router. We're going to need our routes split out into
     a module so that both the client and server entries can require it. Make a file at
     modules/routes and move your routes and components into it.

#+BEGIN_SRC js

// modules/routes.js
import React from 'react'
import { Route, IndexRoute } from 'react-router'
import App from './App'
import About from './About'
import Repos from './Repos'
import Repo from './Repo'
import Home from './Home'

module.exports = (
  <Route path="/" component={App}>
    <IndexRoute component={Home}/>
    <Route path="/repos" component={Repos}>
      <Route path="/repos/:userName/:repoName" component={Repo}/>
    </Route>
    <Route path="/about" component={About}/>
  </Route>
)
// index.js
import React from 'react'
import { render } from 'react-dom'
import { Router, browserHistory } from 'react-router'
// import routes and pass them into <Router/>
import routes from './modules/routes'

render(
  <Router routes={routes} history={browserHistory}/>,
  document.getElementById('app')
)

#+END_SRC


     Now open up server.js. We're going to bring in two modules from React Router to
     help us render on the server.
       If we tried to render a <Router/> on the server like we do in the client, we'd
     get an empty screen since server rendering is synchronous and route matching is
     asynchronous.
       Also, most apps will want to use the router to help them load data, so
     asynchronous routes or not, you'll want to know what screens are going to render
     before you actually render so you can use that information to load asynchronous
     data before rendering. We don't have any data loading in this app, but you'll see
     where it could happen.
       First we import match and RouterContext from react router, then we'll match the
     routes to the url, and finally render.

#+BEGIN_SRC js

// ...
// import some new stuff
import React from 'react'
// we'll use this to render our app to an html string
import { renderToString } from 'react-dom/server'
// and these to match the url to routes and then render
import { match, RouterContext } from 'react-router'
import routes from './modules/routes'

// ...

// send all requests to index.html so browserHistory works

app.get('*', (req, res) => {
  // match the routes to the url
  match({ routes: routes, location: req.url }, (err, redirect, props) => {
    // `RouterContext` is the what `Router` renders. `Router` keeps these
    // `props` in its state as it listens to `browserHistory`. But on the
    // server our app is stateless, so we need to use `match` to
    // get these props before rendering.
    const appHtml = renderToString(<RouterContext {...props}/>)

    // dump the HTML into a template, lots of ways to do this, but none are
    // really influenced by React Router, so we're just using a little
    // function, `renderPage`
    res.send(renderPage(appHtml))
  })
})

function renderPage(appHtml) {
  return `
    <!doctype html public="storage">
    <html>
    <meta charset=utf-8/>
    <title>My First React Router App</title>
    <link rel=stylesheet href=/index.css>
    <div id=app>${appHtml}</div>
    <script src="/bundle.js"></script>
   `
}

var PORT = process.env.PORT || 8080
app.listen(PORT, function() {
  console.log('Production Express server running at localhost:' + PORT)
})

#+END_SRC


     And that's it. Now if you run NODE_ENV=production npm start and visit the app,
     you can view source and see that the server is sending down our app to the
     browser. As you click around, you'll notice the client app has taken over and
     doesn't make requests to the server for UI. Pretty cool yeah?!
       Our callback to match is a little naive, here's what a production version
     would look like:

#+BEGIN_SRC js

app.get('*', (req, res) => {
  match({ routes: routes, location: req.url }, (err, redirect, props) => {
    // in here we can make some decisions all at once
    if (err) {
      // there was an error somewhere during route matching
      res.status(500).send(err.message)
    } else if (redirect) {
      // we haven't talked about `onEnter` hooks on routes, but before a
      // route is entered, it can redirect. Here we handle on the server.
      res.redirect(redirect.pathname + redirect.search)
    } else if (props) {
      // if we got props then we matched a route and can render
      const appHtml = renderToString(<RouterContext {...props}/>)
      res.send(renderPage(appHtml))
    } else {
      // no errors, no redirect, we just didn't match anything
      res.status(404).send('Not Found')
    }
  })
})

#+END_SRC

     Server rendering is really new. There aren't really "best practices" yet,
     especially when it comes to data loading, so this tutorial is done, dropping
     you off at the bleeding edge.
*** Getting Started with Redux (egghead)
*** Getting Started with React Router (egghead)
*** Modern React with Redux (Udemy)
**** Intro
***** Setting up our environment
      Install the ReduxSimpleStarter boilerplate repo from:
      https://github.com/StephenGrider/ReduxSimpleStarter
***** Export Statements 
****** export default FunctionName;
***** Functional Components
****** start with functional components, refactor to classes when necessary 
***** Class Components
****** class Name extends React.Component {}
****** every react class must have a render method 
******* shorthand
***** import {property}
***** events
****** onChange - a vanilla event
****** always called with an event object, describes context of event
****** attributes / props
***** arrow functions w/o ()
***** State
      an object describting state
      when state changes, react rerenders
      only class components have state
****** constructor
       constructor method sets up state, getInitialState?
       constructor is the first, and only function called automatically, 
       reserve for initializing state, variables, etc
       only inside constructor do we this.state =
****** super
       React.component has its own constructor method
       we call parent constructor method with super()
****** this.state
       new state object with properties we want for our component, and initial state      
****** updating state
       we only change state this way:
       this.setState({ ... });
       this is how we maintain continuity
       we can change one prop at a time, or whole state obj
****** state is how we update our components/views
***** controlled component
      has it's value set by state, value changes only when state changes
      controlled input ex: 
        input: value = state, onchange setsState, react rerenders
      lets us avoid manipulating the dom to sync state and ui
***** Review
****** jsx
****** components
******* functional components
******* class-based components
****** state
****** ES6
******* classes
******** constructor
******** super
******* arrow functions
******* import / export
****** youtube API
**** AJAX with React
***** downwards data flow
      the most parent component should be responsible for fetching data
***** ES6 lets us write {videos} instead of {videos: videos}
***** className
***** passing data from parent to child, define property on tag, attributeish PROPS
      anytime the app rerenders, props are re-passed, updated!
      props arrive as arguments to function components, aka props.etc
      in a class component, props are available anywhere as this.props.etc
***** for a split second we see initial state, then state can be set
**** Making lists with map
***** react is good at rendering an array of components
***** but each chld in an arrat or iterator should have a unique key prop
      when we render multiple items of the same type, react will optimize rendering a list
      optimizes better with a key
      adding a key is easy, use an id for each item to make it unique, a unique key!
***** using object destructuring in function arguments
      see video-list-items.js
***** Do I expect this component to need to maintain any state?
      a question to ask each time you create a component
***** handling null props
      some parents cant fetch data fast enough to pas that data to childs before render
      use control flow to render a loading component
      on set state, it'll rerender, passing down actual props.
***** callback passing down
      pass components down from the stateful component that has state to a presentational component
      pass down a setState function as props through each nested child
      rarely go further than two deep
***** css styling
***** refactoring
      important to refactor carefully
      when you're passing down a state changing function to a component that has it's own state
      be sure to keep state stright
***** throttling search term input (throttling re-renders)
      debounce from lo-dash
      $ npm install lo-dash
***** wrapup big ideas
****** class v. functional component
       class if for when we need state
       func. comps. whenever our component is static
****** state
       createclass is older, getinitialstate is an artifact
       we now use es6
       create state in constructor
       state is component level
       redux makes state application level
****** import and export statements
       local vs. node_module
****** callbacks
       parent child communication
       redux reduces callbacks, and passing...
**** Modeling Application State
***** Redux
      A collection of all the data that describes the app
      all state of app (data and ui state)
      all allplications data is in one object
**** Managing App State with Redux
     In Redux, there is one state, one object that contains all stateful data for
     the application. This state is accessed through reducers. 
       Redux constructs the application state, and React provides views that display
     that state. These two libraries are separate, and connect to each other through
     a third library, react-redux.
***** TODO What's are provider, createStore, applyMiddleware?
***** Reducers
      Our application state is generated by reducer functions. A reducer function is
      a function that returns data which represents a piece of the application
      state. We can have many reducers, each of which returns different pieces of
      the application state.
***** moar on reducers
      Every reducers get two arguments (state, action). The state argument does not
      refer broadly - ie. to application state - instead, state refers only to that
      part of the application state that the reducer is responsible for.
        Reducers are only ever called when any action occurs. Most of these actions
      mave nothing to do with our reducer, so reducers default to returning the
      state originally passed in.
        Reducers are usually written with a JS switch statement to determine whether
      the reducer needs to do anything based on the type property of the action
      object. In the event that the case is such that the reducer is relevant,
      it will return the action's payload (which becomes the new state for that
      reducer).
        Note that we need to default the value of the state argument to null.

      NEVER MUTATE STATE INSIDE THE REDUCER! USE THE PAYLOAD!
***** combineReducers ({reducers})=> atomicGlobalState
      An application's atomic state is composed from the data returned by the app's
      reducer functions. We assemble this atomicGlobalState with Redux's
      combineReducers method, by passing in an object assembled from the data that
      our reducers return.
***** container
      Containers are normal React components that we designate to have a direct
      relation to the state managed by Redux; Containers are the point where we 
      inject state into our components. Because state can be passed to child
      components as props, containers should be the parent-most component of a
      constellation of components that consume a related state. We aim to match our
      Containers tightly to the components that truly need access to state.
***** connect(ing) react-redux/components-state
      How do our components access state? Via react-router(s) connect method.
      connect is a function that takes multiple arguments, and returns a function.
        connect's first argument is a function, usually called something helpful,
      like mapStateToProps; predictably this function's job is to take the
      application state, or, at least part of it, and return an object,
      containg select data from the application state.

#+BEGIN_SRC js

function mapStateToProps (state) {
  return {
    books: state.books
  };
}

#+END_SRC

        We then invoke the function returned from connect with the component that
      will consume the data returned from mapStateToProps. Our component recieves
      the returned object and exposes this data as its props. NOTE the props
      properties referenced in our component must match the keys defined in
      mapStateToProps's returned object.
        Whenever our application state changes, our containers will automatically
      rerender.
***** Actions and Action Creators Let us Change State
      1. An event, usually triggered by a user, can call an action creator. An
         action creator is a function that returns an action object.
      2. That action object is automatically sent to all of the reducers within our
         application.
      3. Reducers can choose, depending on the type of action, whether to return the
         current state, or a new state (based on the action object's contents).
      4. Once all of the reducers handle the action, the reducers then re-populate
         the application state.
      5. The state change causes all of the components to re-render.
***** Action Creators are functions that return an Action Object
      Action objects typically have two properties:
      1. type (required) exact spelling is IMPORTANT, we typically import the
         strings from another file.
      2. payload - the data we want to use to update application state
***** We bindActionCreators to Containers using mapDispatchToProps via connect
      Much like we connect container components to the application state by passing
      mapStateToProps to connect, and invoking the returned function by passing it
      our container; we can connect containers to action creators by passing
      matchDispatchToProps as a second argument to our invocation of connect.
        matchDispatchToProps is a function that returns props for the component.
      Inside of matchDispatchToProps, we call a function imported from redux called
      bindActionCreators.
        bindActionCreators is what ensures that our actions - generated from our
      action creator, are presented to our reducers. The dispatch function is
      responsible for doing the actual work of handling the action object. Note 
      that the dispatch object is called within connect, we don't fuss with it.
        bindActionCreators takes two arguments:
        1. An object, containg a key:value that relate to an action creator, and
        2. the dispatch that was originally passed to mapDispatchToProps.

#+BEGIN_SRC js

function mapDispatchToProps (dispatch) {
  return bindActionCreators({selectBook: selectBook}, dispatch);

#+END_SRC

***** Conditional Rendering
      When our application boots up, our reducers may populate our application state
      with null values. We need to have reasonable default states or we will see a
      lot of typeErrors.
        We can use control flow to detmine whether the state is non-null:

#+BEGIN_SRC js

//...

class BookDetail extends Component {
  render() {
    if (!this.props.book) {
      return <div>Select a book to get started!</div>;
    }
    return (
      <div>

//...

#+END_SRC

***** Big Ideas
****** Redux is in charge of managing our application state: a single POJO
****** Application state is completely separate from react components state
****** Our application state is formed by combining reducers
****** Reducers are in control of changing application state over time
****** Action creators are functions that return action objects
****** Actions alert reducers to opportunities to return a new state
****** Connect populates our container with props for managing state
**** Intermediate Redux: Middleware
***** Making a weather app
      Challenges
      1. Making AJAX requests with Redux
      2. Making a line chart within react
      3. Handing extensive state changes
***** Setting up our components and context
****** onChange callbacks and this
       When we hand off a callback and that callback has a reference to this,
       we need to be clear about what the context is, typically by binding the
       callback's context. We can do that in the constructor method of an ES6 class:

#+BEGIN_SRC js

export default class SearchBar extends Component {
  constructor(props){
    super(props);

    this.state = {term: '' };
    this.onInputChange = this.onInputChange.bind(this);
  }
  onInputChange(event) {
    this.setState({ term: event.target.value });
  }
  render() {
    return (
      <form className='input-group'>
        <input
          placeholder='Get your five-day forecast'
          className='form-control'
          value={this.state.term}
          onChange={this.onInputChange}
        />
        <span className='input-group-btn'>
          <button type='submit' className='btn btn-secondary'>Submit</button>
        </span>
      </form>
    );
  }
}

#+END_SRC

****** form elements in React
       Form elements have automatic behavior, ex: enter or clicking submit
       clear out an input field. To prevent this behavior, we need to intercept
       the form's onSubmit behavior, to a function that prevent's the default
       behavior. 

#+BEGIN_SRC js

//...
  onFormSubmit(event) {
    event.preventDefault();
  }
  render() {
    return (
      <form onSubmit={this.onFormSubmit} className='input-group'>
        <input
//...

#+END_SRC

       Why use form's anyway? We can intercept one event, onSubmit on the form tag,
       instead of having to intercept both submit button clicks and enter key
       presses.

***** Middleware
      Middleware are functions that accept an action and return an action. Middleware
      might let an action passs through unchanged, log the action, stop the action,
      etc. This lets us manipulate actions before they hit our reducers. 
****** redux-promise
       npm installed, and included in our app as middleware. 

#+BEGIN_SRC js

//...
import ReduxPromise from 'redux-promise';
//...
const createStoreWithMiddleware = applyMiddleware(ReduxPromise)(createStore);
//...

#+END_SRC

****** AJAX with axios
       we return the promise as the payload of the action, the action goes to the
       reducer with the promise's response. redux-promise doesn't pass an action on
       to a reducer until the promise resolves. if the payload is a promise,
       redux-promise stops the action, once the request finishes, it emits an action
       of the same type, passsing the data on.
         AKA react-router unwraps promises that appear in the payload of an action
       before the action hits reducers.   
***** Avoiding Mutating State in Reducers
      use the spread operator
***** map props to a render helper...
***** react-sparklines
***** react-google-maps


* Video Courses
** Pluralsight Courses
*** PAUSED Intro to Node.js (Paul O'Fallon)
**** Accessing the Local System

***** The Process Object - a way for node to manage itself and other processes on your system
****** https://nodejs.org/api/process.html
****** a collection of streams
       - process.stdin
       - process.stdout
       - process.stderr
****** attributes of the current process
       - process.env
       - processargv
       - process.pid
       - process.title
       - process.uptime()
       - process.memoryUsage()
       - process.cwd()
       - etc...
****** Process-related actions
       - process.abort()
       - process.chdir()
       - process.kill()
       - process.setgid()
       - process.setuid()
       - ...etc...
****** An Instance of Event Emitter
       - event:'exit'
       - event:'uncaughtException'
       - POSIX signal events ('SIGINT',etc.)


***** The File System
****** built in fs module; async is default, "Sync" specified
****** https://nodejs.org/api/fs.html
****** Wrappers around POSIX functions
       - ex: fs.readdir(path, cb) / fs.readDirSync(path)
       - also: rename, truncate, chown, fchown, lchown, chmod, fchmod, lchmod, stat, fstat, lstat
         link, symlink, readlink, realpath, unlink, rmdie, mkdir, readdir, close, open, utimes, futimes, 
         fsync, write, read, readFile, writeFile, and appendFile
****** Stream oriented functions
       - fs.createReadStream() = returns an fs.ReadStream (a readable stream)
       - fs createWriteStream() = | | 
****** Watch a file or dir for changes
       - fs.watch() - returns an fs.FSWatcher (an event emitter)
       - 'change' event: the type of change and the filename that changed
       - 'error' event: emitted when an error occurs


***** Buffers
****** the return value from a fs call is a buffer
****** the buffer class provides a raw memory allocation for dealing with binary data directly
****** to get at it's value, we can .toString() the result from a fs call


***** "os" module
****** provides info about the currently running system

**** Testing and Debugging

**** Scaling Your Node Application
*** DONE Intro to NPM as a build tool

**** Basics

***** Scripts are stored in the package.json file
***** npm init
****** runs wizard to create package.json
****** skip test command for now
****** "scripts" lets us execute scripts with npm 

***** Installing Scripts
****** npm install
****** --save-dev
****** --save
***** running scripts with npm
****** npm run-script <name-of-script>
****** npm run <name-of-script>
****** npm test == npm t == npm tst == npm run test

***** npm stop
****** runs stop script

***** npm restart
****** runs stop script, then start script
****** unless you make a script named restart

***** adding custom scripts
****** simply name a new key:value in script object

***** the value of a script, is just a unix command
****** ex: "node server.js"

***** check out koa
****** minimalist framework works with generators?
     

**** Pre and Post Hooks

***** Hooks are scripts that contain pre- or -post; ex: pretest/posttest
****** hooks run automatically before and after the base script
****** order of appearance in package.json doesn't matter
****** hooks can be run on their own
***** scripts can be chained by using a post-hook to "npm run next script"


**** Scripts for Development and Test
   
***** you can run multiple scripts with && 
****** "npm run this && npm run that"
****** if the first fails, the second is not run
***** you can ignore errors by combining with ; instead of &&

***** Bundling with browserify
****** lets you require modules client side
****** npm install browserify --save-dev
****** "browserify <targetpath> -o <bundlepath> 
****** -o tells browserify to bundle the first file to the second

***** minifying with uglify
****** npm install uglify --save-dev
****** we want to pipe the result from the browserify to the uglify
****** "browserify <app.js> | uglify -mc > <endpath>"
****** -mc (flag to mangle and compress the file)
****** > redirection operator to output result

***** chaining && piping | redirection >

***** npm run <without any more arguments>
****** lists scripts at our disposal


**** Scripts for Development: Watching

***** mocha can watch tests, rerun if test change

***** " -- " lets us pass arguments into another script
****** EX: "npm run test -- -w -R min"

***** watch
****** takes a command and files to run as arguments

***** nodemon
****** when a file/folder changes, restarts app
****** "nodemon --ignore client --ignore public index.js"
****** starts index.js file

***** client side watching 
****** coffeescript and typescript have built in options
****** watchify ! from browserify
******* "watchify <from> -o <to> -dv"
******** -v verbose logging
******** -d delay (doesn't run processor at 100%
****** gotta trigger a bundling if you bundle/minify 
****** but then make changes to base files

***** live browser reload
****** npm install live-reload --save-dev
******* in html, you must serve live-reload client
******* <script src="//localhost:8080" />
****** see npm for more details...

***** run tasks concurrently with &


**** Versioning, Pushing, and Deploying

***** increment version number
****** Semantic Versioning x.y.z
******* major.minor.patch
******* breaking.feature.fix
****** npm version --help
****** npm version <major/minor/patch>
****** this can be scripted!

***** versoning code to git
****** we can use npm version to set git tag
****** in package.sjon, repository, and repo url
****** npm version affects both package.json and git tag in repo
***** pushing code to repo
****** git push --tags 

***** deploy the app
****** as long as there's a command line interface for your provider
***** heroku toolbelt
****** heroku create <name>
******* sets up a git remote
****** deploying is as simple as pushing to the heroku git remote
***** launching the app


**** Deploy Script and Additional Tricks

***** Example process:
  - compile, bundle, & minify serverside javascript
  - bundle & minify client side JS
  - compile CSS
  - new version
  - push to github
  - deploy to heroku
  - open to verify success
*** DONE Webpack Fundamentals (Joe Eames)
**** Intro
***** Why do we need a build?
****** By bunding the files the client needs, the client makes fewer requests to the server
****** reduce code size with minification, compression, etc.
****** file order dependencies: use modules instead of relying on script order
****** transpilation
****** linting / style
***** other solutions
****** server side tools (specific)
****** task runners (grunt, gulp, npm - generic)
***** webpack is a specialized task runner that specialized on file transformation
****** webpack uses npm
****** uses module system(s)
***** module systems express dependencies between files
****** no circular dependencies
****** explicit dependencies permit you to load file dependencies in the right order
**** Basic Builds
***** CLI basics
****** $ npm install webpack
****** webpack takes .js files and bundles them into a bundle
****** to bundle from the CLI : $ webpack ./input.js output.js
***** adding a config file
      The webpack.config.js file exports a Common.js module, an object with keys that tell
      webpack how to do its job. Once we have a config file, we can run webpack from the CLI
      w/o other arguments.At a minimum, the exported object must contain an entry key (the
      path to the entry .js file), and an output property, with a nested filename property
      (the path for the bundle.js)
***** watch mode and the webpack dev server
****** watch mode automatically rebuilds every time a file changes
******* from CLI: webpack --watch
******* in config file add key watch: true
****** webpack has a webserver for us (hotloading)
******* $ npm install webpack-dev-server -g
******* $ webpack-dev-server
******* localhost:8080/webpack-dev-server/ (for auto reload and status bar)
******* localhost:8080/ (for app w/o hot reloading or status bar)
******* if you use --inline when running webpack-dev-server, you can get reloading @ 8080/
***** Bundling multiple files
      Webpack understands the common.js module system, and bundles all dependencies of the
      entry file. In the config, you declare the entry file(s) explicitly, and the entry key
      can be an array of files.
        You must restart the webpack-dev-server to reify changes to the config.
***** using loaders
      By default, webpack can combine and minify files. Loaders let us add functionality. 
      For example, we can use babel to help us support ES6, and jshint for linting. Loaders
      are supplemental modules, npm installed, and saved to package.json. To include loaders
      in our config, we use the 'module.loaders' key. 
****** keys:
******* test: a regex to figure out which files to run through the loader
******* exclude: files to exclude
******* loader: the name of the loader module
******* resolve: an array of file extensions that webpack must process
****** example:

#+BEGIN_SRC js

  module: {
    preLoaders: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: 'jshint-loader'
      }
    ],
    loaders: [
      {
        test: /\.es6$/,
        exclude: /node_modules/,
        loader: 'babel-loader'
      }
    ]
  },
  resolve: {
    extensions: ['', '.js', '.es6']
  },

#+END_SRC

***** using preloaders
      Preloaders run before loaders. The preLoader key takes the same format as loader.
***** creating a start script with npm
      "start": "webpack-dev-server"
***** Production v. Development Builds
      Before deploying our code,  we should minimize the code to save space. Additionally,
      there are some things we might weant to strip out during production, console.logs ex.
****** minimize with the -p CLI flag: 
******* webpack -p
****** the strip-loader lets us strip out code
******* console.log, perfLog, etc.
****** use a separate config file just for production
       We can make a production specific config file, using js modules to require in the
       primary config. Because loaders is an array, we can make an object and push the new
       loader onto the array.
******* Example:

 #+BEGIN_SRC js

 var WebpackStrip = require('strip-loader');
 var devConfig = require('./webpack.config.js');

 var stripLoader = {
   test: [/\.js$/, /\.es6$/],
   exclude: /node-modules/,
   loader: WebpackStrip.loader('console.log')
 }

 devConfig.module.loaders.push(stripLoader);

 module.exports = devConfig;

 #+END_SRC

******* We can specify a a config file other than the default from the CLI
******** $ webpack --config webpack-production.config.js -p
******* $ http-server is a node module that lets us instantiate an http-server w/o webpack
**** Advanced Builds
***** organizing our files and folders
****** We usually organize files in subdirectories of our root directory
       For example, it's common to create root/js/ for all .js files, and a public dir for
       all .html and .css. To facilitate this, we need to give our webpack notice that our
       files reside within a directory within our root directory.
****** We want to exclude our bundles from version control
       So, we will configure webpack to store our bundles in root/build/js/
****** index.html must reference our bundle.js with a logical and accurate path
******* Ex: <script src="/public/assets/js/bundle.js"></script>
****** So we can configure webpack to facilitate the above:
******* Node's path module helps us work with paths
******** var path = require('path');
******* context key tells webpack where to find the entry files, a relative root dir path
******** context: path.resolve('js')
******* output.path key tells webpack where to place bundled files, a relative root dir path
******** path: path.resolve('build/js')
******* output.publicPath key tells webpack where to serve the bundle for the web server
******** publicPath: '/public/assets/js/'
******** this must match the path in our index.html file
******** allows us to redirect requests to public/ into build/
******* devServer key tells webpack where root requests should be directed to
******** contentBase: 'public'
******** this would redirect root requests to the public dir
****** when using the dev-server, the bundle isn't produced and saved to disk
***** working with ES6 modules is easy with babel-loader
      
      Using babel for transpilation allows us to use the ES6 syntax for modules.
      
#+BEGIN_SRC js

  import{login} from './login';

  login('admin', 'radical');

#+END_SRC

***** source map support is built in to webpack
      Source mapping allows us to view our individual and unminified .js files even after
      they have been bundled and minified. This lets us use debugger statements in our dev
      tools (pauses execution).
****** We can generate the source maps for our .js files from the cli:
******* $ webpack -d
******* $ webpack-dev-server -d

***** TODO creating multiple bundles for multiple pages or lazy loading
      We can configure webpack to automatically generate a unique bundle for a set of entry
      files.
****** We need to use the webpack commonsPlugin plugin
**** TODO Adding CSS to your build
**** TODO Adding Images and Fonts to your build
**** TODO Webpack Tools
***** Using the Connect Middleware - a web server
***** Creating a Custom Loader
***** Using Plugins
**** Webpack and Front End Frameworks
***** Webpack React Build
****** babel-preset-react is a loader that processes JSX
****** we refer to babel-preset-react in our .babelrc presets
****** babel-loader is all we need in our webpack config!

*** DONE Git Fundamentals

**** Configure Git

***** Git provides three levels of configuration
****** git config --system
******* stored in /etc/gitconfig
******* applies to entire computer git is installed on
******* not common to modify
****** git config --global
******* user-level config
******* stored in ~/.gitconfig
****** git config
******* Repository Level configuration
******* stored in .git/config in each repo


***** Global Options
****** git config --global user.name "Matthew Hoselton"
****** git config --global user.email "mtthwhsltn@gmail.com"
****** git config --global core.editor emacs
****** git config --global help.autocorrect 1
******* waits a number before executing? helps autocorrect mispelled commands
****** git config --global color.ui auto
******* lets colors help for diffing, status, etc.
****** git config --global core.autocrlf (true|false|input)
******* Not necessary for mac - carriage return line feed - use input
****** git config --global list
******* display global settings


***** Repo Options
******* Overrides global settings for a repo
****** git config user.name
****** git config list
****** git config --unset user.name 
******* unsets a config, reverts to global


**** Working Locally

***** Creating a Local Repo, Adding Files, and Committing Changes
****** git init
******* makes the current working directory a repo
******* creates a .git fir containing the repo and its metadata
****** git status
******* tells you what files are in repo
******* and which of those files have been changed
****** git add
******* stages a file to be added to the repo
******* -u (for updated) adds tracked & modifed files to staging area
******* -A includes all files, including untracked files
****** git commit
******* commits all staged files
******* opens default text editor to input a message
******* -m "" lets you put message inline instead of in text editor
******* git identifies commits with a SHA1 hash


***** Viewing History and Diffs
****** git log
******* shows the history of commits and SHAs
****** git diff <initial-commit-sha-hash> <later-commit-sha-hash>
******* shows what's different betwen two commits
******* the latest commit is the HEAD
******* if you do not specify a SHA, git assumes that you mean HEAD
******* thus "git diff HEAD~1" diffs the HEAD against the commit b/f HEAD
******* ~ just beack back from HEAD, ~3 means back 3,


***** Staging Changes as Multiple Commits
****** Multiple Adds / Multiple Commits
******* You can break commits up into logical units
******* after adding related files, commit them; Repeat


***** Delete and remanimg files
****** git add -u
******* also stages deletions
****** git add -A
******* if you change a file name, git thinks you deleted it and added a new file 
******* upon adding the untracked file, git will recognize the rename operation


***** Undoing Changes to the Working Copy
****** git checkout <filename>
******* grabs head version out of repo and reverts any changes made to file since
****** git reset --hard
******* resets working copy back to HEAD


***** Undoing/Redoing Changes in the Repo
****** git reset --soft HEAD~1
******* rolls back working cpoy to stage before commit?
******* helps to fix things in local repo before pushing to remote repo


***** Cleaning the Working Copy
****** git clean
******* lets you remove files
******* -n tells you what it would do
******* -f (force) actually makes it happen


***** Ignoring Files with .gitignore
****** .gitignore in root dir
******* ignores files in file 
******* list relative to root of repo
******* good for anything that shouldn't be part of repo
****** git add .gitignore
******* so you don't have to edit .gitignore via text editor


**** Working Remotely

***** Cloning a Remote Repo
****** git clone <repo-url>
******* downloads all commits for repo
******* pretty fast
****** git log -oneline
******* one commit per line


***** Basic Repo Stats
****** git log --oneline | wc -l
******* word count (wc) line by line (l) 
******* -graph gives a graph of banches and merges
****** git shortlog
******* lists authors and messages from each commit
******** organized by authors
******* -s (summary) -n(numberofcommits) -e(email) // 
******* -sne organized by number of commits
****** githup proves a graphs option
******* more interactive and visual


***** Viewing Commits
****** git show HEAD
******* shows you the last commit
****** git show HEAD~6
****** git show <SHA>
****** git remote -v
******* shows number of remotes
******* ORIGIN is the default name for where the source came from
******* -verbose shows url for remote


***** Git Protocols
****** http / https
******* default ports 80/443
******* permits read / write access (can demand password)
******* on github, read is allowed, but password for auth to make changes
******* firewall friendly
****** git 
******* different ballgame
****** ssh
******* port 22, secure, standard in unix env's
******* read/write
******* ssh keys for auth
****** file
******* local only
******* read / write
******* path name for repo on system


***** Viewing Branches and Tags
****** git branch
******* what branch are we on?
****** git branch -r
******* lists branches for repo
******* branches are used to separate mainline dev. from bug fixes, features, etc.


***** Fetching from a Remote
****** git remote -v
******* on a local repo, there is no remote
****** git remote add origin <repo-url>
******* permits you to add a remote to a local repo
******* you can add multiple remotes, to facilitate merges, patching, etc
****** git fetch
******* pulls down changes from remote repo
******* if you have multiple remotes, you can spefic the remote to fetch from
******* if you fetch, you have to merge to bring remote diffs into local repo
****** git merge origin/master
******* this merges changes in from the origin/master
******* this is a fast-forward: no conflicts, just add a new HEAD
******* local branch was up-to-date except for one commit


***** Pulling from a Remote
****** git branch -r
******* this shows the branch of remote you just used
******* git has a shortcut for git fetch & git merge
****** git pull
******* combines git branch -t & git merge
****** git branch --set-upstream master origin/master
******* sets remote tracking branch, from where should git pull
******* master (local) to origin/master (remote)
******* not you can git pull automatically from the origin./master
******* cloning sets upstream branch automatically


***** Pushing to a Remote
****** git push
******* do after committing
****** git remote nm origin
******* removes origin
******* re-add origin as the ssh version to avoid password repetition
******* ssh lets you use ssh key, see above


***** Creating and Verifying Tags
****** git tag <name>
******* tag HEAD of remo
******* -a -m to add a "message"
******* -s (signed) requires a passphrase to unlock signing key
******* -v (verifies a signed tag)
****** git tag
******* displays the current tag of repo
******* you can get back to a past state by following the tag to the tagged 


***** Pushing Tags to a Remote
****** git push --tags
******* git push does not push tags by default, you must use --tags


**** Branching, Merging, and Rebasing with Git

***** Visualizing branches
****** git log --graph --online
******* produces list of commits w/ graph of commits
******* --all allows us to visualize all branches, not jus tthe current one
******* --decorate adds labels like ;tags;HEAD;remote branches;local branches;
****** We can add these options in git gonfig
******* git config --global alias.lga "log --graph --oneline --all --decorate"

****** git lga (custom command see above)


***** Creating local branches
****** git branch <branch-name>
******* creates local branch called branch-name
****** git checkout <branch-name>
******* switches to branch-name branch


***** Difference between branches and tags
****** branches follow commits, new commits extend a branch
****** tags stay on a particular commit, a friendly name for the SHA1 hash
****** NOTE: branches are labels on the SHA1 hashes of individual commits


***** Renaming and deleting branches
****** git branch -m <oldname> <newname> ;;rename branch
****** git branch -d <branchname> ;;delete branch
******* only deletes if the branch has been merged into master, otherwise you have to use -D
****** git checkout -b <branch-name> ;;create new branch


***** Recovering deleted commits
****** git reflog ;;log of all refrences, where HEAD has pointed, even deleted
****** git branch <branchname> <commit-SHA> ;;reapplies branch label to commit
******* git doesn't keep dangling commits forever, 30days


***** Stashing changes
****** you can stash changes that you're not ready to commit
****** git stash ;;rolls back changes, puts changes into holding area
****** git stash apply ;;reapplies changes from stash
****** git stash list
****** git stash pop ;;reapplies changes from stash, and removes changes from stash list
****** git reset --hard HEAD
****** git stash branch <new-branch-name>


***** Merging branches
****** git merge <branch-name>
****** "fast-forward"
******* doesn't require resolving conflicts between files
****** "merge-conflicts"
******* git has a standard way to display conflicts
******* merge conflicts can be resolved in a text editor, other tools are available
******* git merge-tool ;;KDiff3 3-way merge tool, app for MacOS
****** git diff --cached ;;compares repo to staging area


***** Rebasing changes
****** git rebase master ;;relocates current branch to master (fast-forward only)
****** if there's a merge conflict:
******* gotta resolve conflict, see "merge-conflicts"
******* git rebase continue


***** Cherry-picking changes
****** git cherry-pick ;;allows you to apply a simgle commit to master
******* useful to apply patches without baggage


***** Creating a remote branch
****** git fetch origin master
****** git push origin <name-of-local-branch> ;;creates new remote branch of same name of local
****** git branch -r ;;lists remote branches


***** Deleting a remote branch
****** git branch -r
****** git push :<branch-name-to-delete>

*** DONE Real Time Web w/ Node
**** HTMl5 Facades
     - Facade is a thin layer of abstraction over an API
       a layer between the native API and your production code
       insulates your code from changes in the native API
       permits a single change in the facade, instead of changes throught your code
       ex: don't use canvas directly, use a facade
     - h5ive gethub repo
***** Storage API
     - local storage and session storage
     - permit persistent storage on client's browser
     - cookies were old-school way, but transmitted data with every request, limiging
       because bogged down requests
       - session cookies persisted for the length of the browser instance
       - shared cookie across windows and tabs
       - ends on logout or browser exit
     - Session storage persists for lifetime of session
       - based upon the tab session
       - each tab permits a new session
       - basically  key-value pairs
       - use for session IDs, etc.
       - doesn't transmit session IDs
     - Local storage persists FOREVER
       - Few people know about deleting cache, cookies, etc.
       - Doesn't delete local storage
       - Doesn't have a mechanism for  expiration, must delete manually
       - Have migration scripts in place to keep local storage clean
       - useful for username, preferences, etc.
     - h5.storage (facade)
       - you decide at construction time, how long you want the data to persist
         - if you want it to expire with the session, it'll use session storage
         - no expiration, works like local storage
         - if you give it a timeline, it will store it in localsotrage with a timestamp wrapper
         - the api will automatically clean up local storage based on the timestamp of requests
     - storage events
       - as soon as you change session or local storage, it will fire an event
       - you can listen to in the browser, and any other browsers attached to the store
       - cross-window messaging

***** Canvas API
      - annoying things
        - two different coordinate systems
          - addressable space (num of pixels)
          - physical display space (css size of space, width and height)
          - rarely useful (zooming maybe?)
          - facade matches dimensions
        - no chainability
          - api implements chainability
        - Paths
          - if you don't give it an initial starting point for a path
          - it might assume 0, 0
          - or it might assume the first point you give it
          - api assumes 0, 0
        - rotate (also scaling, skewing)
          - you're not rotating the drawing
          - you're rotating the coordinate system
          - clockwise in one is countercloskwise in the other
          - facade fixes this

***** getUserMedia
      - allowes us to use JS to get user media streams
      - take the stream and set it as the sorce element to a video tag,
      - and that lets us display the stream to the user
      - h5.userMedia - supersimple facade
      - same object we wound transport across WebRTC to stream to another user

***** requestAnimationFrame
      - not just about animation
      - basically an API that says permits any visual changes, usually in css, you can 
        tell the browser to run that function when it's convienent for the update to occur
      - browser is good at keeping itself in sync with the monitor
      - css updates could be out of sync with the prior two
      - requestAnimationFrame permits the css to sync optimally by letting the browser
        schedule the repaint
      - helps ensure fast transitions occur correctly
      - h5.animationFrame - facade

***** Web Sockets
      - websockets
        - 500-800 ms per ajax request, gotta have http requests
        - websockets keep sockets open, so only one initial http connection
        - 50-100 ms latency - much faster than ajax
        - still might be too slow for games
      - real-time (misnomer)
        - we're not talking sub microsecond response times
      - socket.io
        - few people use the native API
        - socket.io is well known, and common
        - API is basically identical between client and server
          - it's evented!
        - servers can broadcast to all clients
      - it's different to scale, limited number of server ports, etc.
      - what's next?

**** Node.js
***** Node.js Observations
****** What does node do well?
******* really good at communication: i/o
******* no so good at stadic serving of big files
****** "middle end"
******* middleend.com
******* theres a certain core set of tasks that always happens
******* the front end needs control, but the back end has it deeply embedded
******* ex: validation rules, templating, url writing, data formatting, routing, etc.

***** Hello World
****** There's no environment, ther's no dom, no browser, no doctype, etc.
****** how does node do i/o? where does that capability come from?
****** V8, the javascript engine, has no concept of I/O
****** V8 could run in any environment... on a browser, on a phone, in a arduino, etc.
****** Node provides a hosting env. for V8
****** the C wrapper handles this
****** we could also do stdout;

***** Accepting Input
****** what if we wanted to accept input from the cmd line
****** ex: when we write node 1.js --name=matthew
****** --name= is an argument to node 1.js
****** the syntax is very c like
****** that argument data is available in our JS via minimist
******* minimist allows us to store these arguments in an array: process.argv
******* the first element of an array from the previous example would be "node", second "1.js", 3rd "matthew"
****** minimist - OUR FIRST HELPER MODULE
******* parses our arguments
******* instead of manipluating the argv array directly,
******* we're going to pull the name property from argv
******* we could now $ node 1.js --name=World > Hello World
******* documentation describes all helper methods
     - NOTE you can add a header to a .js file that tells the terminal to run the file with node
       then you can directly invoke that filename in bash, as if it were a shell script

***** Adding Help
****** our own print help

***** File IO and Modules
****** node has a standard, built-in module for reading files: fs
******* fs.fileReadSync(filename)
****** everything in data transfer is done in an array buffer
******* an efficient binary representation of our data
******* we can parse our buffer with .toString()
     
***** Asynchronous File IO
****** most natural path is the module pattern and the require system, 
******* vs. prototypal inheritance & classes
****** In general you usually want to write non-blocking APIS, 
****** node usually procides a default and a sync option
****** to use the async function, we use CALLBACKS
******* node uses err first callback, the first param is always reserved for an error
******* whe using node modules, like fs, we assume that the first argument passed to a call back is an error, if any
******* the next argument is going to be the 
****** The setTimeout demonstrates the async-ity
******* for some reason setTimeout will execute a function passed to it by reference right away?
******* why is there a difference when it's wrapped in a function?

***** Asynquence
****** We can express our callbacks as a sequence
******* We must require both asynquence and asynquence-contrib
******* we instantiate a sq from ASQ, and pass it as the callback to the node function - which expects (err, callback)
******* the readFile returns the contents to sq
******* the then, done, val, and or methods are from asynquence
******* later
******* when I call hello.say I pass it a file name and I either get the content or an error.

***** Creating NPM Modules
****** we need to do configuration outsied of our file, we need a package.json file
****** npm init will build it for you
****** name: must be unique
****** version: follow good semantic versioning
******* verions can only increment, must be changed upon update, no overwrites
****** description: not required
****** main: main point of entry to the file 
******* what's require going to pull in?
****** dependencies: what and what version?

***** Publishing NPM Modules
****** npm publish and use the name of the module! easy
****** then we can npm install and require('name')

***** Extending Modules
****** Browserify will include necessary functionality so that a node module will run in the browser
******* our module relies on the fs, not going to work natively in browser
******* common JS in node
****** UMD: Universal Module Definition
*******  one module format, available in all environments!

***** Grunt and Gulp
****** build process tools
****** make files, bash scripts
****** grunt is a configuration based approach, declare steps for build process
****** gulp is more node-like, no config, 
****** npm!

***** File Streams (3b)
****** Streams are an abstraction on IO, using buffers, which are highly memory efficient
******* req and res are input and output streams
****** fs.readFile reads the file in one big chunk, the entire file loads then proceeds to output
****** creating a stream
******* we can swap out this part of our code with a stream, w/o modifying the rest of our code.
******* we can create a stream variable and assign it a read stream and corresponding filename
******* anytime we get a chunk of data, a 'data' event fires
******* each time it does this, we'll concat our return var
******* when the stream is finished, it will emit an 'end' event
******* node has a default buffer size, each chunk is this buffer size, so there might be many data events emitted

***** Piping Streams
****** we can pipe the output of one stream into the input of another stream
****** our code creates a new file!
****** checkout node stream playground @ www.nodestreams.com
****** 

***** Node as a Webserver (4.server.js)
****** node is at it's best when its serving http requests
****** the http module lets us deal with inbound and outbound http requests
****** we can create an http server with:
****** http.createServer(httpRequestHandlingFunction).listen(port, host);
****** our handler takes two arguments: (req, res)
****** executing our 4.server.js file sets up an infinite event loop
****** it'll listen forever
****** we can also install the "forever" module
******* a process manager, if the process dies, it restarts it immediately

***** Handling Requests
****** we can control our response headers
******* res.writeHead(<statusCode>, <content-type>)
****** and we can see the type of request method, url, etc
****** this allows us to rool our own routing, url requests, etc.
****** we can do all of the query string manip that express provides with RegExs

***** Simulating Asyncronicity (5)
****** let's simulate some async!
****** putting in some setTimeouts

***** Adding Asyquence
****** using ASQ

***** Serving Static Files (6)
****** node-static
******* lets us create a static file server
******* the first variable we pass to the static_server instance is a directory name
******* this is the directory we want to serve our static files from
******* .serve passes control to the static server to sniff the req, and form the res
******* req.resume gives control back to the http server
****** the regexs are designed to only recognize only urls that contain a number ex: /6 but !/foo
****** the second regex makes that number translate to num.html, ex: /6 becomes 6.html
****** static fileserver gzips stuff, sometimes automatically

**** socket.io
***** sockets!
****** initial http request, handshake, and upgrade to persistent connection
****** you want to be using SSL on your websockets
****** socket.io is an extension on websockets
****** we're going to use 0.9.16 version
